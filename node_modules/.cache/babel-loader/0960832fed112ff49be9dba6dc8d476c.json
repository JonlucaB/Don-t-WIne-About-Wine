{"ast":null,"code":"var mathUtils = require('../../math/mathUtils');\n/**\n * @class Spherical harmonics surface evaluator based on code by Paul Bourke:\n * http://local.wasp.uwa.edu.au/~pbourke/geometry/sphericalh/\n * @member toxi\n */\n\n\nvar SphericalHarmonics = function (m) {\n  this.m = m;\n};\n\nSphericalHarmonics.prototype = {\n  // toxiclibs - FIXME check where flipped vertex order is coming from sometimes\n  computeVertexFor: function (p, phi, theta) {\n    var r = 0;\n    r += Math.pow(mathUtils.sin(this.m[0] * theta), this.m[1]);\n    r += Math.pow(mathUtils.cos(this.m[2] * theta), this.m[3]);\n    r += Math.pow(mathUtils.sin(this.m[4] * phi), this.m[5]);\n    r += Math.pow(mathUtils.cos(this.m[6] * phi), this.m[7]);\n    var sinTheta = mathUtils.sin(theta);\n    p.x = r * sinTheta * mathUtils.cos(phi);\n    p.y = r * mathUtils.cos(theta);\n    p.z = r * sinTheta * mathUtils.sin(phi);\n    return p;\n  },\n  getPhiRange: function () {\n    return mathUtils.TWO_PI;\n  },\n  getPhiResolutionLimit: function (res) {\n    return res;\n  },\n  getThetaRange: function () {\n    return mathUtils.PI;\n  },\n  getThetaResolutionLimit: function (res) {\n    return res;\n  }\n};\nmodule.exports = SphericalHarmonics;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/mesh/SphericalHarmonics.js"],"names":["mathUtils","require","SphericalHarmonics","m","prototype","computeVertexFor","p","phi","theta","r","Math","pow","sin","cos","sinTheta","x","y","z","getPhiRange","TWO_PI","getPhiResolutionLimit","res","getThetaRange","PI","getThetaResolutionLimit","module","exports"],"mappings":"AAEA,IAAIA,SAAS,GAAGC,OAAO,CAAC,sBAAD,CAAvB;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAIC,kBAAkB,GAAG,UAASC,CAAT,EAAY;AACjC,OAAKA,CAAL,GAASA,CAAT;AACH,CAFD;;AAIAD,kBAAkB,CAACE,SAAnB,GAA+B;AAC3B;AACAC,EAAAA,gBAAgB,EAAE,UAASC,CAAT,EAAWC,GAAX,EAAeC,KAAf,EAAsB;AACpC,QAAIC,CAAC,GAAG,CAAR;AACAA,IAAAA,CAAC,IAAIC,IAAI,CAACC,GAAL,CAASX,SAAS,CAACY,GAAV,CAAc,KAAKT,CAAL,CAAO,CAAP,IAAYK,KAA1B,CAAT,EAA2C,KAAKL,CAAL,CAAO,CAAP,CAA3C,CAAL;AACAM,IAAAA,CAAC,IAAIC,IAAI,CAACC,GAAL,CAASX,SAAS,CAACa,GAAV,CAAc,KAAKV,CAAL,CAAO,CAAP,IAAYK,KAA1B,CAAT,EAA2C,KAAKL,CAAL,CAAO,CAAP,CAA3C,CAAL;AACAM,IAAAA,CAAC,IAAIC,IAAI,CAACC,GAAL,CAASX,SAAS,CAACY,GAAV,CAAc,KAAKT,CAAL,CAAO,CAAP,IAAYI,GAA1B,CAAT,EAAyC,KAAKJ,CAAL,CAAO,CAAP,CAAzC,CAAL;AACAM,IAAAA,CAAC,IAAIC,IAAI,CAACC,GAAL,CAASX,SAAS,CAACa,GAAV,CAAc,KAAKV,CAAL,CAAO,CAAP,IAAYI,GAA1B,CAAT,EAAyC,KAAKJ,CAAL,CAAO,CAAP,CAAzC,CAAL;AAEA,QAAIW,QAAQ,GAAGd,SAAS,CAACY,GAAV,CAAcJ,KAAd,CAAf;AACAF,IAAAA,CAAC,CAACS,CAAF,GAAMN,CAAC,GAAGK,QAAJ,GAAed,SAAS,CAACa,GAAV,CAAcN,GAAd,CAArB;AACAD,IAAAA,CAAC,CAACU,CAAF,GAAMP,CAAC,GAAGT,SAAS,CAACa,GAAV,CAAcL,KAAd,CAAV;AACAF,IAAAA,CAAC,CAACW,CAAF,GAAMR,CAAC,GAAGK,QAAJ,GAAed,SAAS,CAACY,GAAV,CAAcL,GAAd,CAArB;AACA,WAAOD,CAAP;AACH,GAd0B;AAgB3BY,EAAAA,WAAW,EAAE,YAAW;AACpB,WAAOlB,SAAS,CAACmB,MAAjB;AACH,GAlB0B;AAoB3BC,EAAAA,qBAAqB,EAAE,UAASC,GAAT,EAAc;AACjC,WAAOA,GAAP;AACH,GAtB0B;AAwB3BC,EAAAA,aAAa,EAAE,YAAW;AACtB,WAAOtB,SAAS,CAACuB,EAAjB;AACH,GA1B0B;AA4B3BC,EAAAA,uBAAuB,EAAE,UAASH,GAAT,EAAc;AACnC,WAAOA,GAAP;AACH;AA9B0B,CAA/B;AAiCAI,MAAM,CAACC,OAAP,GAAiBxB,kBAAjB","sourcesContent":["\n\nvar mathUtils = require('../../math/mathUtils');\n\n/**\n * @class Spherical harmonics surface evaluator based on code by Paul Bourke:\n * http://local.wasp.uwa.edu.au/~pbourke/geometry/sphericalh/\n * @member toxi\n */\nvar SphericalHarmonics = function(m) {\n    this.m = m;\n};\n\nSphericalHarmonics.prototype = {\n    // toxiclibs - FIXME check where flipped vertex order is coming from sometimes\n    computeVertexFor: function(p,phi,theta) {\n        var r = 0;\n        r += Math.pow(mathUtils.sin(this.m[0] * theta), this.m[1]);\n        r += Math.pow(mathUtils.cos(this.m[2] * theta), this.m[3]);\n        r += Math.pow(mathUtils.sin(this.m[4] * phi), this.m[5]);\n        r += Math.pow(mathUtils.cos(this.m[6] * phi), this.m[7]);\n\n        var sinTheta = mathUtils.sin(theta);\n        p.x = r * sinTheta * mathUtils.cos(phi);\n        p.y = r * mathUtils.cos(theta);\n        p.z = r * sinTheta * mathUtils.sin(phi);\n        return p;\n    },\n\n    getPhiRange: function() {\n        return mathUtils.TWO_PI;\n    },\n\n    getPhiResolutionLimit: function(res) {\n        return res;\n    },\n\n    getThetaRange: function() {\n        return mathUtils.PI;\n    },\n\n    getThetaResolutionLimit: function(res) {\n        return res;\n    }\n};\n\nmodule.exports = SphericalHarmonics;\n\n"]},"metadata":{},"sourceType":"script"}