{"ast":null,"code":"var filter = require('../internals').filter,\n    numberComparator = require('../internals').numberComparator,\n    mathUtils = require('../math/mathUtils'),\n    LinearInterpolation = require('../math/LinearInterpolation'),\n    ColorList = require('./ColorList'); //a protected object for every point on the gradient\n\n\nvar _GradPoint = function (p, c) {\n  this.pos = p;\n  this.color = c;\n};\n\n_GradPoint.prototype = {\n  compareTo: function (p) {\n    if (numberComparator(p.pos, this.pos) === 0) {\n      return 0;\n    }\n\n    return this.pos < p.pos ? -1 : 1;\n  },\n  getColor: function () {\n    return this.color;\n  },\n  getPosition: function () {\n    return this.pos;\n  }\n};\n\nvar ColorGradient = function () {\n  this.gradient = [];\n  this.interpolator = new LinearInterpolation();\n  this.maxDither = 0;\n};\n\nColorGradient.prototype = {\n  /**\n  * Adds a new color at specified position.\n  * @param {Number} p position in the gradient\n  * @param {toxi.color.TColor} c color to add\n  */\n  addColorAt: function (p, c) {\n    this.gradient.push(new _GradPoint(p, c));\n  },\n\n  /**\n  * Calculates the gradient from specified position.\n  * @param {Number} pos position to start at (float)\n  * @param {Number} width (integer)\n  * @return list of interpolated gradient colors\n  */\n  calcGradient: function (pos, width) {\n    if (arguments.length === 0) {\n      pos = this.gradient[0].getPosition();\n      var last = this.gradient[this.gradient.length - 1].getPosition();\n      width = Math.floor(last - pos);\n    }\n\n    var result = new ColorList();\n\n    if (this.gradient.length === 0) {\n      return result;\n    }\n\n    var frac = 0,\n        currPoint,\n        nextPoint,\n        endPos = pos + width,\n        i = 0,\n        l = this.gradient.length;\n\n    for (i = 0; i < l; i++) {\n      if (this.gradient[i].pos < pos) {\n        currPoint = this.gradient[i];\n      }\n    }\n\n    var isPremature = currPoint === undefined,\n        activeGradient;\n\n    if (!isPremature) {\n      activeGradient = filter(this.gradient, function (g) {\n        return g.pos >= currPoint.pos;\n      });\n    } else {\n      //start position is before 1st gradient color, so use whole\n      activeGradient = this.gradient;\n      currPoint = this.gradient[0];\n    }\n\n    var currWidth = 0; //start over with i, and use it to iterate\n\n    i = 0;\n    l = activeGradient.length;\n\n    if (currPoint !== activeGradient[l - 1]) {\n      nextPoint = activeGradient[i];\n\n      if (isPremature) {\n        var d = currPoint.pos - pos;\n        currWidth = mathUtils.abs(d) > 0 ? 1 / d : 1;\n      } else {\n        if (nextPoint.pos - currPoint.pos > 0) {\n          currWidth = 1 / (nextPoint.pos - currPoint.pos);\n        }\n      }\n    }\n\n    while (pos < endPos) {\n      if (isPremature) {\n        frac = 1 - (currPoint.pos - pos) * currWidth;\n      } else {\n        frac = (pos - currPoint.pos) * currWidth;\n      } //switch to next color?\n\n\n      if (frac > 1.0) {\n        currPoint = nextPoint;\n        isPremature = false;\n        i++;\n\n        if (i < activeGradient.length) {\n          nextPoint = activeGradient[i];\n\n          if (currPoint !== activeGradient[l - 1]) {\n            currWidth = 1 / (nextPoint.pos - currPoint.pos);\n          } else {\n            currWidth = 0;\n          }\n\n          frac = (pos - currPoint.pos) * currWidth;\n        }\n      }\n\n      if (currPoint !== activeGradient[l - 1]) {\n        var ditheredFrac = mathUtils.clip(frac + mathUtils.normalizedRandom() * this.maxDither, 0, 1);\n        ditheredFrac = this.interpolator.interpolate(0, 1, ditheredFrac);\n        result.add(currPoint.color.getBlended(nextPoint.color, ditheredFrac));\n      } else {\n        result.add(currPoint.color.copy());\n      }\n\n      pos++;\n    }\n\n    return result;\n  },\n  getGradientPoints: function () {\n    return this.gradient;\n  },\n\n  /**\n  * @return the interpolator\n  */\n  getInterpolator: function () {\n    return this.interpolator;\n  },\n\n  /**\n  * @return the maximum dither amount.\n  */\n  getMaxDither: function () {\n    return this.maxDither;\n  },\n\n  /**\n  * @param interpolator the interpolator to set\n  */\n  setInterpolator: function (interpolator) {\n    this.interpolator = interpolator;\n  },\n\n  /**\n  * Sets the maximum dither amount. Setting this to values >0 will jitter the\n  * interpolated colors in the calculated gradient. The value range for this\n  * parameter is 0.0 (off) to 1.0 (100%).\n  * @param {Number} maxDither\n  */\n  setMaxDither: function (maxDither) {\n    this.maxDither = mathUtils.clip(maxDither, 0, 1);\n  }\n};\nmodule.exports = ColorGradient;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/color/ColorGradient.js"],"names":["filter","require","numberComparator","mathUtils","LinearInterpolation","ColorList","_GradPoint","p","c","pos","color","prototype","compareTo","getColor","getPosition","ColorGradient","gradient","interpolator","maxDither","addColorAt","push","calcGradient","width","arguments","length","last","Math","floor","result","frac","currPoint","nextPoint","endPos","i","l","isPremature","undefined","activeGradient","g","currWidth","d","abs","ditheredFrac","clip","normalizedRandom","interpolate","add","getBlended","copy","getGradientPoints","getInterpolator","getMaxDither","setInterpolator","setMaxDither","module","exports"],"mappings":"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","sourcesContent":["\n\n\nvar filter = require('../internals').filter,\n\tnumberComparator = require('../internals').numberComparator,\n\tmathUtils = require('../math/mathUtils'),\n\tLinearInterpolation = require('../math/LinearInterpolation'),\n\tColorList = require('./ColorList');\n\n//a protected object for every point on the gradient\nvar _GradPoint = function(p, c){\n\tthis.pos = p;\n\tthis.color = c;\n};\n\n_GradPoint.prototype = {\n\tcompareTo: function(p){\n\t\tif(numberComparator(p.pos,this.pos) === 0){\n\t\t\treturn 0;\n\t\t}\n\t\treturn this.pos < p.pos ? -1 : 1;\n\t},\n\tgetColor: function(){\n\t\treturn this.color;\n\t},\n\tgetPosition: function(){\n\t\treturn this.pos;\n\t}\n};\n\nvar ColorGradient = function(){\n\tthis.gradient = [];\n\tthis.interpolator = new LinearInterpolation();\n\tthis.maxDither = 0;\n};\n\nColorGradient.prototype = {\n\t/**\n\t* Adds a new color at specified position.\n\t* @param {Number} p position in the gradient\n\t* @param {toxi.color.TColor} c color to add\n\t*/\n\taddColorAt: function(p, c){\n\t\tthis.gradient.push(new _GradPoint(p,c));\n\t},\n\t/**\n\t* Calculates the gradient from specified position.\n\t* @param {Number} pos position to start at (float)\n\t* @param {Number} width (integer)\n\t* @return list of interpolated gradient colors\n\t*/\n\tcalcGradient: function(pos, width){\n\t\tif( arguments.length === 0 ){\n\t\t\tpos = this.gradient[0].getPosition();\n\t\t\tvar last = this.gradient[this.gradient.length-1].getPosition();\n\t\t\twidth = Math.floor(last - pos);\n\t\t}\n\n\t\tvar result = new ColorList();\n\t\tif( this.gradient.length === 0 ){\n\t\t\treturn result;\n\t\t}\n\n\t\tvar frac = 0,\n\t\t\tcurrPoint, nextPoint,\n\t\t\tendPos = pos + width,\n\t\t\ti = 0,\n\t\t\tl = this.gradient.length;\n\n\t\tfor( i=0; i<l; i++ ){\n\t\t\tif( this.gradient[i].pos < pos ){\n\t\t\t\tcurrPoint = this.gradient[i];\n\t\t\t}\n\t\t}\n\n\t\tvar isPremature = (currPoint===undefined),\n\t\t\tactiveGradient;\n\t\tif( !isPremature ){\n\t\t\tactiveGradient = filter(this.gradient, function( g ){ return g.pos >= currPoint.pos; });\n\t\t} else {\n\t\t\t//start position is before 1st gradient color, so use whole\n\t\t\tactiveGradient = this.gradient;\n\t\t\tcurrPoint = this.gradient[0];\n\t\t}\n\n\t\tvar currWidth = 0;\n\t\t//start over with i, and use it to iterate\n\t\ti = 0;\n\t\tl = activeGradient.length;\n\t\tif( currPoint !== activeGradient[l-1] ){\n\t\t\tnextPoint = activeGradient[i];\n\t\t\tif( isPremature ){\n\t\t\t\tvar d = currPoint.pos - pos;\n\t\t\t\tcurrWidth = mathUtils.abs( d ) > 0 ? 1 / d : 1;\n\t\t\t} else {\n\t\t\t\tif( nextPoint.pos - currPoint.pos > 0 ) {\n\t\t\t\t\tcurrWidth = 1 / (nextPoint.pos - currPoint.pos);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\twhile( pos < endPos ){\n\t\t\tif( isPremature ){\n\t\t\t\tfrac = 1 - (currPoint.pos - pos) * currWidth;\n\t\t\t} else {\n\t\t\t\tfrac = (pos - currPoint.pos) * currWidth;\n\t\t\t}\n\t\t\t//switch to next color?\n\t\t\tif( frac > 1.0 ){\n\t\t\t\tcurrPoint = nextPoint;\n\t\t\t\tisPremature = false;\n\t\t\t\ti++;\n\t\t\t\tif( i < activeGradient.length ){\n\t\t\t\t\tnextPoint = activeGradient[i];\n\t\t\t\t\tif( currPoint !== activeGradient[l-1] ){\n\t\t\t\t\t\tcurrWidth = 1 / (nextPoint.pos - currPoint.pos);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tcurrWidth = 0;\n\t\t\t\t\t}\n\t\t\t\t\tfrac = (pos - currPoint.pos) * currWidth;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif( currPoint  !== activeGradient[l-1] ){\n\t\t\t\tvar ditheredFrac = mathUtils.clip( frac+mathUtils.normalizedRandom() * this.maxDither, 0, 1 );\n\t\t\t\tditheredFrac = this.interpolator.interpolate( 0, 1, ditheredFrac );\n\t\t\t\tresult.add( currPoint.color.getBlended(nextPoint.color, ditheredFrac) );\n\t\t\t} else {\n\t\t\t\tresult.add( currPoint.color.copy() );\n\t\t\t}\n\t\t\tpos++;\n\t\t}\n\t\treturn result;\n\n\t},\n\tgetGradientPoints: function(){\n\t\treturn this.gradient;\n\t},\n\t/**\n\t* @return the interpolator\n\t*/\n\tgetInterpolator: function(){\n\t\treturn this.interpolator;\n\t},\n\t/**\n\t* @return the maximum dither amount.\n\t*/\n\tgetMaxDither: function(){\n\t\treturn this.maxDither;\n\t},\n\t/**\n\t* @param interpolator the interpolator to set\n\t*/\n\tsetInterpolator: function(interpolator){\n\t\tthis.interpolator = interpolator;\n\t},\n\t/**\n\t* Sets the maximum dither amount. Setting this to values >0 will jitter the\n\t* interpolated colors in the calculated gradient. The value range for this\n\t* parameter is 0.0 (off) to 1.0 (100%).\n\t* @param {Number} maxDither\n\t*/\n\tsetMaxDither: function(maxDither){\n\t\tthis.maxDither = mathUtils.clip(maxDither, 0, 1);\n\t}\n};\n\tmodule.exports = ColorGradient;\n\n"]},"metadata":{},"sourceType":"script"}