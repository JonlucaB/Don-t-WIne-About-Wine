{"ast":null,"code":"var Vec3D = require('../Vec3D'),\n    TriangleMesh = require('./TriangleMesh'),\n    is = require('../../internals/is');\n/**\n * @class 4x4 bezier patch implementation with tesselation support (dynamic resolution)\n * for generating triangle mesh representations.\n * @member toxi\n */\n\n\nvar BezierPatch = function (points) {\n  if (is.Array(points)) {\n    this.points = points;\n  } else {\n    this.points = [];\n\n    for (var i = 0; i < 4; i++) {\n      this.points[i] = this.points[i] || [];\n\n      for (var j = 0; j < 4; j++) {\n        this.points[i][j] = new Vec3D();\n      }\n    }\n  }\n};\n\nBezierPatch.prototype = {\n  computePointAt: function (u, v) {\n    return BezierPatch.computePointAt(u, v, this.points);\n  },\n  set: function (x, y, p) {\n    this.points[y][x].set(p);\n    return this;\n  },\n  toMesh: function (mesh_or_res, _res) {\n    var mesh, res;\n\n    if (_res === undefined) {\n      mesh = new TriangleMesh();\n      res = mesh_or_res;\n    } else {\n      mesh = mesh_or_res;\n      res = _res;\n    }\n\n    var curr = new Array(res + 1),\n        prev = new Array(res + 1);\n    var r1 = 1.0 / res;\n\n    for (var y = 0; y <= res; y++) {\n      for (var x = 0; x <= res; x++) {\n        var p = this.computePointAt(x * r1, y * r1, this.points);\n\n        if (x > 0 && y > 0) {\n          mesh.addFace(p, curr[x - 1], prev[x - 1]);\n          mesh.addFace(p, prev[x - 1], prev[x]);\n        }\n\n        curr[x] = p;\n      }\n\n      var tmp = prev;\n      prev = curr;\n      curr = tmp;\n    }\n\n    return mesh;\n  }\n};\n/**\nComputes a single point on the bezier surface given by the 2d array of\ncontrol points. The desired point's coordinates have to be specified in\nUV space (range 0.0 .. 1.0). The implementation does not check or enforce\nthe correct range of these coords and will not return valid points if the\nrange is exceeded.\n@param u positive normalized U coordinate on the bezier surface\n@param v positive normalized V coordinate on the bezier surface\n@param points 4x4 array defining the patch's control points\n@return point on surface\n*/\n\nBezierPatch.computePointAt = function (u, v, points) {\n  var u1 = 1 - u;\n  var u1squared = u1 * u1 * 3 * u,\n      u1cubed = u1 * u1 * u1,\n      usquared = u * u,\n      v1 = 1 - v,\n      vsquared = v * v * 3,\n      v1squared = v1 * v1 * 3,\n      v1cubed = v1 * v1 * v1,\n      vcubed = v * v * v,\n      u1usq = u1 * usquared * 3,\n      usqu = u * usquared,\n      v1vsq = v1 * vsquared,\n      v1sqv = v1squared * v;\n  var p0 = points[0];\n  var p1 = points[1];\n  var p2 = points[2];\n  var p3 = points[3];\n  var x = u1cubed * (p0[0].x * v1cubed + p0[1].x * v1sqv + p0[2].x * v1vsq + p0[3].x * vcubed) + u1squared * (p1[0].x * v1cubed + p1[1].x * v1sqv + p1[2].x * v1vsq + p1[3].x * vcubed) + u1usq * (p2[0].x * v1cubed + p2[1].x * v1sqv + p2[2].x * v1vsq + p2[3].x * vcubed) + usqu * (p3[0].x * v1cubed + p3[1].x * v1sqv + p3[2].x * v1vsq + p3[3].x * vcubed);\n  var y = u1cubed * (p0[0].y * v1cubed + p0[1].y * v1sqv + p0[2].y * v1vsq + p0[3].y * vcubed) + u1squared * (p1[0].y * v1cubed + p1[1].y * v1sqv + p1[2].y * v1vsq + p1[3].y * vcubed) + u1usq * (p2[0].y * v1cubed + p2[1].y * v1sqv + p2[2].y * v1vsq + p2[3].y * vcubed) + usqu * (p3[0].y * v1cubed + p3[1].y * v1sqv + p3[2].y * v1vsq + p3[3].y * vcubed);\n  var z = u1cubed * (p0[0].z * v1cubed + p0[1].z * v1sqv + p0[2].z * v1vsq + p0[3].z * vcubed) + u1squared * (p1[0].z * v1cubed + p1[1].z * v1sqv + p1[2].z * v1vsq + p1[3].z * vcubed) + u1usq * (p2[0].z * v1cubed + p2[1].z * v1sqv + p2[2].z * v1vsq + p2[3].z * vcubed) + usqu * (p3[0].z * v1cubed + p3[1].z * v1sqv + p3[2].z * v1vsq + p3[3].z * vcubed);\n  return new Vec3D(x, y, z);\n};\n\nmodule.exports = BezierPatch;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/geom/mesh/BezierPatch.js"],"names":["Vec3D","require","TriangleMesh","is","BezierPatch","points","Array","i","j","prototype","computePointAt","u","v","set","x","y","p","toMesh","mesh_or_res","_res","mesh","res","undefined","curr","prev","r1","addFace","tmp","u1","u1squared","u1cubed","usquared","v1","vsquared","v1squared","v1cubed","vcubed","u1usq","usqu","v1vsq","v1sqv","p0","p1","p2","p3","z","module","exports"],"mappings":"AACA,IAAIA,KAAK,GAAGC,OAAO,CAAC,UAAD,CAAnB;AAAA,IACCC,YAAY,GAAGD,OAAO,CAAC,gBAAD,CADvB;AAAA,IAECE,EAAE,GAAGF,OAAO,CAAC,oBAAD,CAFb;AAIA;AACA;AACA;AACA;AACA;;;AACA,IAAIG,WAAW,GAAG,UAASC,MAAT,EAAgB;AACjC,MAAIF,EAAE,CAACG,KAAH,CAASD,MAAT,CAAJ,EAAsB;AACrB,SAAKA,MAAL,GAAcA,MAAd;AACA,GAFD,MAEO;AACN,SAAKA,MAAL,GAAc,EAAd;;AACA,SAAK,IAAIE,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC3B,WAAKF,MAAL,CAAYE,CAAZ,IAAiB,KAAKF,MAAL,CAAYE,CAAZ,KAAkB,EAAnC;;AACA,WAAK,IAAIC,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG,CAApB,EAAuBA,CAAC,EAAxB,EAA4B;AAC3B,aAAKH,MAAL,CAAYE,CAAZ,EAAeC,CAAf,IAAoB,IAAIR,KAAJ,EAApB;AACA;AACD;AACD;AACD,CAZD;;AAcAI,WAAW,CAACK,SAAZ,GAAwB;AAEvBC,EAAAA,cAAc,EAAE,UAASC,CAAT,EAAWC,CAAX,EAAc;AAC7B,WAAOR,WAAW,CAACM,cAAZ,CAA2BC,CAA3B,EAA8BC,CAA9B,EAAiC,KAAKP,MAAtC,CAAP;AACA,GAJsB;AAMvBQ,EAAAA,GAAG,EAAE,UAASC,CAAT,EAAWC,CAAX,EAAaC,CAAb,EAAgB;AACpB,SAAKX,MAAL,CAAYU,CAAZ,EAAeD,CAAf,EAAkBD,GAAlB,CAAsBG,CAAtB;AACA,WAAO,IAAP;AACA,GATsB;AAWvBC,EAAAA,MAAM,EAAE,UAASC,WAAT,EAAqBC,IAArB,EAA2B;AAClC,QAAIC,IAAJ,EACCC,GADD;;AAEA,QAAGF,IAAI,KAAKG,SAAZ,EAAsB;AACrBF,MAAAA,IAAI,GAAG,IAAIlB,YAAJ,EAAP;AACAmB,MAAAA,GAAG,GAAGH,WAAN;AACA,KAHD,MAGO;AACNE,MAAAA,IAAI,GAAGF,WAAP;AACAG,MAAAA,GAAG,GAAGF,IAAN;AACA;;AACD,QAAII,IAAI,GAAG,IAAIjB,KAAJ,CAAUe,GAAG,GAAG,CAAhB,CAAX;AAAA,QACCG,IAAI,GAAG,IAAIlB,KAAJ,CAAUe,GAAG,GAAG,CAAhB,CADR;AAEA,QAAII,EAAE,GAAG,MAAMJ,GAAf;;AACA,SAAK,IAAIN,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIM,GAArB,EAA0BN,CAAC,EAA3B,EAA+B;AAC9B,WAAK,IAAID,CAAC,GAAG,CAAb,EAAgBA,CAAC,IAAIO,GAArB,EAA0BP,CAAC,EAA3B,EAA+B;AAC9B,YAAIE,CAAC,GAAG,KAAKN,cAAL,CAAoBI,CAAC,GAAGW,EAAxB,EAA4BV,CAAC,GAAGU,EAAhC,EAAoC,KAAKpB,MAAzC,CAAR;;AACA,YAAIS,CAAC,GAAG,CAAJ,IAASC,CAAC,GAAG,CAAjB,EAAoB;AACnBK,UAAAA,IAAI,CAACM,OAAL,CAAaV,CAAb,EAAgBO,IAAI,CAACT,CAAC,GAAG,CAAL,CAApB,EAA6BU,IAAI,CAACV,CAAC,GAAG,CAAL,CAAjC;AACAM,UAAAA,IAAI,CAACM,OAAL,CAAaV,CAAb,EAAgBQ,IAAI,CAACV,CAAC,GAAG,CAAL,CAApB,EAA6BU,IAAI,CAACV,CAAD,CAAjC;AACA;;AACDS,QAAAA,IAAI,CAACT,CAAD,CAAJ,GAAUE,CAAV;AACA;;AACD,UAAIW,GAAG,GAAGH,IAAV;AACAA,MAAAA,IAAI,GAAGD,IAAP;AACAA,MAAAA,IAAI,GAAGI,GAAP;AACA;;AACD,WAAOP,IAAP;AAEA;AAvCsB,CAAxB;AA0CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEAhB,WAAW,CAACM,cAAZ,GAA6B,UAASC,CAAT,EAAWC,CAAX,EAAaP,MAAb,EAAoB;AAC/C,MAAIuB,EAAE,GAAG,IAAIjB,CAAb;AACA,MAAIkB,SAAS,GAAGD,EAAE,GAAGA,EAAL,GAAU,CAAV,GAAcjB,CAA9B;AAAA,MACAmB,OAAO,GAAGF,EAAE,GAAGA,EAAL,GAAUA,EADpB;AAAA,MAEAG,QAAQ,GAAGpB,CAAC,GAAGA,CAFf;AAAA,MAGAqB,EAAE,GAAG,IAAIpB,CAHT;AAAA,MAIAqB,QAAQ,GAAGrB,CAAC,GAAGA,CAAJ,GAAQ,CAJnB;AAAA,MAKAsB,SAAS,GAAGF,EAAE,GAAGA,EAAL,GAAU,CALtB;AAAA,MAMAG,OAAO,GAAGH,EAAE,GAAGA,EAAL,GAAUA,EANpB;AAAA,MAOAI,MAAM,GAAGxB,CAAC,GAAGA,CAAJ,GAAQA,CAPjB;AAAA,MASAyB,KAAK,GAAGT,EAAE,GAAGG,QAAL,GAAgB,CATxB;AAAA,MAUAO,IAAI,GAAG3B,CAAC,GAAGoB,QAVX;AAAA,MAWAQ,KAAK,GAAGP,EAAE,GAAGC,QAXb;AAAA,MAYAO,KAAK,GAAGN,SAAS,GAAGtB,CAZpB;AAcA,MAAI6B,EAAE,GAAGpC,MAAM,CAAC,CAAD,CAAf;AACA,MAAIqC,EAAE,GAAGrC,MAAM,CAAC,CAAD,CAAf;AACA,MAAIsC,EAAE,GAAGtC,MAAM,CAAC,CAAD,CAAf;AACA,MAAIuC,EAAE,GAAGvC,MAAM,CAAC,CAAD,CAAf;AAEA,MAAIS,CAAC,GAAGgB,OAAO,IAAIW,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUqB,OAAV,GAAoBM,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAU0B,KAA9B,GAAsCC,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUyB,KAAhD,GAAwDE,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUsB,MAAtE,CAAP,GAAuFP,SAAS,IAAIa,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUqB,OAAV,GAAoBO,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAU0B,KAA9B,GAAsCE,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUyB,KAAhD,GAAwDG,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUsB,MAAtE,CAAhG,GAAgLC,KAAK,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUqB,OAAV,GAAoBQ,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAU0B,KAA9B,GAAsCG,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUyB,KAAhD,GAAwDI,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUsB,MAAtE,CAArL,GAAqQE,IAAI,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAM9B,CAAN,GAAUqB,OAAV,GAAoBS,EAAE,CAAC,CAAD,CAAF,CAAM9B,CAAN,GAAU0B,KAA9B,GAAsCI,EAAE,CAAC,CAAD,CAAF,CAAM9B,CAAN,GAAUyB,KAAhD,GAAwDK,EAAE,CAAC,CAAD,CAAF,CAAM9B,CAAN,GAAUsB,MAAtE,CAAjR;AAEA,MAAIrB,CAAC,GAAGe,OAAO,IAAIW,EAAE,CAAC,CAAD,CAAF,CAAM1B,CAAN,GAAUoB,OAAV,GAAoBM,EAAE,CAAC,CAAD,CAAF,CAAM1B,CAAN,GAAUyB,KAA9B,GAAsCC,EAAE,CAAC,CAAD,CAAF,CAAM1B,CAAN,GAAUwB,KAAhD,GAAwDE,EAAE,CAAC,CAAD,CAAF,CAAM1B,CAAN,GAAUqB,MAAtE,CAAP,GAAuFP,SAAS,IAAIa,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUoB,OAAV,GAAoBO,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUyB,KAA9B,GAAsCE,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUwB,KAAhD,GAAwDG,EAAE,CAAC,CAAD,CAAF,CAAM3B,CAAN,GAAUqB,MAAtE,CAAhG,GAAgLC,KAAK,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUoB,OAAV,GAAoBQ,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUyB,KAA9B,GAAsCG,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUwB,KAAhD,GAAwDI,EAAE,CAAC,CAAD,CAAF,CAAM5B,CAAN,GAAUqB,MAAtE,CAArL,GAAqQE,IAAI,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUoB,OAAV,GAAoBS,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUyB,KAA9B,GAAsCI,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUwB,KAAhD,GAAwDK,EAAE,CAAC,CAAD,CAAF,CAAM7B,CAAN,GAAUqB,MAAtE,CAAjR;AAEA,MAAIS,CAAC,GAAGf,OAAO,IAAIW,EAAE,CAAC,CAAD,CAAF,CAAMI,CAAN,GAAUV,OAAV,GAAoBM,EAAE,CAAC,CAAD,CAAF,CAAMI,CAAN,GAAUL,KAA9B,GAAsCC,EAAE,CAAC,CAAD,CAAF,CAAMI,CAAN,GAAUN,KAAhD,GAAwDE,EAAE,CAAC,CAAD,CAAF,CAAMI,CAAN,GAAUT,MAAtE,CAAP,GAAuFP,SAAS,IAAIa,EAAE,CAAC,CAAD,CAAF,CAAMG,CAAN,GAAUV,OAAV,GAAoBO,EAAE,CAAC,CAAD,CAAF,CAAMG,CAAN,GAAUL,KAA9B,GAAsCE,EAAE,CAAC,CAAD,CAAF,CAAMG,CAAN,GAAUN,KAAhD,GAAwDG,EAAE,CAAC,CAAD,CAAF,CAAMG,CAAN,GAAUT,MAAtE,CAAhG,GAAgLC,KAAK,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAME,CAAN,GAAUV,OAAV,GAAoBQ,EAAE,CAAC,CAAD,CAAF,CAAME,CAAN,GAAUL,KAA9B,GAAsCG,EAAE,CAAC,CAAD,CAAF,CAAME,CAAN,GAAUN,KAAhD,GAAwDI,EAAE,CAAC,CAAD,CAAF,CAAME,CAAN,GAAUT,MAAtE,CAArL,GAAqQE,IAAI,IAAIM,EAAE,CAAC,CAAD,CAAF,CAAMC,CAAN,GAAUV,OAAV,GAAoBS,EAAE,CAAC,CAAD,CAAF,CAAMC,CAAN,GAAUL,KAA9B,GAAsCI,EAAE,CAAC,CAAD,CAAF,CAAMC,CAAN,GAAUN,KAAhD,GAAwDK,EAAE,CAAC,CAAD,CAAF,CAAMC,CAAN,GAAUT,MAAtE,CAAjR;AAEA,SAAO,IAAIpC,KAAJ,CAAUc,CAAV,EAAaC,CAAb,EAAgB8B,CAAhB,CAAP;AAED,CA7BD;;AA+BAC,MAAM,CAACC,OAAP,GAAiB3C,WAAjB","sourcesContent":["\nvar Vec3D = require('../Vec3D'),\n\tTriangleMesh = require('./TriangleMesh'),\n\tis = require('../../internals/is');\n\n/**\n * @class 4x4 bezier patch implementation with tesselation support (dynamic resolution)\n * for generating triangle mesh representations.\n * @member toxi\n */\nvar BezierPatch = function(points){\n\tif( is.Array(points) ){\n\t\tthis.points = points;\n\t} else {\n\t\tthis.points = [];\n\t\tfor (var i = 0; i < 4; i++) {\n\t\t\tthis.points[i] = this.points[i] || [];\n\t\t\tfor (var j = 0; j < 4; j++) {\n\t\t\t\tthis.points[i][j] = new Vec3D();\n\t\t\t}\n\t\t}\n\t}\n};\n\nBezierPatch.prototype = {\n\n\tcomputePointAt: function(u,v) {\n\t\treturn BezierPatch.computePointAt(u, v, this.points);\n\t},\n\n\tset: function(x,y,p) {\n\t\tthis.points[y][x].set(p);\n\t\treturn this;\n\t},\n\n\ttoMesh: function(mesh_or_res,_res) {\n\t\tvar mesh,\n\t\t\tres;\n\t\tif(_res === undefined){\n\t\t\tmesh = new TriangleMesh();\n\t\t\tres = mesh_or_res;\n\t\t} else {\n\t\t\tmesh = mesh_or_res;\n\t\t\tres = _res;\n\t\t}\n\t\tvar curr = new Array(res + 1),\n\t\t\tprev = new Array(res + 1);\n\t\tvar r1 = 1.0 / res;\n\t\tfor (var y = 0; y <= res; y++) {\n\t\t\tfor (var x = 0; x <= res; x++) {\n\t\t\t\tvar p = this.computePointAt(x * r1, y * r1, this.points);\n\t\t\t\tif (x > 0 && y > 0) {\n\t\t\t\t\tmesh.addFace(p, curr[x - 1], prev[x - 1]);\n\t\t\t\t\tmesh.addFace(p, prev[x - 1], prev[x]);\n\t\t\t\t}\n\t\t\t\tcurr[x] = p;\n\t\t\t}\n\t\t\tvar tmp = prev;\n\t\t\tprev = curr;\n\t\t\tcurr = tmp;\n\t\t}\n\t\treturn mesh;\n\n\t}\n};\n\n/**\nComputes a single point on the bezier surface given by the 2d array of\ncontrol points. The desired point's coordinates have to be specified in\nUV space (range 0.0 .. 1.0). The implementation does not check or enforce\nthe correct range of these coords and will not return valid points if the\nrange is exceeded.\n@param u positive normalized U coordinate on the bezier surface\n@param v positive normalized V coordinate on the bezier surface\n@param points 4x4 array defining the patch's control points\n@return point on surface\n*/\n\nBezierPatch.computePointAt = function(u,v,points){\n\t\tvar u1 = 1 - u;\n\t\tvar u1squared = u1 * u1 * 3 * u,\n\t\tu1cubed = u1 * u1 * u1,\n\t\tusquared = u * u,\n\t\tv1 = 1 - v,\n\t\tvsquared = v * v * 3,\n\t\tv1squared = v1 * v1 * 3,\n\t\tv1cubed = v1 * v1 * v1,\n\t\tvcubed = v * v * v,\n\n\t\tu1usq = u1 * usquared * 3,\n\t\tusqu = u * usquared,\n\t\tv1vsq = v1 * vsquared,\n\t\tv1sqv = v1squared * v;\n\n\t\tvar p0 = points[0];\n\t\tvar p1 = points[1];\n\t\tvar p2 = points[2];\n\t\tvar p3 = points[3];\n\n\t\tvar x = u1cubed * (p0[0].x * v1cubed + p0[1].x * v1sqv + p0[2].x * v1vsq + p0[3].x * vcubed) + u1squared * (p1[0].x * v1cubed + p1[1].x * v1sqv + p1[2].x * v1vsq + p1[3].x * vcubed) + u1usq * (p2[0].x * v1cubed + p2[1].x * v1sqv + p2[2].x * v1vsq + p2[3].x * vcubed) + usqu * (p3[0].x * v1cubed + p3[1].x * v1sqv + p3[2].x * v1vsq + p3[3].x * vcubed);\n\n\t\tvar y = u1cubed * (p0[0].y * v1cubed + p0[1].y * v1sqv + p0[2].y * v1vsq + p0[3].y * vcubed) + u1squared * (p1[0].y * v1cubed + p1[1].y * v1sqv + p1[2].y * v1vsq + p1[3].y * vcubed) + u1usq * (p2[0].y * v1cubed + p2[1].y * v1sqv + p2[2].y * v1vsq + p2[3].y * vcubed) + usqu * (p3[0].y * v1cubed + p3[1].y * v1sqv + p3[2].y * v1vsq + p3[3].y * vcubed);\n\n\t\tvar z = u1cubed * (p0[0].z * v1cubed + p0[1].z * v1sqv + p0[2].z * v1vsq + p0[3].z * vcubed) + u1squared * (p1[0].z * v1cubed + p1[1].z * v1sqv + p1[2].z * v1vsq + p1[3].z * vcubed) + u1usq * (p2[0].z * v1cubed + p2[1].z * v1sqv + p2[2].z * v1vsq + p2[3].z * vcubed) + usqu * (p3[0].z * v1cubed + p3[1].z * v1sqv + p3[2].z * v1vsq + p3[3].z * vcubed);\n\n\t\treturn new Vec3D(x, y, z);\n\n};\n\nmodule.exports = BezierPatch;\n\n"]},"metadata":{},"sourceType":"script"}