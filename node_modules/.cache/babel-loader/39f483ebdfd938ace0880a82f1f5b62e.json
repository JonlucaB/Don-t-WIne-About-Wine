{"ast":null,"code":"/**\n* A version of the Sutherland-Hodgeman algorithm to clip 2D polygons optimized\n* for rectangular clipping regions.\n* More information: http://en.wikipedia.org/wiki/Sutherland-Hodgman_algorithm\n*/\nvar Polygon2D = require('./Polygon2D'),\n    Vec2D = require('./vectors').Vec2D; //function for finding clipped position on each edge\n//faster than a switch\n\n\nvar clippedPos = {\n  0: function (b, p1, p2) {\n    var x = p1.x + (b.y - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);\n    return new Vec2D(x, b.y);\n  },\n  1: function (b, p1, p2) {\n    var bx = b.x + b.width;\n    var y = p1.y + (bx - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);\n    return new Vec2D(bx, y);\n  },\n  2: function (b, p1, p2) {\n    var by = b.y + b.height;\n    var x = p1.x + (by - p1.y) * (p2.x - p1.x) / (p2.y - p1.y);\n    return new Vec2D(x, by);\n  },\n  3: function (b, p1, p2) {\n    var y = p1.y + (b.x - p1.x) * (p2.y - p1.y) / (p2.x - p1.x);\n    return new Vec2D(b.x, y);\n  }\n};\n/**\n * method for getting the position on the edge\n * @private\n * @param {Rect} bounds\n * @param {Number} edgeID\n * @param {Vec2D} p1\n * @param {Vec2D} p2\n * @returns Vec2D\n */\n\nvar getClippedPosOnEdge = function (bounds, edgeID, p1, p2) {\n  return clippedPos[edgeID](bounds, p1, p2);\n}; //tests for each edgeID whether the point is within the edge\n\n\nvar insideEdgeConditions = {\n  0: function (bounds, p) {\n    return p.y >= bounds.y;\n  },\n  1: function (bounds, p) {\n    return p.x < bounds.x + bounds.width;\n  },\n  2: function (bounds, p) {\n    return p.y < bounds.y + bounds.height;\n  },\n  3: function (bounds, p) {\n    return p.x >= bounds.x;\n  }\n};\n/**\n * @private\n * @param {Rect} bounds\n * @param {Vec2D} p\n * @param {Number} edgeID\n * @return {Boolean}\n */\n\nvar isInsideEdge = function (bounds, p, edgeID) {\n  return insideEdgeConditions[edgeID](bounds, p);\n};\n/**\n * SutherlandHodgemanClipper constructor\n * @param {Rect} bounds\n */\n\n\nvar SutherlandHodgemanClipper = function (bounds) {\n  this.bounds = bounds;\n};\n\nSutherlandHodgemanClipper.prototype = {\n  constructor: SutherlandHodgemanClipper,\n  clipPolygon: function (poly) {\n    var points = poly.vertices.slice(0),\n        //copy of poly's points\n    clipped,\n        //will contain the clipped points\n    edgeID = 0,\n        //numeric id for each edge\n    i = 0,\n        num = points.length - 1,\n        p,\n        //current point in loop\n    q; //next point in loop\n    //duplicate the first point ref\n\n    points.push(points[0]);\n\n    for (; edgeID < 4; edgeID++) {\n      i = 0; //make sure the inner-loop starts over\n\n      num = points.length - 1;\n      clipped = []; //new clipped coords for this iteration\n\n      for (; i < num; i++) {\n        p = points[i];\n        q = points[i + 1];\n\n        if (isInsideEdge(this.bounds, p, edgeID)) {\n          if (isInsideEdge(this.bounds, q, edgeID)) {\n            clipped.push(q.copy());\n          } else {\n            clipped.push(getClippedPosOnEdge(this.bounds, edgeID, p, q));\n          }\n\n          continue;\n        }\n\n        if (isInsideEdge(this.bounds, q, edgeID)) {\n          clipped.push(getClippedPosOnEdge(this.bounds, edgeID, p, q));\n          clipped.push(q.copy());\n        }\n      }\n\n      if (clipped.length > 0 && clipped[0] !== clipped[clipped.length - 1]) {\n        clipped.push(clipped[0]);\n      }\n\n      points = clipped;\n    }\n\n    return new Polygon2D(points).removeDuplicates(0.001);\n  },\n  getBounds: function () {\n    return this.bounds;\n  },\n  //protected + unused in java\n  isKnownVertex: function (list, q) {\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].equalsWithTolerance(q, 0.0001)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  setBounds: function (bounds) {\n    this.bounds = bounds;\n  }\n};\nmodule.exports = SutherlandHodgemanClipper;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/SutherlandHodgemanClipper.js"],"names":["Polygon2D","require","Vec2D","clippedPos","b","p1","p2","x","y","bx","width","by","height","getClippedPosOnEdge","bounds","edgeID","insideEdgeConditions","p","isInsideEdge","SutherlandHodgemanClipper","prototype","constructor","clipPolygon","poly","points","vertices","slice","clipped","i","num","length","q","push","copy","removeDuplicates","getBounds","isKnownVertex","list","l","equalsWithTolerance","setBounds","module","exports"],"mappings":"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","sourcesContent":["\n\t/**\n\t* A version of the Sutherland-Hodgeman algorithm to clip 2D polygons optimized\n\t* for rectangular clipping regions.\n\t* More information: http://en.wikipedia.org/wiki/Sutherland-Hodgman_algorithm\n\t*/\n\tvar Polygon2D = require('./Polygon2D'),\n\t\tVec2D = require('./vectors').Vec2D;\n\n\t//function for finding clipped position on each edge\n\t//faster than a switch\n\tvar clippedPos = {\n\t\t0: function( b, p1, p2 ){\n\t\t\tvar x = p1.x + ( (b.y-p1.y) * (p2.x-p1.x) ) / ( p2.y-p1.y );\n\t\t\treturn new Vec2D( x, b.y );\n\t\t},\n\t\t1: function( b, p1, p2 ){\n\t\t\tvar bx = b.x + b.width;\n\t\t\tvar y = p1.y + ( (bx-p1.x) * (p2.y-p1.y) ) / (p2.x-p1.x);\n\t\t\treturn new Vec2D( bx, y );\n\t\t},\n\t\t2: function( b, p1, p2 ){\n\t\t\tvar by = b.y + b.height;\n\t\t\tvar x = p1.x + ( (by-p1.y) * (p2.x-p1.x) ) / ( p2.y-p1.y );\n\t\t\treturn new Vec2D( x, by );\n\t\t},\n\t\t3: function( b, p1, p2 ){\n\t\t\tvar y = p1.y + ( (b.x-p1.x) * (p2.y-p1.y) ) / ( p2.x-p1.x );\n\t\t\treturn new Vec2D( b.x, y );\n\t\t}\n\t};\n\n\t/**\n\t * method for getting the position on the edge\n\t * @private\n\t * @param {Rect} bounds\n\t * @param {Number} edgeID\n\t * @param {Vec2D} p1\n\t * @param {Vec2D} p2\n\t * @returns Vec2D\n\t */\n\tvar getClippedPosOnEdge = function( bounds, edgeID, p1, p2 ){\n\t\treturn clippedPos[edgeID]( bounds, p1, p2 );\n\t};\n\n\n\t//tests for each edgeID whether the point is within the edge\n\tvar insideEdgeConditions = {\n\t\t0: function( bounds, p ){\n\t\t\treturn p.y >= bounds.y;\n\t\t},\n\t\t1: function( bounds, p ){\n\t\t\treturn p.x < bounds.x + bounds.width;\n\t\t},\n\t\t2: function( bounds, p ){\n\t\t\treturn p.y < bounds.y + bounds.height;\n\t\t},\n\t\t3: function( bounds, p ){\n\t\t\treturn p.x >= bounds.x;\n\t\t}\n\t};\n\n\t/**\n\t * @private\n\t * @param {Rect} bounds\n\t * @param {Vec2D} p\n\t * @param {Number} edgeID\n\t * @return {Boolean}\n\t */\n\tvar isInsideEdge = function( bounds, p, edgeID ){\n\t\treturn insideEdgeConditions[edgeID]( bounds, p );\n\t};\n\n\n\t/**\n\t * SutherlandHodgemanClipper constructor\n\t * @param {Rect} bounds\n\t */\n\tvar SutherlandHodgemanClipper = function( bounds ){\n\t\tthis.bounds = bounds;\n\t};\n\n\tSutherlandHodgemanClipper.prototype = {\n\t\tconstructor: SutherlandHodgemanClipper,\n\t\tclipPolygon: function( poly ){\n\t\t\tvar points = poly.vertices.slice(0), //copy of poly's points\n\t\t\t\tclipped, //will contain the clipped points\n\t\t\t\tedgeID = 0, //numeric id for each edge\n\t\t\t\ti = 0,\n\t\t\t\tnum = points.length-1,\n\t\t\t\tp, //current point in loop\n\t\t\t\tq; //next point in loop\n\n\t\t\t//duplicate the first point ref\n\t\t\tpoints.push( points[0] );\n\t\t\tfor( ; edgeID < 4; edgeID++ ){\n\t\t\t\ti = 0; //make sure the inner-loop starts over\n                num = points.length - 1;\n\t\t\t\tclipped = []; //new clipped coords for this iteration\n\t\t\t\tfor( ; i<num; i++ ){\n\t\t\t\t\tp = points[i];\n\t\t\t\t\tq = points[i+1];\n\t\t\t\t\tif( isInsideEdge( this.bounds, p, edgeID ) ){\n\t\t\t\t\t\tif( isInsideEdge( this.bounds, q, edgeID ) ){\n\t\t\t\t\t\t\tclipped.push( q.copy() );\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tclipped.push( getClippedPosOnEdge(this.bounds, edgeID, p, q) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcontinue;\n\t\t\t\t\t}\n\t\t\t\t\tif( isInsideEdge( this.bounds, q, edgeID) ){\n\t\t\t\t\t\tclipped.push( getClippedPosOnEdge(this.bounds, edgeID, p, q) );\n\t\t\t\t\t\tclipped.push( q.copy() );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif( clipped.length > 0 && clipped[0] !== clipped[clipped.length-1] ){\n\t\t\t\t\tclipped.push( clipped[0] );\n\t\t\t\t}\n\t\t\t\tpoints = clipped;\n\t\t\t}\n\t\t\treturn new Polygon2D( points ).removeDuplicates( 0.001 );\n\t\t},\n\t\tgetBounds: function(){\n\t\t\treturn this.bounds;\n\t\t},\n\t\t//protected + unused in java\n\t\tisKnownVertex: function( list, q ){\n\t\t\tfor( var i=0, l=list.length; i<l; i++){\n\t\t\t\tif( list[i].equalsWithTolerance(q, 0.0001) ){\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t},\n\t\tsetBounds: function( bounds ){\n\t\t\tthis.bounds = bounds;\n\t\t}\n\t};\n\n\tmodule.exports = SutherlandHodgemanClipper;\n"]},"metadata":{},"sourceType":"script"}