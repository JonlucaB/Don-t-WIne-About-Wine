{"ast":null,"code":"var MathUtils = require('../math/mathUtils');\n\nvar Vec2D = require('./Vec2D');\n\nvar Line2D = require('./Line2D');\n\nvar Circle = require('./Circle');\n\nvar Rect = require('./Rect');\n\nvar TriangleMesh = require('./mesh/TriangleMesh');\n\nvar has = require('../internals/has');\n\nvar is = require('../internals/is');\n/**\n* @class\n* @member toxi\n* @param {Array<Vec2D>|Vec2D...} [points] optionally provide points for the polygon\n*/\n\n\nvar Polygon2D = function () {\n  this.vertices = [];\n  var i, l;\n\n  if (arguments.length > 1) {\n    //comma-separated Vec2D's were passed in\n    for (i = 0, l = arguments.length; i < l; i++) {\n      this.add(arguments[i].copy());\n    }\n  } else if (arguments.length == 1) {\n    var arg = arguments[0];\n\n    if (is.Array(arg)) {\n      // if it was an array of points\n      for (i = 0, l = arg.length; i < l; i++) {\n        this.add(arg[i].copy());\n      }\n    }\n  } //otherwise no args were passed, and thats ok\n\n};\n\nPolygon2D.prototype = {\n  constructor: Polygon2D,\n  add: function (p) {\n    //accept an array also\n    if (is.Array(p)) {\n      for (var i = 0, l = p.length; i < l; i++) {\n        if (this.vertices.indexOf(p[i]) < 0) {\n          this.vertices.push(p[i]);\n        }\n      }\n\n      return;\n    }\n\n    if (this.vertices.indexOf(p) < 0) {\n      this.vertices.push(p);\n    }\n  },\n\n  /**\n  * centers the polygon so that its new centroid is at the given point\n  * @param {Vec2D} [origin]\n  * @return itself\n  */\n  center: function (origin) {\n    var centroid = this.getCentroid();\n    var delta = origin !== undefined ? origin.sub(centroid) : centroid.invert();\n\n    for (var i = 0, l = this.vertices.length; i < l; i++) {\n      this.vertices[i].addSelf(delta);\n    }\n\n    return this;\n  },\n  containsPoint: function (p) {\n    var num = this.vertices.length,\n        i = 0,\n        j = num - 1,\n        oddNodes = false,\n        px = p.x,\n        py = p.y;\n\n    for (i = 0; i < num; i++) {\n      var vi = this.vertices[i],\n          vj = this.vertices[j];\n\n      if (vi.y < py && vj.y >= py || vj.y < py && vi.y >= py) {\n        if (vi.x + (py - vi.y) / (vj.y - vi.y) * (vj.x - vi.x) < px) {\n          oddNodes = !oddNodes;\n        }\n      }\n\n      j = i;\n    }\n\n    return oddNodes;\n  },\n  containsPolygon: function (poly) {\n    for (var i = 0, num = poly.vertices.length; i < num; i++) {\n      if (!this.containsPoint(poly.vertices[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n  copy: function () {\n    return new Polygon2D(this.vertices);\n  },\n  flipVertexOrder: function () {\n    this.vertices.reverse();\n    return this;\n  },\n\n  /**\n  * Returns the vertex at the given index. This function follows Python\n  * convention, in that if the index is negative, it is considered relative\n  * to the list end. Therefore the vertex at index -1 is the last vertex in\n  * the list.\n  * @param {Number} i index\n  * @return vertex\n  */\n  get: function (i) {\n    if (i < 0) {\n      i += this.vertices.length;\n    }\n\n    return this.vertices[i];\n  },\n\n  /**\n  * Computes the length of this polygon's apothem. This will only be valid if\n  * the polygon is regular. More info: http://en.wikipedia.org/wiki/Apothem\n  * @return apothem length\n  */\n  getApothem: function () {\n    return this.vertices[0].interpolateTo(this.vertices[1], 0.5).distanceTo(this.getCentroid());\n  },\n  getArea: function () {\n    var area = 0,\n        numPoints = this.vertices.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      var a = this.vertices[i],\n          b = this.vertices[(i + 1) % numPoints];\n      area += a.x * b.y;\n      area -= a.y * b.x;\n    }\n\n    area *= 0.5;\n    return area;\n  },\n  getBoundingCircle: function () {\n    var Circle = require('./Circle');\n\n    return Circle.newBoundingCircle(this.vertices);\n  },\n  getBounds: function () {\n    var Rect = require('./Rect');\n\n    return Rect.getBoundingRect(this.vertices);\n  },\n  getCentroid: function () {\n    var res = new Vec2D(),\n        numPoints = this.vertices.length;\n\n    for (var i = 0; i < numPoints; i++) {\n      var a = this.vertices[i],\n          b = this.vertices[(i + 1) % numPoints],\n          factor = a.x * b.y - b.x * a.y;\n      res.x += (a.x + b.x) * factor;\n      res.y += (a.y + b.y) * factor;\n    }\n\n    return res.scale(1 / (this.getArea() * 6));\n  },\n  getCircumference: function () {\n    var circ = 0;\n\n    for (var i = 0, num = this.vertices.length; i < num; i++) {\n      circ += this.vertices[i].distanceTo(this.vertices[(i + 1) % num]);\n    }\n\n    return circ;\n  },\n  getClosestPointTo: function (p) {\n    var minD = Number.MAX_VALUE;\n    var q, c, d;\n    var edges = this.getEdges();\n\n    for (var i = 0, len = edges.length; i < len; i++) {\n      c = edges[i].closestPointTo(p);\n      d = c.distanceToSquared(p);\n\n      if (d < minD) {\n        q = c;\n        minD = d;\n      }\n    }\n\n    return q;\n  },\n  getClosestVertexTo: function (p) {\n    var minD = Number.MAX_VALUE;\n    var q,\n        d,\n        i = 0,\n        len = this.vertices.length;\n\n    for (; i < len; i++) {\n      d = this.vertices[i].distanceToSquared(p);\n\n      if (d < minD) {\n        q = this.vertices[i];\n        minD = d;\n      }\n    }\n\n    return q;\n  },\n  getEdges: function () {\n    var num = this.vertices.length,\n        edges = [];\n\n    for (var i = 0; i < num; i++) {\n      edges[i] = new Line2D(this.vertices[i], this.vertices[(i + 1) % num]);\n    }\n\n    return edges;\n  },\n  //@deprecated\n  getNumPoints: function () {\n    return this.getNumVertices();\n  },\n  getNumVertices: function () {\n    return this.vertices.length;\n  },\n  getRandomPoint: function () {\n    var edges = this.getEdges();\n    var numEdges = edges.length;\n    var ea = edges[MathUtils.random(numEdges)],\n        eb;\n\n    while (eb === undefined || eb.equals(ea)) {\n      eb = edges[MathUtils.random(numEdges)];\n    } //pick a random point on edge A\n\n\n    var p = ea.a.interpolateTo(ea.b, Math.random()); //then randomly interpolate to another point on b\n\n    return p.interpolateToSelf(eb.a.interpolateTo(eb.b, Math.random()), Math.random());\n  },\n\n  /**\n  * Repeatedly inserts vertices as mid points of the longest edges until the\n  * new vertex count is reached.\n  * @param {Number} count new vertex count\n  * @return itself\n  */\n  increaseVertexCount: function (count) {\n    var num = this.vertices.length,\n        longestID = 0,\n        maxD = 0,\n        i = 0,\n        d,\n        m;\n\n    while (num < count) {\n      //find longest edge\n      longestID = 0;\n      maxD = 0;\n\n      for (i = 0; i < num; i++) {\n        d = this.vertices[i].distanceToSquared(this.vertices[(i + 1) % num]);\n\n        if (d > maxD) {\n          longestID = i;\n          maxD = d;\n        }\n      } //insert mid point of longest segment\n\n\n      m = this.vertices[longestID].add(this.vertices[(longestID + 1) % num]).scaleSelf(0.5); //push this into the array inbetween the 2 points\n\n      this.vertices.splice(longestID + 1, 0, m);\n      num++;\n    }\n\n    return this;\n  },\n  intersectsPolygon: function (poly) {\n    if (!this.containsPolygon(poly)) {\n      var edges = this.getEdges();\n      var pedges = poly.getEdges();\n\n      for (var i = 0, n = edges.length; i < n; i++) {\n        for (var j = 0, m = pedges.length, e = edges[i]; j < m; j++) {\n          if (e.intersectLine(pedges[j]).getType() == Line2D.LineIntersection.Type.INTERSECTING) {\n            return true;\n          }\n        }\n      }\n\n      return false;\n    } else {\n      return true;\n    }\n  },\n  isClockwise: function () {\n    return this.getArea() > 0;\n  },\n\n  /**\n  * Checks if the polygon is convex.\n  * @return true, if convex.\n  */\n  isConvex: function () {\n    var isPositive = false,\n        num = this.vertices.length,\n        prev,\n        next,\n        d0,\n        d1,\n        newIsP;\n\n    for (var i = 0; i < num; i++) {\n      prev = i === 0 ? num - 1 : i - 1;\n      next = i === num - 1 ? 0 : i + 1;\n      d0 = this.vertices[i].sub(this.vertices[prev]);\n      d1 = this.vertices[next].sub(this.vertices[i]);\n      newIsP = d0.cross(d1) > 0;\n\n      if (i === 0) {\n        isPositive = true;\n      } else if (isPositive != newIsP) {\n        return false;\n      }\n    }\n\n    return true;\n  },\n\n  /**\n  * Given the sequentially connected points p1, p2, p3, this function returns\n  * a bevel-offset replacement for point p2.\n  *\n  * Note: If vectors p1->p2 and p2->p3 are exactly 180 degrees opposed, or if\n  * either segment is zero then no offset will be applied.\n  *\n  * @param x1\n  * @param y1\n  * @param x2\n  * @param y2\n  * @param x3\n  * @param y3\n  * @param distance\n  * @param out\n  *\n  * @see http://alienryderflex.com/polygon_inset/\n  */\n  _offsetCorner: function (x1, y1, x2, y2, x3, y3, distance, out) {\n    var c1 = x2,\n        d1 = y2,\n        c2 = x2,\n        d2 = y2;\n    var dx1, dy1, dist1, dx2, dy2, dist2, insetX, insetY;\n    dx1 = x2 - x1;\n    dy1 = y2 - y1;\n    dist1 = Math.sqrt(dx1 * dx1 + dy1 * dy1);\n    dx2 = x3 - x2;\n    dy2 = y3 - y2;\n    dist2 = Math.sqrt(dx2 * dx2 + dy2 * dy2);\n\n    if (dist1 < MathUtils.EPS || dist2 < MathUtils.EPS) {\n      return;\n    }\n\n    dist1 = distance / dist1;\n    dist2 = distance / dist2;\n    insetX = dy1 * dist1;\n    insetY = -dx1 * dist1;\n    x1 += insetX;\n    c1 += insetX;\n    y1 += insetY;\n    d1 += insetY;\n    insetX = dy2 * dist2;\n    insetY = -dx2 * dist2;\n    x3 += insetX;\n    c2 += insetX;\n    y3 += insetY;\n    d2 += insetY;\n\n    if (c1 === c2 && d1 === d2) {\n      out.set(c1, d1);\n      return;\n    }\n\n    var l1 = new Line2D(new Vec2D(x1, y1), new Vec2D(c1, d1)),\n        l2 = new Line2D(new Vec2D(c2, d2), new Vec2D(x3, y3)),\n        isec = l1.intersectLine(l2),\n        ipos = isec.getPos();\n\n    if (ipos !== null || ipos !== undefined) {\n      out.set(ipos);\n    }\n  },\n\n  /**\n  * Moves each line segment of the polygon in/outward perpendicular by the\n  * given distance. New line segments and polygon vertices are created by\n  * computing the intersection points of the displaced segments. Choosing an\n  * too large displacement amount will result in deformation/undefined\n  * behavior with various self intersections. Should that happen, please try\n  * to clean up the shape using the {@link #toOutline()} method.\n  *\n  * @param distance\n  *            offset/inset distance (negative for inset)\n  * @return itself\n  */\n  offsetShape: function (distance) {\n    var v = this.vertices;\n    var num = v.length - 1;\n\n    if (num > 1) {\n      var startX = v[0].x,\n          startY = v[0].y,\n          c = v[num].x,\n          d = v[num].y,\n          e = startX,\n          f = startY,\n          a,\n          b;\n\n      for (var i = 0; i < num; i++) {\n        a = c;\n        b = d;\n        c = e;\n        d = f;\n        e = v[i + 1].x;\n        f = v[i + 1].y;\n\n        this._offsetCorner(a, b, c, d, e, f, distance, v[i]);\n      }\n\n      this._offsetCorner(c, d, e, f, startX, startY, distance, v[num]);\n    }\n\n    return this;\n  },\n\n  /**\n  * Reduces the number of vertices in the polygon based on the given minimum\n  * edge length. Only vertices with at least this distance between them will\n  * be kept.\n  *\n  * @param minEdgeLen\n  * @return itself\n  */\n  reduceVertices: function (minEdgeLen) {\n    minEdgeLen *= minEdgeLen;\n    var vs = this.vertices,\n        reduced = [],\n        prev = vs[0],\n        num = vs.length - 1,\n        vec;\n    reduced.push(prev);\n\n    for (var i = 0; i < num; i++) {\n      vec = vs[i];\n\n      if (prev.distanceToSquared(vec) >= minEdgeLen) {\n        reduced.push(vec);\n        prev = vec;\n      }\n    }\n\n    if (vs[0].distanceToSquared(vs[num]) >= minEdgeLen) {\n      reduced.push(vs[num]);\n    }\n\n    this.vertices = reduced;\n    return this;\n  },\n\n  /**\n  * Removes duplicate vertices from the polygon. Only successive points are\n  * recognized as duplicates.\n  * @param {Number} tolerance snap distance for finding duplicates\n  * @return itself\n  */\n  removeDuplicates: function (tolerance) {\n    //if tolerance is 0, it will be faster to just use 'equals' method\n    var equals = tolerance ? 'equalsWithTolerance' : 'equals';\n    var p,\n        prev,\n        i = 0,\n        num = this.vertices.length;\n    var last;\n\n    for (; i < num; i++) {\n      p = this.vertices[i]; //if its the 'equals' method tolerance will just be ingored\n\n      if (p[equals](prev, tolerance)) {\n        //remove from array, step back counter\n        this.vertices.splice(i, 1);\n        i--;\n        num--;\n      } else {\n        prev = p;\n      }\n    }\n\n    num = this.vertices.length;\n\n    if (num > 0) {\n      last = this.vertices[num - 1];\n\n      if (last[equals](this.vertices[0], tolerance)) {\n        this.vertices.splice(num - 1, 1);\n      }\n    }\n\n    return this;\n  },\n  rotate: function (theta) {\n    for (var i = 0, num = this.vertices.length; i < num; i++) {\n      this.vertices[i].rotate(theta);\n    }\n\n    return this;\n  },\n  scale: function (x, y) {\n    if (arguments.length == 1) {\n      var arg = arguments[0];\n\n      if (has.XY(arg)) {\n        x = arg.x;\n        y = arg.y;\n      } else {\n        // uniform scale\n        x = arg;\n        y = arg;\n      }\n    } else if (arguments.length == 2) {\n      x = arguments[0];\n      y = arguments[1];\n    } else {\n      throw \"Invalid argument(s) passed.\";\n    }\n\n    for (var i = 0, num = this.vertices.length; i < num; i++) {\n      this.vertices[i].scaleSelf(x, y);\n    }\n\n    return this;\n  },\n  scaleSize: function (x, y) {\n    var centroid;\n\n    if (arguments.length === 1) {\n      var arg = arguments[0];\n\n      if (has.XY(arg)) {\n        x = arg.x;\n        y = arg.y;\n      } else {\n        //uniform\n        x = arg;\n        y = arg;\n      }\n    } else if (arguments.length === 2) {\n      x = arguments[0];\n      y = arguments[1];\n    } else {\n      throw new Error('Invalid argument(s) passed.');\n    }\n\n    centroid = this.getCentroid();\n\n    for (var i = 0, l = this.vertices.length; i < l; i++) {\n      var v = this.vertices[i];\n      v.subSelf(centroid).scaleSelf(x, y).addSelf(centroid);\n    }\n\n    return this;\n  },\n  smooth: function (amount, baseWeight) {\n    var centroid = this.getCentroid();\n    var num = this.vertices.length;\n    var filtered = [];\n\n    for (var i = 0, j = num - 1, k = 1; i < num; i++) {\n      var a = this.vertices[i];\n      var dir = this.vertices[j].sub(a).addSelf(this.vertices[k].sub(a)).addSelf(a.sub(centroid).scaleSelf(baseWeight));\n      filtered.push(a.add(dir.scaleSelf(amount)));\n      j++;\n\n      if (j == num) {\n        j = 0;\n      }\n\n      k++;\n\n      if (k == num) {\n        k = 0;\n      }\n    }\n\n    this.vertices = filtered;\n    return this;\n  },\n  toMesh: function (mesh, centroid2D, extrude) {\n    mesh = mesh || new TriangleMesh();\n    var num = this.vertices.length;\n    centroid2D = centroid2D || this.getCentroid();\n    var centroid = centroid2D.to3DXY();\n    centroid.z = extrude;\n    var bounds = this.getBounds(),\n        boundScale = new Vec2D(1 / bounds.width, 1 / bounds.height),\n        uvC = centroid2D.sub(bounds.getTopLeft()).scaleSelf(boundScale),\n        a,\n        b,\n        uvA,\n        uvB;\n\n    for (var i = 1; i <= num; i++) {\n      a = this.vertices[i % num];\n      b = this.vertices[i - 1];\n      uvA = a.sub(bounds.getTopLeft()).scaleSelf(boundScale);\n      uvB = b.sub(bounds.getTopLeft()).scaleSelf(boundScale);\n      mesh.addFace(centroid, a.to3DXY(), b.to3DXY(), uvC, uvA, uvB);\n    }\n\n    return mesh;\n  },\n  toPolygon2D: function () {\n    return this;\n  },\n  toString: function () {\n    var s = \"\";\n\n    for (var i = 0; i < this.vertices.length; i++) {\n      s += this.vertices[i];\n\n      if (i < this.vertices.length - 1) {\n        s += \", \";\n      }\n    }\n\n    return s;\n  },\n  translate: function () {\n    var x, y;\n\n    if (arguments.length == 1 && has.XY(arguments[0])) {\n      x = arguments[0].x;\n      y = arguments[0].y;\n    } else if (arguments.length == 2) {\n      x = arguments[0];\n      y = arguments[1];\n    } else {\n      throw \"Invalid argument(s) passed.\";\n    }\n\n    for (var i = 0, num = this.vertices.length; i < num; i++) {\n      this.vertices[i].addSelf(x, y);\n    }\n\n    return this;\n  }\n};\n/**\n* Constructs a new regular polygon from the given base line/edge.\n* @param {Vec2D} baseA left point of the base edge\n* @param {Vec2D} baseB right point of the base edge\n* @param {Number} res number of polygon vertices\n* @return polygon\n*/\n\nPolygon2D.fromBaseEdge = function (baseA, baseB, res) {\n  var theta = -(MathUtils.PI - MathUtils.PI * (res - 2) / res),\n      dir = baseB.sub(baseA),\n      prev = baseB,\n      poly = new Polygon2D(baseA, baseB),\n      p;\n\n  for (var i = 0; i < res - 1; i++) {\n    p = prev.add(dir.getRotated(theta * i));\n    poly.add(p);\n    prev = p;\n  }\n\n  return poly;\n};\n/**\n* Constructs a regular polygon from the given edge length and number of\n* vertices. This automatically computes the radius of the circle the\n* polygon is inscribed in.\n* More information: http://en.wikipedia.org/wiki/Regular_polygon#Radius\n*\n* @param {Number} len desired edge length\n* @param {Number} res number of vertices\n* @return polygon\n*/\n\n\nPolygon2D.fromEdgeLength = function (len, res) {\n  var Circle = require('./Circle');\n\n  return new Circle(Polygon2D.getRadiusForEdgeLength(len, res)).toPolygon2D(res);\n};\n/**\n* Computes the radius of the circle the regular polygon with the desired\n* edge length is inscribed in\n* @param {Number} len edge length\n* @param {Number} res number of polygon vertices\n* @return radius\n*/\n\n\nPolygon2D.getRadiusForEdgeLength = function (len, res) {\n  return len / (2 * MathUtils.sin(MathUtils.PI / res));\n};\n\nmodule.exports = Polygon2D;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/Polygon2D.js"],"names":["MathUtils","require","Vec2D","Line2D","Circle","Rect","TriangleMesh","has","is","Polygon2D","vertices","i","l","arguments","length","add","copy","arg","Array","prototype","constructor","p","indexOf","push","center","origin","centroid","getCentroid","delta","undefined","sub","invert","addSelf","containsPoint","num","j","oddNodes","px","x","py","y","vi","vj","containsPolygon","poly","flipVertexOrder","reverse","get","getApothem","interpolateTo","distanceTo","getArea","area","numPoints","a","b","getBoundingCircle","newBoundingCircle","getBounds","getBoundingRect","res","factor","scale","getCircumference","circ","getClosestPointTo","minD","Number","MAX_VALUE","q","c","d","edges","getEdges","len","closestPointTo","distanceToSquared","getClosestVertexTo","getNumPoints","getNumVertices","getRandomPoint","numEdges","ea","random","eb","equals","Math","interpolateToSelf","increaseVertexCount","count","longestID","maxD","m","scaleSelf","splice","intersectsPolygon","pedges","n","e","intersectLine","getType","LineIntersection","Type","INTERSECTING","isClockwise","isConvex","isPositive","prev","next","d0","d1","newIsP","cross","_offsetCorner","x1","y1","x2","y2","x3","y3","distance","out","c1","c2","d2","dx1","dy1","dist1","dx2","dy2","dist2","insetX","insetY","sqrt","EPS","set","l1","l2","isec","ipos","getPos","offsetShape","v","startX","startY","f","reduceVertices","minEdgeLen","vs","reduced","vec","removeDuplicates","tolerance","last","rotate","theta","XY","scaleSize","Error","subSelf","smooth","amount","baseWeight","filtered","k","dir","toMesh","mesh","centroid2D","extrude","to3DXY","z","bounds","boundScale","width","height","uvC","getTopLeft","uvA","uvB","addFace","toPolygon2D","toString","s","translate","fromBaseEdge","baseA","baseB","PI","getRotated","fromEdgeLength","getRadiusForEdgeLength","sin","module","exports"],"mappings":"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","sourcesContent":["var MathUtils = require('../math/mathUtils');\nvar Vec2D = require('./Vec2D');\nvar Line2D = require('./Line2D');\nvar Circle = require('./Circle');\nvar Rect = require('./Rect');\nvar TriangleMesh = require('./mesh/TriangleMesh');\nvar has = require('../internals/has');\nvar is = require('../internals/is');\n\n    /**\n    * @class\n    * @member toxi\n    * @param {Array<Vec2D>|Vec2D...} [points] optionally provide points for the polygon\n    */\n    var Polygon2D = function(){\n        this.vertices = [];\n        var i,l;\n        if(arguments.length > 1){ //comma-separated Vec2D's were passed in\n            for(i=0, l = arguments.length;i<l;i++){\n                this.add(arguments[i].copy());\n            }\n        } else if(arguments.length == 1){\n            var arg = arguments[0];\n            if( is.Array( arg ) ){ // if it was an array of points\n                for(i=0,l = arg.length;i<l;i++){\n                    this.add(arg[i].copy());\n                }\n            }\n        } //otherwise no args were passed, and thats ok\n\n    };\n\n\n    Polygon2D.prototype = {\n        constructor: Polygon2D,\n\n        add: function(p){\n            //accept an array also\n            if( is.Array(p) ){\n                for( var i=0, l = p.length; i<l; i++ ){\n                    if( this.vertices.indexOf(p[i]) < 0 ){\n                        this.vertices.push(p[i]);\n                    }\n                }\n                return;\n            }\n            if(this.vertices.indexOf(p) < 0){\n                this.vertices.push(p);\n            }\n        },\n\n        /**\n        * centers the polygon so that its new centroid is at the given point\n        * @param {Vec2D} [origin]\n        * @return itself\n        */\n        center: function( origin ){\n            var centroid = this.getCentroid();\n            var delta = origin !== undefined ? origin.sub( centroid ) : centroid.invert();\n            for( var i=0, l = this.vertices.length; i<l; i++){\n                this.vertices[i].addSelf( delta );\n            }\n            return this;\n        },\n\n        containsPoint: function(p){\n            var num = this.vertices.length,\n                i = 0,\n                j = num-1,\n                oddNodes = false,\n                px = p.x,\n                py = p.y;\n            for(i=0;i<num;i++){\n                var vi = this.vertices[i],\n                    vj = this.vertices[j];\n                if (vi.y < py && vj.y >= py || vj.y < py && vi.y >= py) {\n                    if (vi.x + (py - vi.y) / (vj.y - vi.y) * (vj.x - vi.x) < px) {\n                        oddNodes = !oddNodes;\n                    }\n                }\n                j = i;\n            }\n            return oddNodes;\n        },\n\n        containsPolygon: function(poly) {\n            for (var i=0,num=poly.vertices.length; i<num; i++) {\n                if (!this.containsPoint(poly.vertices[i])) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        copy: function(){\n            return new Polygon2D( this.vertices );\n        },\n\n        flipVertexOrder: function(){\n            this.vertices.reverse();\n            return this;\n        },\n\n        /**\n        * Returns the vertex at the given index. This function follows Python\n        * convention, in that if the index is negative, it is considered relative\n        * to the list end. Therefore the vertex at index -1 is the last vertex in\n        * the list.\n        * @param {Number} i index\n        * @return vertex\n        */\n        get: function( i ){\n            if( i < 0 ){\n                i += this.vertices.length;\n            }\n            return this.vertices[i];\n        },\n\n        /**\n        * Computes the length of this polygon's apothem. This will only be valid if\n        * the polygon is regular. More info: http://en.wikipedia.org/wiki/Apothem\n        * @return apothem length\n        */\n        getApothem: function() {\n            return this.vertices[0]\n                .interpolateTo(this.vertices[1], 0.5)\n                .distanceTo( this.getCentroid() );\n        },\n\n        getArea: function(){\n            var area = 0,\n                numPoints = this.vertices.length;\n            for(var i=0;i<numPoints;i++){\n                var a = this.vertices[i],\n                    b = this.vertices[(i+1) % numPoints];\n                area += a.x * b.y;\n                area -= a.y * b.x;\n            }\n            area *= 0.5;\n            return area;\n        },\n\n        getBoundingCircle: function() {\n            var Circle = require('./Circle');\n            return Circle.newBoundingCircle( this.vertices );\n        },\n\n        getBounds: function(){\n            var Rect = require('./Rect');\n            return Rect.getBoundingRect(this.vertices);\n        },\n\n        getCentroid: function(){\n            var res = new Vec2D(),\n                numPoints = this.vertices.length;\n            for(var i=0;i<numPoints;i++){\n                var a = this.vertices[i],\n                    b = this.vertices[(i+1) %numPoints],\n                    factor = a.x * b.y - b.x * a.y;\n                res.x += (a.x + b.x) * factor;\n                res.y += (a.y + b.y) * factor;\n            }\n            return res.scale(1 / (this.getArea() * 6));\n        },\n\n        getCircumference: function(){\n            var circ = 0;\n            for(var i=0,num=this.vertices.length;i<num;i++){\n                circ += this.vertices[i].distanceTo(this.vertices[(i+1)%num]);\n            }\n            return circ;\n        },\n\n        getClosestPointTo: function( p ){\n            var minD = Number.MAX_VALUE;\n            var q, c, d;\n            var edges = this.getEdges();\n            for( var i=0, len = edges.length; i<len; i++ ){\n                c = edges[i].closestPointTo( p );\n                d = c.distanceToSquared( p );\n                if( d < minD ){\n                    q = c;\n                    minD = d;\n                }\n            }\n            return q;\n        },\n\n        getClosestVertexTo: function( p ){\n            var minD = Number.MAX_VALUE;\n            var q, d, i = 0, len = this.vertices.length;\n            for( ; i<len; i++){\n                d = this.vertices[i].distanceToSquared( p );\n                if( d < minD ){\n                    q = this.vertices[i];\n                    minD = d;\n                }\n            }\n            return q;\n        },\n\n        getEdges: function() {\n            var num = this.vertices.length,\n                edges = [];\n            for (var i = 0; i < num; i++) {\n                edges[i] = new Line2D(this.vertices[i], this.vertices[(i + 1) % num]);\n            }\n            return edges;\n        },\n\n        //@deprecated\n        getNumPoints: function(){\n            return this.getNumVertices();\n        },\n\n        getNumVertices: function(){\n            return this.vertices.length;\n        },\n\n        getRandomPoint: function(){\n            var edges = this.getEdges();\n            var numEdges = edges.length;\n            var ea = edges[MathUtils.random(numEdges)],\n                eb;\n            while( eb === undefined || eb.equals( ea ) ){\n                eb = edges[ MathUtils.random(numEdges) ];\n            }\n            //pick a random point on edge A\n            var p = ea.a.interpolateTo( ea.b, Math.random() );\n            //then randomly interpolate to another point on b\n            return p.interpolateToSelf(\n                eb.a.interpolateTo( eb.b, Math.random() ),\n                Math.random()\n            );\n        },\n\n        /**\n        * Repeatedly inserts vertices as mid points of the longest edges until the\n        * new vertex count is reached.\n        * @param {Number} count new vertex count\n        * @return itself\n        */\n        increaseVertexCount: function( count ){\n            var num = this.vertices.length,\n                longestID = 0,\n                maxD = 0,\n                i = 0,\n                d,\n                m;\n\n            while( num < count ){\n                //find longest edge\n                longestID = 0;\n                maxD = 0;\n                for( i=0; i<num; i++ ){\n                    d = this.vertices[i].distanceToSquared( this.vertices[ (i+1) % num ] );\n                    if( d > maxD ){\n                        longestID = i;\n                        maxD = d;\n                    }\n                }\n                //insert mid point of longest segment\n                m = this.vertices[longestID]\n                    .add(this.vertices[(longestID + 1) % num])\n                    .scaleSelf(0.5);\n                //push this into the array inbetween the 2 points\n                this.vertices.splice( longestID+1, 0, m );\n                num++;\n            }\n            return this;\n        },\n\n        intersectsPolygon: function(poly) {\n            if (!this.containsPolygon(poly)) {\n                var edges=this.getEdges();\n                var pedges=poly.getEdges();\n                for(var i=0, n=edges.length; i < n; i++) {\n                    for(var j=0, m = pedges.length, e = edges[i]; j < m; j++) {\n                        if (e.intersectLine(pedges[j]).getType() == Line2D.LineIntersection.Type.INTERSECTING) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            } else {\n                return true;\n            }\n        },\n\n        isClockwise: function(){\n            return this.getArea() > 0;\n        },\n\n        /**\n        * Checks if the polygon is convex.\n        * @return true, if convex.\n        */\n        isConvex: function(){\n            var isPositive = false,\n                num = this.vertices.length,\n                prev,\n                next,\n                d0,\n                d1,\n                newIsP;\n\n            for( var i = 0; i < num; i++ ){\n                prev = (i===0) ? num -1 : i - 1;\n                next = (i===num-1) ? 0 : i + 1;\n                d0 = this.vertices[i].sub(this.vertices[prev]);\n                d1 = this.vertices[next].sub(this.vertices[i]);\n                newIsP = (d0.cross(d1) > 0);\n                if( i === 0 ) {\n                    isPositive = true;\n                } else if( isPositive != newIsP ) {\n                    return false;\n                }\n            }\n            return true;\n        },\n\n        /**\n        * Given the sequentially connected points p1, p2, p3, this function returns\n        * a bevel-offset replacement for point p2.\n        *\n        * Note: If vectors p1->p2 and p2->p3 are exactly 180 degrees opposed, or if\n        * either segment is zero then no offset will be applied.\n        *\n        * @param x1\n        * @param y1\n        * @param x2\n        * @param y2\n        * @param x3\n        * @param y3\n        * @param distance\n        * @param out\n        *\n        * @see http://alienryderflex.com/polygon_inset/\n        */\n        _offsetCorner: function( x1, y1, x2, y2, x3, y3, distance, out ){\n            var c1 = x2,\n                d1 = y2,\n                c2 = x2,\n                d2 = y2;\n            var dx1,\n                dy1,\n                dist1,\n                dx2,\n                dy2,\n                dist2,\n                insetX,\n                insetY;\n\n            dx1 = x2-x1;\n            dy1 = y2-y1;\n            dist1 = Math.sqrt(dx1*dx1 + dy1*dy1);\n            dx2 = x3-x2;\n            dy2 = y3-y2;\n            dist2 = Math.sqrt(dx2*dx2 + dy2*dy2);\n\n            if( dist1 < MathUtils.EPS || dist2 < MathUtils.EPS ){\n                return;\n            }\n\n            dist1 = distance / dist1;\n            dist2 = distance / dist2;\n\n            insetX = dy1 * dist1;\n            insetY = -dx1 * dist1;\n            x1 += insetX;\n            c1 += insetX;\n            y1 += insetY;\n            d1 += insetY;\n            insetX = dy2 * dist2;\n            insetY = -dx2 * dist2;\n            x3 += insetX;\n            c2 += insetX;\n            y3 += insetY;\n            d2 += insetY;\n\n            if( c1 === c2 && d1 === d2 ){\n                out.set(c1,d1);\n                return;\n            }\n\n            var l1 = new Line2D( new Vec2D(x1,y1), new Vec2D(c1,d1) ),\n                l2 = new Line2D( new Vec2D(c2,d2), new Vec2D(x3,y3) ),\n                isec = l1.intersectLine(l2),\n                ipos = isec.getPos();\n            if( ipos !== null || ipos !== undefined ){\n                out.set(ipos);\n            }\n        },\n\n        /**\n        * Moves each line segment of the polygon in/outward perpendicular by the\n        * given distance. New line segments and polygon vertices are created by\n        * computing the intersection points of the displaced segments. Choosing an\n        * too large displacement amount will result in deformation/undefined\n        * behavior with various self intersections. Should that happen, please try\n        * to clean up the shape using the {@link #toOutline()} method.\n        *\n        * @param distance\n        *            offset/inset distance (negative for inset)\n        * @return itself\n        */\n        offsetShape: function( distance ){\n            var v = this.vertices;\n            var num = v.length - 1;\n            if( num > 1 ){\n                var startX = v[0].x,\n                    startY = v[0].y,\n                    c = v[num].x,\n                    d = v[num].y,\n                    e = startX,\n                    f = startY,\n                    a,\n                    b;\n                for( var i = 0; i < num; i++ ){\n                    a = c;\n                    b = d;\n                    c = e;\n                    d = f;\n                    e = v[i + 1].x;\n                    f = v[i + 1].y;\n                    this._offsetCorner(a, b, c, d, e, f, distance, v[i]);\n                }\n                this._offsetCorner(c, d, e, f, startX, startY, distance, v[num]);\n            }\n            return this;\n        },\n\n        /**\n        * Reduces the number of vertices in the polygon based on the given minimum\n        * edge length. Only vertices with at least this distance between them will\n        * be kept.\n        *\n        * @param minEdgeLen\n        * @return itself\n        */\n        reduceVertices: function( minEdgeLen ){\n            minEdgeLen *= minEdgeLen;\n            var vs = this.vertices,\n                reduced = [],\n                prev = vs[0],\n                num = vs.length - 1,\n                vec;\n            reduced.push(prev);\n            for( var i = 0; i < num; i++ ){\n                vec = vs[i];\n                if( prev.distanceToSquared(vec) >= minEdgeLen ){\n                    reduced.push(vec);\n                    prev = vec;\n                }\n            }\n            if( vs[0].distanceToSquared(vs[num]) >= minEdgeLen ){\n                reduced.push(vs[num]);\n            }\n            this.vertices = reduced;\n            return this;\n        },\n\n\n        /**\n        * Removes duplicate vertices from the polygon. Only successive points are\n        * recognized as duplicates.\n        * @param {Number} tolerance snap distance for finding duplicates\n        * @return itself\n        */\n        removeDuplicates: function( tolerance ){\n            //if tolerance is 0, it will be faster to just use 'equals' method\n            var equals = tolerance ? 'equalsWithTolerance' : 'equals';\n            var p, prev, i = 0, num = this.vertices.length;\n            var last;\n            for( ; i<num; i++ ){\n                p = this.vertices[i];\n                //if its the 'equals' method tolerance will just be ingored\n                if( p[equals]( prev, tolerance ) ){\n                    //remove from array, step back counter\n                    this.vertices.splice( i, 1 );\n                    i--;\n                    num--;\n                } else {\n                    prev = p;\n                }\n            }\n            num = this.vertices.length;\n            if( num >  0 ){\n                last = this.vertices[num-1];\n                if( last[equals]( this.vertices[0], tolerance ) ){\n                    this.vertices.splice( num-1, 1 );\n                }\n            }\n            return this;\n        },\n\n        rotate: function(theta) {\n            for (var i=0, num=this.vertices.length; i < num; i++) {\n                this.vertices[i].rotate(theta);\n            }\n            return this;\n        },\n\n        scale: function( x, y ) {\n            if (arguments.length==1) {\n                var arg = arguments[0];\n                if( has.XY( arg ) ){\n                    x=arg.x;\n                    y=arg.y;\n                } else {\n                    // uniform scale\n                    x=arg;\n                    y=arg;\n                }\n            } else if (arguments.length==2) {\n                x=arguments[0];\n                y=arguments[1];\n            } else {\n                throw \"Invalid argument(s) passed.\";\n            }\n            for (var i=0, num=this.vertices.length; i < num; i++) {\n                this.vertices[i].scaleSelf(x, y);\n            }\n            return this;\n        },\n\n        scaleSize: function( x, y ){\n            var centroid;\n            if(arguments.length===1) {\n                var arg = arguments[0];\n                if( has.XY(arg) ){\n                    x = arg.x;\n                    y = arg.y;\n                } else {\n                    //uniform\n                    x = arg;\n                    y = arg;\n                }\n            } else if ( arguments.length===2) {\n                x = arguments[0];\n                y = arguments[1];\n            } else {\n                throw new Error('Invalid argument(s) passed.');\n            }\n            centroid = this.getCentroid();\n            for( var i = 0, l = this.vertices.length; i<l; i++ ){\n                var v = this.vertices[i];\n                v.subSelf(centroid).scaleSelf(x,y).addSelf(centroid);\n            }\n            return this;\n        },\n\n        smooth: function(amount, baseWeight){\n            var centroid = this.getCentroid();\n            var num = this.vertices.length;\n            var filtered = [];\n            for(var i=0,j=num-1,k=1;i<num;i++){\n                var a = this.vertices[i];\n                var dir = this.vertices[j].sub(a).addSelf(this.vertices[k].sub(a))\n                    .addSelf(a.sub(centroid).scaleSelf(baseWeight));\n                filtered.push(a.add(dir.scaleSelf(amount)));\n                j++;\n                if(j == num){\n                    j=0;\n                }\n                k++;\n                if(k == num){\n                    k=0;\n                }\n            }\n            this.vertices = filtered;\n            return this;\n        },\n\n        toMesh: function( mesh, centroid2D, extrude ){\n            mesh = mesh || new TriangleMesh();\n            var num = this.vertices.length;\n            centroid2D = centroid2D || this.getCentroid();\n            var centroid = centroid2D.to3DXY();\n            centroid.z = extrude;\n            var bounds = this.getBounds(),\n                boundScale = new Vec2D(1/bounds.width, 1/bounds.height),\n                uvC = centroid2D.sub(bounds.getTopLeft()).scaleSelf(boundScale),\n                a, b, uvA, uvB;\n\n            for( var i=1; i<=num; i++ ){\n                a = this.vertices[i % num];\n                b = this.vertices[i - 1];\n                uvA = a.sub(bounds.getTopLeft()).scaleSelf(boundScale);\n                uvB = b.sub(bounds.getTopLeft()).scaleSelf(boundScale);\n                mesh.addFace(centroid, a.to3DXY(), b.to3DXY(), uvC, uvA, uvB);\n            }\n            return mesh;\n        },\n\n        toPolygon2D: function(){\n            return this;\n        },\n\n        toString: function(){\n            var s = \"\";\n            for(var i=0;i<this.vertices.length;i++){\n                s += this.vertices[i];\n                if(i<this.vertices.length-1){\n                    s+= \", \";\n                }\n            }\n            return s;\n        },\n\n        translate: function() {\n            var x,y;\n            if (arguments.length==1 && has.XY( arguments[0] ) ){\n                x=arguments[0].x;\n                y=arguments[0].y;\n            } else if (arguments.length==2) {\n                x=arguments[0];\n                y=arguments[1];\n            } else {\n                throw \"Invalid argument(s) passed.\";\n            }\n            for (var i=0, num=this.vertices.length; i < num; i++) {\n                this.vertices[i].addSelf(x, y);\n            }\n            return this;\n        }\n    };\n\n    /**\n    * Constructs a new regular polygon from the given base line/edge.\n    * @param {Vec2D} baseA left point of the base edge\n    * @param {Vec2D} baseB right point of the base edge\n    * @param {Number} res number of polygon vertices\n    * @return polygon\n    */\n    Polygon2D.fromBaseEdge = function( baseA, baseB, res ){\n        var theta = -( MathUtils.PI - (MathUtils.PI*(res-2) / res) ),\n            dir = baseB.sub( baseA ),\n            prev = baseB,\n            poly = new Polygon2D( baseA, baseB ),\n            p;\n        for( var i=0; i< res-1; i++){\n            p = prev.add( dir.getRotated(theta*i) );\n            poly.add( p );\n            prev = p;\n        }\n        return poly;\n    };\n\n    /**\n    * Constructs a regular polygon from the given edge length and number of\n    * vertices. This automatically computes the radius of the circle the\n    * polygon is inscribed in.\n    * More information: http://en.wikipedia.org/wiki/Regular_polygon#Radius\n    *\n    * @param {Number} len desired edge length\n    * @param {Number} res number of vertices\n    * @return polygon\n    */\n    Polygon2D.fromEdgeLength = function( len, res ){\n        var Circle = require('./Circle');\n        return new Circle( Polygon2D.getRadiusForEdgeLength(len,res) ).toPolygon2D( res );\n    };\n\n    /**\n    * Computes the radius of the circle the regular polygon with the desired\n    * edge length is inscribed in\n    * @param {Number} len edge length\n    * @param {Number} res number of polygon vertices\n    * @return radius\n    */\n    Polygon2D.getRadiusForEdgeLength = function( len, res ){\n        return len / ( 2 * MathUtils.sin(MathUtils.PI/res) );\n    };\n\n    module.exports = Polygon2D;\n\n"]},"metadata":{},"sourceType":"script"}