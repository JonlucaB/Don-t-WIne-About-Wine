{"ast":null,"code":"var is = require('../internals/is'),\n    each = require('../internals/each'),\n    Iterator = require('../internals/Iterator'),\n    mathUtils = require('../math/mathUtils'),\n    TColor = require('./TColor'),\n    HSVDistanceProxy = require('./HSVDistanceProxy'),\n    RGBDistanceProxy = require('./RGBDistanceProxy'),\n    ProximityComparator = require('./ProximityComparator'),\n    AccessCriteria = require('./accessCriteria');\n/**\n * A container class of concrete colors. ColorLists can be built manually and\n * are also created when working with {@link ColorRange}s. The class has various\n * methods to manipulate all colors in the list in parallel, as well as sort\n * them by various criteria.\n * @see ColorRange\n * @see AccessCriteria\n */\n\n/**\n @memberOf toxi.color\n @class Creates a ColorList by wrapping the given ArrayList of colors. No copies\n of the given colors are created (shallow copy only).\n @param {TColor[]} colors\n*/\n\n\nvar ColorList = function (colors) {\n  if (arguments.length > 1) {\n    return ColorList.call(this, arguments);\n  }\n\n  this.colors = [];\n  var i = 0;\n\n  if (is.Array(colors) && colors.length) {\n    if (typeof colors[0] === 'number') {\n      //argb integers\n      for (i = 0, l = colors.length; i < l; i++) {\n        this.colors.push(TColor.newARGB(colors[i]));\n      }\n    } else {\n      //an array of tcolors\n      this.addAll(colors);\n    }\n  } else if (is.ColorList(colors)) {\n    for (i = 0, l = colors.size(); i < l; i++) {\n      this.add(colors.get(i));\n    }\n  } else if (is.TColor(colors)) {\n    //tcolor\n    this.add(colors);\n  }\n};\n\nColorList.prototype = {\n  constructor: ColorList,\n\n  /**\n  * Adds a copy of the given color to the list\n  * @param {TColor} c\n  * @return itself\n  */\n  add: function (c) {\n    this.colors.push(c.copy());\n    return this;\n  },\n\n  /**\n  * Adds all entries of the TColor collection to the list (shallow copy only,\n  * manipulating the new list will modify the original colors).\n  * @param {Array} collection\n  * @return itself\n  */\n  addAll: function (collection) {\n    var self = this;\n\n    if (!is.Array(collection)) {\n      this.colors.push(collection);\n    } else {\n      each(collection, function (color) {\n        self.colors.push(color);\n      });\n    }\n\n    return this;\n  },\n\n  /**\n  * Adjusts the brightness component of all list colors by the given amount.\n  * @param step adjustment value\n  * @return itself\n  */\n  adjustBrightness: function (step) {\n    each(this.colors, function (c) {\n      c.lighten(step);\n    });\n    return this;\n  },\n\n  /**\n   * Adjusts the saturation component of all list colors by the given amount.\n  \t * @param step\n   *            adjustment value\n   * @return itself\n   */\n  adjustSaturation: function (step) {\n    each(this.colors, function (c) {\n      c.saturate(step);\n    });\n    return this;\n  },\n\n  /**\n  * Sorts the list based on two criteria to create clusters/segments within\n  * the list.\n  * @param clusterCriteria main sort criteria\n  * @param subClusterCriteria secondary sort criteria\n  * @param numClusters number of clusters\n  * @param isReversed true, if reversed sort\n  * @return itself\n  */\n  clusterSort: function (clusterCriteria, subClusterCriteria, numClusters, isReversed) {\n    var sorted = this.colors.slice(0),\n        clusters = [],\n        d = 1,\n        i = 0,\n        num = sorted.length,\n        slice;\n    sorted.sort(clusterCriteria.compare).reverse();\n\n    for (var j = 0; j < num; j++) {\n      var c = sorted[j];\n\n      if (c.getComponentValue(clusterCriteria) < d) {\n        slice = sorted.slice(i, j);\n        slice.sort(subClusterCriteria.compare);\n        clusters.push.apply(clusters, slice);\n        d -= 1.0 / numClusters;\n        i = j;\n      }\n    }\n\n    slice = [];\n    Array.prototype.push.apply(slice, sorted.slice(i, sorted.length));\n    slice.sort(subClusterCriteria.compare);\n    clusters.push.apply(clusters, slice);\n\n    if (isReversed) {\n      clusters.reverse();\n    }\n\n    this.colors = clusters;\n    return this;\n  },\n\n  /**\n  * Switches all list colors to their complementary color.\n  * @return itself\n  */\n  complement: function () {\n    this.each(function (c) {\n      c.complement();\n    });\n    return this;\n  },\n\n  /**\n  * Checks if the given color is part of the list. Check is done by value,\n  * not instance.\n  * @param color\n  * @return true, if the color is present.\n  */\n  contains: function (color) {\n    for (var i = 0, l = this.colors.length; i < l; i++) {\n      if (this.colors[i].equals(color)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  each: function (fn) {\n    each(this.colors, fn);\n    return this;\n  },\n\n  /**\n  * Returns the color at the given index. This function follows Python\n  * convention, in that if the index is negative, it is considered relative\n  * to the list end. Therefore the color at index -1 is the last color in the\n  * list.\n  * @param i\n  *            index\n  * @return color\n  */\n  get: function (i) {\n    if (i < 0) {\n      i += this.colors.length;\n    }\n\n    return this.colors[i];\n  },\n\n  /**\n  * Calculates and returns the average color of the list.\n  * @return average color or null, if there're no entries yet.\n  */\n  getAverage: function () {\n    var r = 0,\n        g = 0,\n        b = 0,\n        a = 0;\n    this.each(function (c) {\n      r += c.rgb[0];\n      g += c.rgb[1];\n      b += c.rgb[2];\n      a += c.alpha();\n    });\n    var num = this.colors.length;\n\n    if (num > 0) {\n      return TColor.newRGBA(r / num, g / num, b / num, a / num);\n    }\n\n    return undefined;\n  },\n\n  /**\n  * Creates a new ColorList by blending all colors in the list with each\n  * other (successive indices only)\n  * @param amount\n  *            blend amount\n  * @return new color list\n  */\n  getBlended: function (amount) {\n    var clrs = [],\n        len = this.colors.length;\n\n    for (var i = 0; i < len; i++) {\n      var index = i > 0 ? i - 1 : clrs.length - 1,\n          c = this.colors[index];\n      clrs.push(this.colors[i].getBlended(c, amount));\n    }\n\n    return new ColorList(clrs);\n  },\n\n  /**\n  * Finds and returns the darkest color of the list.\n  * @return darkest color or null if there're no entries yet.\n  */\n  getDarkest: function () {\n    var darkest,\n        minBrightness = Number.MAX_VALUE;\n    this.each(function (c) {\n      var luma = c.luminance();\n\n      if (luma < minBrightness) {\n        darkest = c;\n        minBrightness = luma;\n      }\n    });\n    return darkest;\n  },\n\n  /**\n  * Finds and returns the lightest (luminance) color of the list.\n  * @return lightest color or null, if there're no entries yet.\n  */\n  getLightest: function () {\n    var lightest,\n        maxBrightness = Number.MIN_VALUE;\n    this.each(function (c) {\n      var luma = c.luminance();\n\n      if (luma > maxBrightness) {\n        lightest = c;\n        maxBrightness = luma;\n      }\n    });\n    return lightest;\n  },\n  getRandom: function () {\n    var index = Math.floor(mathUtils.random(this.colors.length));\n    return this.colors[index];\n  },\n  getReverse: function () {\n    return new ColorList(this.colors).reverse();\n  },\n  invert: function () {\n    this.each(function (c) {\n      c.invert();\n    });\n    return this;\n  },\n  iterator: function () {\n    return new Iterator(this.colors);\n  },\n  reverse: function () {\n    this.colors.reverse();\n    return this;\n  },\n  rotateRYB: function (theta, isRadians) {\n    var angle;\n\n    if (theta !== Math.floor(theta) || isRadians) {\n      angle = mathUtils.degrees(theta);\n    } else {\n      angle = theta;\n    }\n\n    this.each(function (c) {\n      c.rotateRYB(angle);\n    });\n    return this;\n  },\n  size: function () {\n    return this.colors.length;\n  },\n  sort: function () {\n    return this.sortByCriteria(AccessCriteria.HUE, false);\n  },\n\n  /**\n  * Sorts the list using the given comparator.\n  * @param comp\n  *            comparator\n  * @param isReversed\n  *            true, if reversed sort\n  * @return itself\n  */\n  sortByComparator: function (comp, isReversed) {\n    //if a normal ( a, b ) sort function instead of an AccessCriteria,\n    //wrap it so it can be invoked the same\n    if (typeof comp === 'function' && typeof comp.compare === 'undefined') {\n      comp = {\n        compare: comp\n      };\n    }\n\n    this.colors.sort(comp.compare);\n\n    if (isReversed) {\n      this.colors.reverse();\n    }\n\n    return this;\n  },\n\n  /**\n  * Sorts the list using the given {@link AccessCriteria}.\n  * @param criteria\n  *            sort criteria\n  * @param isReversed\n  *            true, if reversed sort\n  * @return itself\n  */\n  sortByCriteria: function (criteria, isReversed) {\n    return this.sortByComparator(criteria, isReversed);\n  },\n\n  /**\n  * Sorts the list by relative distance to each predecessor, starting with\n  * the darkest color in the list.\n     * @param {toxi.color.*{DistanceProxy}} proxy\n  * @param isReversed\n  *            true, if list is to be sorted in reverse.\n  * @return itself\n  */\n  sortByDistance: function (proxy, isReversed) {\n    if (arguments.length === 1) {\n      isReversed = arguments[0];\n      proxy = new HSVDistanceProxy();\n    }\n\n    if (this.colors.length === 0) {\n      return this;\n    } // Remove the darkest color from the stack,\n    // put it in the sorted list as starting element.\n\n\n    var root = this.getDarkest(),\n        stack = this.colors.slice(0),\n        sorted = [];\n    stack.splice(stack.indexOf(root), 1);\n    sorted.push(root); // Now find the color in the stack closest to that color.\n    // Take this color from the stack and add it to the sorted list.\n    // Now find the color closest to that color, etc.\n\n    var sortedCount = 0;\n\n    while (stack.length > 1) {\n      var closest = stack[0],\n          lastSorted = sorted[sortedCount],\n          distance = proxy.distanceBetween(closest, lastSorted);\n\n      for (var i = stack.length - 1; i >= 0; i--) {\n        var c = stack[i],\n            d = proxy.distanceBetween(c, lastSorted);\n\n        if (d < distance) {\n          closest = c;\n          distance = d;\n        }\n      }\n\n      stack.splice(stack.indexOf(closest), 1);\n      sorted.push(closest);\n      sortedCount++;\n    }\n\n    sorted.push(stack[0]);\n\n    if (isReversed) {\n      sorted.reverse();\n    }\n\n    this.colors = sorted;\n    return this;\n  },\n\n  /**\n  * Sorts the list by proximity to the given target color (using RGB distance\n  * metrics).\n  * @see #sortByProximityTo(ReadonlyTColor, DistanceProxy, boolean)\n  * @param target\n  *            color\n  * @param isReversed\n  *            true, if reverse sorted\n  * @return sorted list\n  */\n  sortByProximityTo: function (target, proxy, isReversed) {\n    if (arguments.length == 2) {\n      target = arguments[0];\n      proxy = new RGBDistanceProxy();\n      isReversed = arguments[1];\n    }\n\n    return this.sortByComparator(new ProximityComparator(target, proxy), isReversed);\n  },\n  toARGBArray: function () {\n    var array = [];\n    this.each(function (c) {\n      array.push(c.toARGB());\n    });\n    return array;\n  }\n};\n/**\n * Factory method. Creates a new ColorList of colors randomly sampled from\n * the given ARGB image array. If the number of samples equals or exceeds\n * the number of pixels in the source image and no unique colors are\n * required, the function will simply return the same as\n * {@link #ColorList(int[])}.\n * @param pixels\n *            int array of ARGB pixels\n * @param num\n *            number of colors samples (clipped automatically to number of\n *            pixels in the image)\n * @param uniqueOnly\n *            flag if only unique samples are to be taken (doesn't guarantee\n *            unique colors though)\n * @param maxIterations (optional)\n *            max number of attempts to find a unique color. If no more\n *            unique colors can be found the search is terminated.\n * @return new color list of samples\n */\n\nColorList.createFromARGBArray = function (pixels, num, uniqueOnly, maxIterations) {\n  maxIterations = maxIterations || 100;\n  num = mathUtils.min(num, pixels.length);\n\n  if (!uniqueOnly && num == pixels.length) {\n    return new ColorList(pixels);\n  }\n\n  var colors = [],\n      temp = TColor.BLACK.copy(),\n      i = 0,\n      isUnique = true,\n      numTries = 0,\n      idx;\n\n  for (i = 0; i < num; i++) {\n    if (uniqueOnly) {\n      isUnique = true;\n      numTries = 0;\n\n      do {\n        idx = mathUtils.random(pixels.length);\n        temp.setARGB(pixels[idx]);\n        isUnique = !(colors.indexOf(temp) >= 0);\n      } while (!isUnique && ++numTries < maxIterations);\n\n      if (numTries < maxIterations) {\n        colors.push(temp.copy());\n      } else {\n        break;\n      }\n    } else {\n      idx = mathUtils.random(pixels.length);\n      colors.push(TColor.newARGB(pixels[idx]));\n    }\n  }\n\n  return new ColorList(colors);\n};\n\nColorList.createUsingStrategy = function () {\n  throw new Error('Not allowed, use toxi/color/createListUsingStrategy instead');\n};\n\nmodule.exports = ColorList;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/color/ColorList.js"],"names":["is","require","each","Iterator","mathUtils","TColor","HSVDistanceProxy","RGBDistanceProxy","ProximityComparator","AccessCriteria","ColorList","colors","arguments","length","call","i","Array","l","push","newARGB","addAll","size","add","get","prototype","constructor","c","copy","collection","self","color","adjustBrightness","step","lighten","adjustSaturation","saturate","clusterSort","clusterCriteria","subClusterCriteria","numClusters","isReversed","sorted","slice","clusters","d","num","sort","compare","reverse","j","getComponentValue","apply","complement","contains","equals","fn","getAverage","r","g","b","a","rgb","alpha","newRGBA","undefined","getBlended","amount","clrs","len","index","getDarkest","darkest","minBrightness","Number","MAX_VALUE","luma","luminance","getLightest","lightest","maxBrightness","MIN_VALUE","getRandom","Math","floor","random","getReverse","invert","iterator","rotateRYB","theta","isRadians","angle","degrees","sortByCriteria","HUE","sortByComparator","comp","criteria","sortByDistance","proxy","root","stack","splice","indexOf","sortedCount","closest","lastSorted","distance","distanceBetween","sortByProximityTo","target","toARGBArray","array","toARGB","createFromARGBArray","pixels","uniqueOnly","maxIterations","min","temp","BLACK","isUnique","numTries","idx","setARGB","createUsingStrategy","Error","module","exports"],"mappings":"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","sourcesContent":["\n\nvar is = require('../internals/is'),\n    each = require('../internals/each'),\n    Iterator = require('../internals/Iterator'),\n\tmathUtils = require('../math/mathUtils'),\n\tTColor = require('./TColor'),\n\tHSVDistanceProxy = require('./HSVDistanceProxy'),\n\tRGBDistanceProxy = require('./RGBDistanceProxy'),\n\tProximityComparator = require('./ProximityComparator'),\n\tAccessCriteria = require('./accessCriteria');\n\n/**\n * A container class of concrete colors. ColorLists can be built manually and\n * are also created when working with {@link ColorRange}s. The class has various\n * methods to manipulate all colors in the list in parallel, as well as sort\n * them by various criteria.\n * @see ColorRange\n * @see AccessCriteria\n */\n\n\n/**\n @memberOf toxi.color\n @class Creates a ColorList by wrapping the given ArrayList of colors. No copies\n of the given colors are created (shallow copy only).\n @param {TColor[]} colors\n*/\nvar ColorList = function(colors){\n\tif(arguments.length > 1){\n\t\treturn ColorList.call(this,arguments);\n\t}\n\tthis.colors = [];\n    var i = 0;\n    if( is.Array(colors) && colors.length ){\n        if( typeof colors[0] === 'number' ){\n            //argb integers\n            for( i=0, l = colors.length; i<l; i++){\n                this.colors.push(TColor.newARGB(colors[i]));\n            }\n        } else {\n            //an array of tcolors\n            this.addAll(colors);\n        }\n    } else if( is.ColorList(colors) ){\n        for( i=0, l=colors.size(); i<l; i++){\n            this.add(colors.get(i));\n        }\n    } else if( is.TColor(colors) ){\n        //tcolor\n        this.add(colors);\n    }\n};\n\nColorList.prototype = {\n\tconstructor: ColorList,\n\t/**\n\t* Adds a copy of the given color to the list\n\t* @param {TColor} c\n\t* @return itself\n\t*/\n\tadd: function(c){\n\t\tthis.colors.push(c.copy());\n\t\treturn this;\n\t},\n\t/**\n\t* Adds all entries of the TColor collection to the list (shallow copy only,\n\t* manipulating the new list will modify the original colors).\n\t* @param {Array} collection\n\t* @return itself\n\t*/\n\taddAll:\tfunction(collection){\n\t\tvar self = this;\n        if( !is.Array(collection) ){\n            this.colors.push(collection);\n        } else {\n            each(collection,function(color){\n                self.colors.push(color);\n            });\n        }\n\t\treturn this;\n\t},\n\t/**\n\t* Adjusts the brightness component of all list colors by the given amount.\n\t* @param step adjustment value\n\t* @return itself\n\t*/\n\tadjustBrightness: function(step){\n\t\teach(this.colors,function(c){\n\t\t\tc.lighten(step);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t * Adjusts the saturation component of all list colors by the given amount.\n\t\t * @param step\n\t *            adjustment value\n\t * @return itself\n\t */\n\tadjustSaturation: function(step){\n\t\teach(this.colors,function(c){\n\t\t\tc.saturate(step);\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t* Sorts the list based on two criteria to create clusters/segments within\n\t* the list.\n\t* @param clusterCriteria main sort criteria\n\t* @param subClusterCriteria secondary sort criteria\n\t* @param numClusters number of clusters\n\t* @param isReversed true, if reversed sort\n\t* @return itself\n\t*/\n\tclusterSort: function(clusterCriteria, subClusterCriteria, numClusters, isReversed){\n\t\tvar sorted = this.colors.slice(0),\n\t\t\tclusters = [],\n\t\t\td = 1,\n\t\t\ti = 0,\n\t\t\tnum = sorted.length,\n\t\t\tslice;\n\n\t\tsorted.sort( clusterCriteria.compare ).reverse();\n\t\tfor(var j=0;j<num;j++){\n\t\t\tvar c = sorted[j];\n\t\t\tif(c.getComponentValue(clusterCriteria) < d){\n\t\t\t\tslice = sorted.slice(i, j);\n\t\t\t\tslice.sort( subClusterCriteria.compare );\n\t\t\t\tclusters.push.apply(clusters,slice);\n\t\t\t\td -= 1.0 / numClusters;\n\t\t\t\ti = j;\n\t\t\t}\n\t\t}\n\t\tslice = [];\n\t\tArray.prototype.push.apply(slice,sorted.slice(i,sorted.length));\n\t\tslice.sort( subClusterCriteria.compare );\n\t\tclusters.push.apply(clusters,slice);\n\t\tif(isReversed){\n\t\t\tclusters.reverse();\n\t\t}\n\t\tthis.colors = clusters;\n\t\treturn this;\n\t},\n\t/**\n\t* Switches all list colors to their complementary color.\n\t* @return itself\n\t*/\n\tcomplement: function(){\n\t\tthis.each(function(c){\n\t\t\tc.complement();\n\t\t});\n\t\treturn this;\n\t},\n\t/**\n\t* Checks if the given color is part of the list. Check is done by value,\n\t* not instance.\n\t* @param color\n\t* @return true, if the color is present.\n\t*/\n\tcontains: function(color){\n\t\tfor( var i=0, l= this.colors.length; i<l; i++){\n\t\t\tif( this.colors[i].equals( color ) ){\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\treturn false;\n\t},\n\teach: function( fn ){\n\t\teach( this.colors, fn );\n\t\treturn this;\n\t},\n\t/**\n\t* Returns the color at the given index. This function follows Python\n\t* convention, in that if the index is negative, it is considered relative\n\t* to the list end. Therefore the color at index -1 is the last color in the\n\t* list.\n\t* @param i\n\t*            index\n\t* @return color\n\t*/\n\tget: function(i){\n\t\tif(i < 0){\n\t\t\ti += this.colors.length;\n\t\t}\n\t\treturn this.colors[i];\n\t},\n\t/**\n\t* Calculates and returns the average color of the list.\n\t* @return average color or null, if there're no entries yet.\n\t*/\n\tgetAverage: function(){\n\t\tvar r = 0,\n\t\t\tg = 0,\n\t\t\tb = 0,\n\t\t\ta = 0;\n\n\t\tthis.each(function(c){\n\t\t\tr += c.rgb[0];\n\t\t\tg += c.rgb[1];\n\t\t\tb += c.rgb[2];\n\t\t\ta += c.alpha();\n\t\t});\n\n\t\tvar num = this.colors.length;\n\t\tif(num > 0){\n\t\t\treturn TColor.newRGBA(r / num, g / num, b / num, a / num);\n\t\t}\n\t\treturn undefined;\n\t},\n\t/**\n\t* Creates a new ColorList by blending all colors in the list with each\n\t* other (successive indices only)\n\t* @param amount\n\t*            blend amount\n\t* @return new color list\n\t*/\n\tgetBlended: function(amount){\n\t\tvar clrs = [],\n\t\t\tlen = this.colors.length;\n\t\tfor(var i=0; i< len; i++){\n\t\t\tvar index = i > 0 ? i -1 : clrs.length - 1,\n\t\t\t\tc = this.colors[index];\n\t\t\tclrs.push(this.colors[i].getBlended(c,amount));\n\t\t}\n\t\treturn new ColorList(clrs);\n\t},\n\t/**\n\t* Finds and returns the darkest color of the list.\n\t* @return darkest color or null if there're no entries yet.\n\t*/\n\tgetDarkest: function(){\n\t\tvar darkest,\n\t\t\tminBrightness = Number.MAX_VALUE;\n\t\tthis.each(function(c){\n\t\t\tvar luma = c.luminance();\n\t\t\tif(luma < minBrightness){\n\t\t\t\tdarkest = c;\n\t\t\t\tminBrightness = luma;\n\t\t\t}\n\t\t});\n\t\treturn darkest;\n\t},\n\t/**\n\t* Finds and returns the lightest (luminance) color of the list.\n\t* @return lightest color or null, if there're no entries yet.\n\t*/\n\tgetLightest: function(){\n\t\tvar lightest,\n\t\t\tmaxBrightness = Number.MIN_VALUE;\n\t\tthis.each(function(c){\n\t\t\tvar luma = c.luminance();\n\t\t\tif(luma > maxBrightness){\n\t\t\t\tlightest = c;\n\t\t\t\tmaxBrightness = luma;\n\t\t\t}\n\t\t});\n\t\treturn lightest;\n\t},\n\n\tgetRandom: function(){\n\t\tvar index = Math.floor(mathUtils.random(this.colors.length));\n\t\treturn this.colors[index];\n\t},\n\n\tgetReverse: function(){\n\t\treturn new ColorList(this.colors).reverse();\n\t},\n\n\tinvert: function(){\n\t\tthis.each(function(c){\n\t\t\tc.invert();\n\t\t});\n\t\treturn this;\n\t},\n\n\titerator: function(){\n\t\treturn new Iterator(this.colors);\n\t},\n\n\treverse: function(){\n\t\tthis.colors.reverse();\n\t\treturn this;\n\t},\n\n\trotateRYB: function(theta, isRadians){\n\t\tvar angle;\n\t\tif(theta !== Math.floor(theta) || isRadians){\n\t\t\tangle = mathUtils.degrees(theta);\n\t\t} else {\n\t\t\tangle = theta;\n\t\t}\n\t\tthis.each(function(c){\n\t\t\tc.rotateRYB(angle);\n\t\t});\n\t\treturn this;\n\t},\n\n\tsize: function(){\n\t\treturn this.colors.length;\n\t},\n\n\tsort: function(){\n\t\treturn this.sortByCriteria(AccessCriteria.HUE, false);\n\t},\n\t/**\n\t* Sorts the list using the given comparator.\n\t* @param comp\n\t*            comparator\n\t* @param isReversed\n\t*            true, if reversed sort\n\t* @return itself\n\t*/\n\tsortByComparator: function(comp, isReversed){\n        //if a normal ( a, b ) sort function instead of an AccessCriteria,\n        //wrap it so it can be invoked the same\n        if( typeof comp === 'function' && typeof comp.compare === 'undefined' ){\n            comp = { compare: comp };\n        }\n\t\tthis.colors.sort( comp.compare );\n\t\tif(isReversed){\n\t\t\tthis.colors.reverse();\n\t\t}\n\t\treturn this;\n\t},\n\t/**\n\t* Sorts the list using the given {@link AccessCriteria}.\n\t* @param criteria\n\t*            sort criteria\n\t* @param isReversed\n\t*            true, if reversed sort\n\t* @return itself\n\t*/\n\tsortByCriteria: function(criteria, isReversed){\n\t\treturn this.sortByComparator(criteria, isReversed);\n\t},\n\t/**\n\t* Sorts the list by relative distance to each predecessor, starting with\n\t* the darkest color in the list.\n    * @param {toxi.color.*{DistanceProxy}} proxy\n\t* @param isReversed\n\t*            true, if list is to be sorted in reverse.\n\t* @return itself\n\t*/\n\n\tsortByDistance: function(proxy, isReversed){\n\t\tif(arguments.length === 1){\n\t\t\tisReversed = arguments[0];\n\t\t\tproxy = new HSVDistanceProxy();\n\t\t}\n\n\t\tif(this.colors.length === 0){\n\t\t\treturn this;\n\t\t}\n\n\t\t// Remove the darkest color from the stack,\n\t\t// put it in the sorted list as starting element.\n\t\tvar root = this.getDarkest(),\n\t\t\tstack = this.colors.slice(0),\n\t\t\tsorted = [];\n\n\t\tstack.splice(stack.indexOf(root),1);\n\t\tsorted.push(root);\n\n\t\t// Now find the color in the stack closest to that color.\n\t\t// Take this color from the stack and add it to the sorted list.\n\t\t// Now find the color closest to that color, etc.\n\t\tvar sortedCount = 0;\n\t\twhile(stack.length > 1){\n\t\t\tvar closest = stack[0],\n\t\t\t\tlastSorted = sorted[sortedCount],\n\t\t\t\tdistance = proxy.distanceBetween(closest, lastSorted);\n\n\t\t\tfor(var i = stack.length - 1; i >= 0; i--){\n\t\t\t\tvar c = stack[i],\n\t\t\t\t\td = proxy.distanceBetween(c, lastSorted);\n\t\t\t\tif(d < distance){\n\t\t\t\t\tclosest = c;\n\t\t\t\t\tdistance = d;\n\t\t\t\t}\n\t\t\t}\n\t\t\tstack.splice(stack.indexOf(closest),1);\n\t\t\tsorted.push(closest);\n\t\t\tsortedCount++;\n\t\t}\n\t\tsorted.push(stack[0]);\n\t\tif(isReversed){\n\t\t\tsorted.reverse();\n\t\t}\n\t\tthis.colors = sorted;\n\t\treturn this;\n\t},\n\t/**\n\t* Sorts the list by proximity to the given target color (using RGB distance\n\t* metrics).\n\t* @see #sortByProximityTo(ReadonlyTColor, DistanceProxy, boolean)\n\t* @param target\n\t*            color\n\t* @param isReversed\n\t*            true, if reverse sorted\n\t* @return sorted list\n\t*/\n\tsortByProximityTo: function(target, proxy, isReversed){\n\t\tif(arguments.length == 2){\n\t\t\ttarget = arguments[0];\n\t\t\tproxy = new RGBDistanceProxy();\n\t\t\tisReversed = arguments[1];\n\t\t}\n\t\treturn this.sortByComparator(new ProximityComparator(target,proxy), isReversed);\n\t},\n\n\ttoARGBArray: function(){\n\t\tvar array = [];\n\t\tthis.each(function(c){\n\t\t\tarray.push(c.toARGB());\n\t\t});\n\t\treturn array;\n\t}\n};\n\n/**\n * Factory method. Creates a new ColorList of colors randomly sampled from\n * the given ARGB image array. If the number of samples equals or exceeds\n * the number of pixels in the source image and no unique colors are\n * required, the function will simply return the same as\n * {@link #ColorList(int[])}.\n * @param pixels\n *            int array of ARGB pixels\n * @param num\n *            number of colors samples (clipped automatically to number of\n *            pixels in the image)\n * @param uniqueOnly\n *            flag if only unique samples are to be taken (doesn't guarantee\n *            unique colors though)\n * @param maxIterations (optional)\n *            max number of attempts to find a unique color. If no more\n *            unique colors can be found the search is terminated.\n * @return new color list of samples\n */\n ColorList.createFromARGBArray = function(pixels, num, uniqueOnly, maxIterations){\n\tmaxIterations = maxIterations || 100;\n\tnum = mathUtils.min(num, pixels.length);\n\tif(!uniqueOnly && num == pixels.length){\n\t\treturn new ColorList(pixels);\n\t}\n\n\tvar colors = [],\n\t\ttemp = TColor.BLACK.copy(),\n\t\ti = 0,\n\t\tisUnique = true,\n\t\tnumTries = 0,\n\t\tidx;\n\tfor(i=0;i<num;i++){\n\t\tif(uniqueOnly){\n\t\t\tisUnique = true;\n\t\t\tnumTries = 0;\n\t\t\tdo {\n\t\t\t\tidx = mathUtils.random(pixels.length);\n\t\t\t\ttemp.setARGB(pixels[idx]);\n\t\t\t\tisUnique = !(colors.indexOf(temp) >= 0);\n\t\t\t} while (!isUnique && ++numTries < maxIterations);\n\t\t\tif(numTries < maxIterations) {\n\t\t\t\tcolors.push(temp.copy());\n\t\t\t} else {\n\t\t\t\tbreak;\n\t\t\t}\n\t\t} else {\n\t\t\tidx = mathUtils.random(pixels.length);\n\t\t\tcolors.push(TColor.newARGB(pixels[idx]));\n\t\t}\n\t}\n\treturn new ColorList(colors);\n };\n\n\nColorList.createUsingStrategy = function(){\n    throw new Error('Not allowed, use toxi/color/createListUsingStrategy instead');\n};\n\nmodule.exports = ColorList;\n\n"]},"metadata":{},"sourceType":"script"}