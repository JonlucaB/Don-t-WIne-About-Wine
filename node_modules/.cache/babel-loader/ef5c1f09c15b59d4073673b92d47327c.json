{"ast":null,"code":"var Vec3D = require('./vectors').Vec3D,\n    Line3D = require('./Line3D'),\n    hasXYZ = require('../internals/has').XYZ,\n    Iterator = require('../internals/Iterator');\n/**\n* construct a LineStrip3D\n* @constructor\n* @param {Vec3D[]} [vertices] optional vertices to start with\n*/\n\n\nvar LineStrip3D = function (vertices) {\n  this.vertices = vertices || [];\n};\n\nLineStrip3D.prototype = {\n  constructor: LineStrip3D,\n\n  /**\n  * add a vector to the line-strip, it will always be a copy\n  * @param {Vec3D | Number } x either a Vec3D or an x coordinate\n  * @param {Number} [y]\n  * @param {Number} [z]\n  * @return itself\n  */\n  add: function (x, y, z) {\n    if (hasXYZ(x)) {\n      //it was 1 param, it was a vector or object\n      this.vertices.push(new Vec3D(x));\n    } else {\n      this.vertices.push(new Vec3D(x, y, z));\n    }\n\n    return this;\n  },\n  get: function (i) {\n    if (i < 0) {\n      i += this.vertices.length;\n    }\n\n    return this.vertices[i];\n  },\n\n  /**\n  * Computes a list of points along the spline which are uniformly separated\n  * by the given step distance.\n  *\n  * @param {Number} step\n  * @param {Boolean} [doAddFinalVertex] true by default\n  * @return {Vec3D[]} point list\n  */\n  getDecimatedVertices: function (step, doAddFinalVertex) {\n    if (doAddFinalVertex !== false) {\n      doAddFinalVertex = true;\n    }\n\n    var uniform = [];\n\n    if (this.vertices.length < 3) {\n      if (this.vertices.length === 2) {\n        new Line3D(this.vertices[0], this.vertices[1]).splitIntoSegments(uniform, step, true);\n\n        if (!doAddFinalVertex) {\n          uniform.pop();\n        }\n      } else {\n        return;\n      }\n    }\n\n    var arcLen = this.getEstimatedArcLength(),\n        delta = step / arcLen,\n        currIdx = 0,\n        currT,\n        t,\n        p,\n        q,\n        frac,\n        i;\n\n    for (t = 0; t < 1.0; t += delta) {\n      currT = t * arcLen;\n\n      while (currT >= this.arcLenIndex[currIdx]) {\n        currIdx++;\n      }\n\n      p = this.get(currIdx - 1);\n      q = this.get(currIdx);\n      frac = (currT - this.arcLenIndex[currIdx - 1]) / (this.arcLenIndex[currIdx] - this.arcLenIndex[currIdx - 1]);\n      i = p.interpolateTo(q, frac);\n      uniform.push(i);\n    }\n\n    if (doAddFinalVertex) {\n      uniform.push(this.get(-1).copy());\n    }\n\n    return uniform;\n  },\n  getEstimatedArcLength: function () {\n    if (this.arcLenIndex === undefined || this.arcLenIndex.length !== this.vertices.length) {\n      this.arcLenIndex = [0];\n    }\n\n    var arcLen = 0,\n        p,\n        q;\n\n    for (var i = 1, l = this.vertices.length; i < l; i++) {\n      p = this.vertices[i - 1];\n      q = this.vertices[i];\n      arcLen += p.distanceTo(q); //this will start at index 1\n\n      this.arcLenIndex[i] = arcLen;\n    }\n\n    return arcLen;\n  },\n  getSegments: function () {\n    var i = 1,\n        num = this.vertices.length,\n        segments = [];\n\n    for (; i < num; i++) {\n      segments.push(new Line3D(this.get(i - 1), this.get(i)));\n    }\n\n    return segments;\n  },\n  getVertices: function () {\n    return vertices;\n  },\n  iterator: function () {\n    return new Iterator(this.vertices);\n  },\n  setVertices: function (vertices) {\n    this.vertices = vertices;\n  }\n};\nmodule.exports = LineStrip3D;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/LineStrip3D.js"],"names":["Vec3D","require","Line3D","hasXYZ","XYZ","Iterator","LineStrip3D","vertices","prototype","constructor","add","x","y","z","push","get","i","length","getDecimatedVertices","step","doAddFinalVertex","uniform","splitIntoSegments","pop","arcLen","getEstimatedArcLength","delta","currIdx","currT","t","p","q","frac","arcLenIndex","interpolateTo","copy","undefined","l","distanceTo","getSegments","num","segments","getVertices","iterator","setVertices","module","exports"],"mappings":"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","sourcesContent":["\n\n\tvar Vec3D = require('./vectors').Vec3D,\n\t\tLine3D = require('./Line3D'),\n\t\thasXYZ = require('../internals/has').XYZ,\n\t\tIterator = require('../internals/Iterator');\n\n\t/**\n\t* construct a LineStrip3D\n\t* @constructor\n\t* @param {Vec3D[]} [vertices] optional vertices to start with\n\t*/\n\tvar LineStrip3D = function( vertices ){\n\t\tthis.vertices = vertices || [];\n\t};\n\n\tLineStrip3D.prototype = {\n\t\tconstructor: LineStrip3D,\n\t\t/**\n\t\t* add a vector to the line-strip, it will always be a copy\n\t\t* @param {Vec3D | Number } x either a Vec3D or an x coordinate\n\t\t* @param {Number} [y]\n\t\t* @param {Number} [z]\n\t\t* @return itself\n\t\t*/\n\t\tadd: function( x, y, z ){\n\t\t\tif( hasXYZ( x ) ){\n\t\t\t\t//it was 1 param, it was a vector or object\n\t\t\t\tthis.vertices.push( new Vec3D(x) );\n\t\t\t} else {\n\t\t\t\tthis.vertices.push( new Vec3D(x,y,z) );\n\t\t\t}\n\t\t\treturn this;\n\t\t},\n\t\tget: function( i ){\n\t\t\tif( i < 0 ){\n\t\t\t\ti += this.vertices.length;\n\t\t\t}\n\t\t\treturn this.vertices[i];\n\t\t},\n\t\t/**\n\t\t* Computes a list of points along the spline which are uniformly separated\n\t\t* by the given step distance.\n\t\t*\n\t\t* @param {Number} step\n\t\t* @param {Boolean} [doAddFinalVertex] true by default\n\t\t* @return {Vec3D[]} point list\n\t\t*/\n\t\tgetDecimatedVertices: function( step, doAddFinalVertex ){\n\t\t\tif( doAddFinalVertex !== false ){\n\t\t\t\tdoAddFinalVertex = true;\n\t\t\t}\n\t\t\tvar uniform = [];\n\t\t\tif( this.vertices.length < 3 ){\n\t\t\t\tif( this.vertices.length === 2 ){\n\t\t\t\t\tnew Line3D( this.vertices[0], this.vertices[1])\n\t\t\t\t\t\t.splitIntoSegments( uniform, step, true );\n\t\t\t\t\tif( !doAddFinalVertex ){\n\t\t\t\t\t\tuniform.pop();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar arcLen = this.getEstimatedArcLength(),\n\t\t\t\tdelta = step / arcLen,\n\t\t\t\tcurrIdx = 0,\n\t\t\t\tcurrT,\n\t\t\t\tt,\n\t\t\t\tp,\n\t\t\t\tq,\n\t\t\t\tfrac,\n\t\t\t\ti;\n\n\t\t\tfor( t = 0; t<1.0; t+=delta ){\n\t\t\t\tcurrT = t * arcLen;\n\t\t\t\twhile( currT >= this.arcLenIndex[currIdx] ){\n\t\t\t\t\tcurrIdx++;\n\t\t\t\t}\n\t\t\t\tp = this.get(currIdx-1);\n\t\t\t\tq = this.get(currIdx);\n\t\t\t\tfrac = ((currT-this.arcLenIndex[currIdx-1]) / (this.arcLenIndex[currIdx] - this.arcLenIndex[currIdx-1]) );\n\t\t\t\ti = p.interpolateTo( q, frac );\n\t\t\t\tuniform.push( i );\n\t\t\t}\n\t\t\tif( doAddFinalVertex ){\n\t\t\t\tuniform.push( this.get(-1).copy() );\n\t\t\t}\n\t\t\treturn uniform;\n\t\t},\n\t\tgetEstimatedArcLength: function(){\n\t\t\tif( this.arcLenIndex === undefined || this.arcLenIndex.length !== this.vertices.length ){\n\t\t\t\tthis.arcLenIndex = [0];\n\t\t\t}\n\t\t\tvar arcLen = 0,\n\t\t\t\tp,\n\t\t\t\tq;\n\t\t\tfor( var i=1, l = this.vertices.length; i<l; i++){\n\t\t\t\tp = this.vertices[i-1];\n\t\t\t\tq = this.vertices[i];\n\t\t\t\tarcLen += p.distanceTo(q);\n\t\t\t\t//this will start at index 1\n\t\t\t\tthis.arcLenIndex[i] = arcLen;\n\t\t\t}\n\t\t\treturn arcLen;\n\t\t},\n\t\tgetSegments: function(){\n\t\t\tvar i = 1,\n\t\t\t\tnum = this.vertices.length,\n\t\t\t\tsegments = [];\n\t\t\tfor( ; i<num; i++ ){\n\t\t\t\tsegments.push( new Line3D(this.get(i-1), this.get(i)) );\n\t\t\t}\n\t\t\treturn segments;\n\t\t},\n\t\tgetVertices: function(){\n\t\t\treturn vertices;\n\t\t},\n\t\titerator: function(){\n\t\t\treturn new Iterator( this.vertices );\n\t\t},\n\t\tsetVertices: function( vertices ){\n\t\t\tthis.vertices = vertices;\n\t\t}\n\t};\n\n\tmodule.exports = LineStrip3D;\n\n"]},"metadata":{},"sourceType":"script"}