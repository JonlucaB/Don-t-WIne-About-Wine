{"ast":null,"code":"//2 modules defined\nvar Sphere, SphereFunction; //Sphere\n\n(function () {\n  var internals = require('../internals');\n\n  var meshCommon = require('./mesh/meshCommon');\n\n  var Vec3D = require('./Vec3D');\n  /**\n   * @module toxi.geom.Sphere\n   * @augments toxi.geom.Vec3D\n   */\n\n\n  Sphere = function (a, b) {\n    if (a === undefined) {\n      Vec3D.apply(this, [new Vec3D()]);\n      this.radius = 1;\n    } else if (internals.has.XYZ(a)) {\n      Vec3D.apply(this, [a]);\n\n      if (internals.is.Sphere(a)) {\n        this.radius = a.radius;\n      } else {\n        this.radius = b;\n      }\n    } else {\n      Vec3D.apply(this, [new Vec3D()]);\n      this.radius = a;\n    }\n  };\n\n  internals.extend(Sphere, Vec3D);\n\n  Sphere.prototype.containsPoint = function (p) {\n    var d = this.sub(p).magSquared();\n    return d <= this.radius * this.radius;\n  };\n  /**\n   * Alternative to {@link SphereIntersectorReflector}. Computes primary &\n   * secondary intersection points of this sphere with the given ray. If no\n   * intersection is found the method returns null. In all other cases, the\n   * returned array will contain the distance to the primary intersection\n   * point (i.e. the closest in the direction of the ray) as its first index\n   * and the other one as its second. If any of distance values is negative,\n   * the intersection point lies in the opposite ray direction (might be\n   * useful to know). To get the actual intersection point coordinates, simply\n   * pass the returned values to {@link Ray3D#getPointAtDistance(float)}.\n   * @param ray\n   * @return 2-element float array of intersection points or null if ray\n   * doesn't intersect sphere at all.\n   */\n\n\n  Sphere.prototype.intersectRay = function (ray) {\n    var result,\n        a,\n        b,\n        t,\n        q = ray.sub(this),\n        distSquared = q.magSquared(),\n        v = -q.dot(ray.getDirection()),\n        d = this.radius * this.radius - (distSquared - v * v);\n\n    if (d >= 0.0) {\n      d = Math.sqrt(d);\n      a = v + d;\n      b = v - d;\n\n      if (!(a < 0 && b < 0)) {\n        if (a > 0 && b > 0) {\n          if (a > b) {\n            t = a;\n            a = b;\n            b = t;\n          }\n        } else {\n          if (b > 0) {\n            t = a;\n            a = b;\n            b = t;\n          }\n        }\n      }\n\n      result = [a, b];\n    }\n\n    return result;\n  };\n  /**\n   * Considers the current vector as centre of a collision sphere with radius\n   * r and checks if the triangle abc intersects with this sphere. The Vec3D p\n   * The point on abc closest to the sphere center is returned via the\n   * supplied result vector argument.\n   * @param t\n   *\t\t\ttriangle to check for intersection\n   * @param result\n   *\t\t\ta non-null vector for storing the result\n   * @return true, if sphere intersects triangle ABC\n   */\n\n\n  Sphere.prototype.intersectSphereTriangle = function (t, result) {\n    // Find Vec3D P on triangle ABC closest to sphere center\n    result.set(t.closestPointOnSurface(this)); // Sphere and triangle intersect if the (squared) distance from sphere\n    // center to Vec3D p is less than the (squared) sphere radius\n\n    var v = result.sub(this);\n    return v.magSquared() <= this.radius * this.radius;\n  };\n  /**\n   * Calculates the normal vector on the sphere in the direction of the\n   * current point.\n   * @param q\n   * @return a unit normal vector to the tangent plane of the ellipsoid in the\n   * point.\n   */\n\n\n  Sphere.prototype.tangentPlaneNormalAt = function (q) {\n    return this.sub(q).normalize();\n  };\n\n  Sphere.prototype.toMesh = function () {\n    //this fn requires SurfaceMeshBuilder, loading it here to avoid circular dependency\n    //var SurfaceMeshBuilder = require('./mesh/SurfaceMeshBuilder');\n    //if one argument is passed it can either be a Number for resolution, or an options object\n    //if 2 parameters are passed it must be a TriangleMesh and then a Number for resolution\n    var opts = {\n      mesh: undefined,\n      resolution: 0\n    };\n\n    if (arguments.length === 1) {\n      if (typeof arguments[0] == 'object') {\n        //options object\n        opts.mesh = arguments[0].mesh;\n        opts.resolution = arguments[0].res || arguments[0].resolution;\n      } else {\n        //it was just the resolution Number\n        opts.resolution = arguments[0];\n      }\n    } else {\n      opts.mesh = arguments[0];\n      opts.resolution = arguments[1];\n    }\n\n    var builder = new meshCommon.SurfaceMeshBuilder(new SphereFunction(this));\n    return builder.createMesh(opts.mesh, opts.resolution, 1);\n  };\n})(); //toxi.geom.mesh.SphereFunction\n\n\n(function (Sphere) {\n  //SphereFunction\n  var mathUtils = require('../math/mathUtils'),\n      Vec3D = require('./Vec3D'),\n      internals = require('../internals');\n  /**\n   * @class This implementation of a {@link SurfaceFunction} samples a given\n   * {@link Sphere} instance when called by the {@link SurfaceMeshBuilder}.\n   * @member toxi\n   */\n\n\n  SphereFunction = function (sphere_or_radius) {\n    if (sphere_or_radius === undefined) {\n      this.sphere = new Sphere(new Vec3D(), 1);\n    }\n\n    if (internals.is.Sphere(sphere_or_radius)) {\n      this.sphere = sphere_or_radius;\n    } else {\n      this.sphere = new Sphere(new Vec3D(), sphere_or_radius);\n    }\n\n    this.phiRange = mathUtils.PI;\n    this.thetaRange = mathUtils.TWO_PI;\n  };\n\n  SphereFunction.prototype = {\n    computeVertexFor: function (p, phi, theta) {\n      phi -= mathUtils.HALF_PI;\n      var cosPhi = mathUtils.cos(phi);\n      var cosTheta = mathUtils.cos(theta);\n      var sinPhi = mathUtils.sin(phi);\n      var sinTheta = mathUtils.sin(theta);\n      var t = mathUtils.sign(cosPhi) * mathUtils.abs(cosPhi);\n      p.x = t * mathUtils.sign(cosTheta) * mathUtils.abs(cosTheta);\n      p.y = mathUtils.sign(sinPhi) * mathUtils.abs(sinPhi);\n      p.z = t * mathUtils.sign(sinTheta) * mathUtils.abs(sinTheta);\n      return p.scaleSelf(this.sphere.radius).addSelf(this.sphere);\n    },\n    getPhiRange: function () {\n      return this.phiRange;\n    },\n    getPhiResolutionLimit: function (res) {\n      return res;\n    },\n    getThetaRange: function () {\n      return this.thetaRange;\n    },\n    getThetaResolutionLimit: function (res) {\n      return res;\n    },\n    setMaxPhi: function (max) {\n      this.phiRange = mathUtils.min(max / 2, mathUtils.PI);\n    },\n    setMaxTheta: function (max) {\n      this.thetaRange = mathUtils.min(max, mathUtils.TWO_PI);\n    }\n  };\n})(Sphere);\n\nSphere.SphereFunction = SphereFunction;\nmodule.exports = Sphere;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/geom/Sphere.js"],"names":["Sphere","SphereFunction","internals","require","meshCommon","Vec3D","a","b","undefined","apply","radius","has","XYZ","is","extend","prototype","containsPoint","p","d","sub","magSquared","intersectRay","ray","result","t","q","distSquared","v","dot","getDirection","Math","sqrt","intersectSphereTriangle","set","closestPointOnSurface","tangentPlaneNormalAt","normalize","toMesh","opts","mesh","resolution","arguments","length","res","builder","SurfaceMeshBuilder","createMesh","mathUtils","sphere_or_radius","sphere","phiRange","PI","thetaRange","TWO_PI","computeVertexFor","phi","theta","HALF_PI","cosPhi","cos","cosTheta","sinPhi","sin","sinTheta","sign","abs","x","y","z","scaleSelf","addSelf","getPhiRange","getPhiResolutionLimit","getThetaRange","getThetaResolutionLimit","setMaxPhi","max","min","setMaxTheta","module","exports"],"mappings":"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","sourcesContent":["\n\n\t//2 modules defined\n\tvar Sphere, SphereFunction;\n\n\t//Sphere\n\t(function(){\n\t\tvar internals = require('../internals');\n\t\tvar meshCommon = require('./mesh/meshCommon');\n\t\tvar Vec3D = require('./Vec3D');\n\t\t/**\n\t\t * @module toxi.geom.Sphere\n\t\t * @augments toxi.geom.Vec3D\n\t\t */\n\t\tSphere = function(a,b){\n\t\t\tif(a === undefined){\n\t\t\t\tVec3D.apply(this,[new Vec3D()]);\n\t\t\t\tthis.radius = 1;\n\t\t\t} else if( internals.has.XYZ( a ) ){\n\t\t\t\tVec3D.apply(this,[a]);\n\t\t\t\tif( internals.is.Sphere( a ) ){\n\t\t\t\t\tthis.radius = a.radius;\n\t\t\t\t} else {\n\t\t\t\t\tthis.radius = b;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tVec3D.apply(this,[new Vec3D()]);\n\t\t\t\tthis.radius = a;\n\t\t\t}\n\t\t};\n\t\tinternals.extend(Sphere,Vec3D);\n\n\t\tSphere.prototype.containsPoint = function(p) {\n\t\t\tvar d = this.sub(p).magSquared();\n\t\t\treturn (d <= this.radius * this.radius);\n\t\t};\n\n\t\t/**\n\t\t * Alternative to {@link SphereIntersectorReflector}. Computes primary &\n\t\t * secondary intersection points of this sphere with the given ray. If no\n\t\t * intersection is found the method returns null. In all other cases, the\n\t\t * returned array will contain the distance to the primary intersection\n\t\t * point (i.e. the closest in the direction of the ray) as its first index\n\t\t * and the other one as its second. If any of distance values is negative,\n\t\t * the intersection point lies in the opposite ray direction (might be\n\t\t * useful to know). To get the actual intersection point coordinates, simply\n\t\t * pass the returned values to {@link Ray3D#getPointAtDistance(float)}.\n\t\t * @param ray\n\t\t * @return 2-element float array of intersection points or null if ray\n\t\t * doesn't intersect sphere at all.\n\t\t */\n\t\tSphere.prototype.intersectRay = function(ray) {\n\t\t\tvar result, a, b, t,\n\t\t\t\tq = ray.sub(this),\n\t\t\t\tdistSquared = q.magSquared(),\n\t\t\t\tv = -q.dot(ray.getDirection()),\n\t\t\t\td = this.radius * this.radius - (distSquared - v * v);\n\t\t\tif (d >= 0.0) {\n\t\t\t\td = Math.sqrt(d);\n\t\t\t\ta = v + d;\n\t\t\t\tb = v - d;\n\t\t\t\tif (!(a < 0 && b < 0)) {\n\t\t\t\t\tif (a > 0 && b > 0) {\n\t\t\t\t\t\tif (a > b) {\n\t\t\t\t\t\t\tt = a;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tb = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\tif (b > 0) {\n\t\t\t\t\t\t\tt = a;\n\t\t\t\t\t\t\ta = b;\n\t\t\t\t\t\t\tb = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tresult = [a,b];\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\t/**\n\t\t * Considers the current vector as centre of a collision sphere with radius\n\t\t * r and checks if the triangle abc intersects with this sphere. The Vec3D p\n\t\t * The point on abc closest to the sphere center is returned via the\n\t\t * supplied result vector argument.\n\t\t * @param t\n\t\t *\t\t\ttriangle to check for intersection\n\t\t * @param result\n\t\t *\t\t\ta non-null vector for storing the result\n\t\t * @return true, if sphere intersects triangle ABC\n\t\t */\n\t\tSphere.prototype.intersectSphereTriangle = function(t,result) {\n\t\t\t// Find Vec3D P on triangle ABC closest to sphere center\n\t\t\tresult.set(t.closestPointOnSurface(this));\n\n\t\t\t// Sphere and triangle intersect if the (squared) distance from sphere\n\t\t\t// center to Vec3D p is less than the (squared) sphere radius\n\t\t\tvar v = result.sub(this);\n\t\t\treturn v.magSquared() <= this.radius * this.radius;\n\t\t};\n\n\t\t/**\n\t\t * Calculates the normal vector on the sphere in the direction of the\n\t\t * current point.\n\t\t * @param q\n\t\t * @return a unit normal vector to the tangent plane of the ellipsoid in the\n\t\t * point.\n\t\t */\n\t\tSphere.prototype.tangentPlaneNormalAt = function(q) {\n\t\t\treturn this.sub(q).normalize();\n\t\t};\n\n\t\tSphere.prototype.toMesh = function() {\n\t\t\t//this fn requires SurfaceMeshBuilder, loading it here to avoid circular dependency\n\t\t\t//var SurfaceMeshBuilder = require('./mesh/SurfaceMeshBuilder');\n\n\t\t\t//if one argument is passed it can either be a Number for resolution, or an options object\n\t\t\t//if 2 parameters are passed it must be a TriangleMesh and then a Number for resolution\n\t\t\tvar opts = {\n\t\t\t\tmesh: undefined,\n\t\t\t\tresolution: 0\n\t\t\t};\n\t\t\tif(arguments.length === 1){\n\t\t\t\tif(typeof(arguments[0]) == 'object'){ //options object\n\t\t\t\t\topts.mesh = arguments[0].mesh;\n\t\t\t\t\topts.resolution = arguments[0].res || arguments[0].resolution;\n\t\t\t\t} else { //it was just the resolution Number\n\t\t\t\t\topts.resolution = arguments[0];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\topts.mesh = arguments[0];\n\t\t\t\topts.resolution = arguments[1];\n\t\t\t}\n\n\t\t\tvar builder = new meshCommon.SurfaceMeshBuilder(new SphereFunction(this));\n\t\t\treturn builder.createMesh(opts.mesh, opts.resolution, 1);\n\t\t};\n\t}());\n\n\n\t//toxi.geom.mesh.SphereFunction\n\t(function( Sphere ){\n\t\t//SphereFunction\n\t\tvar mathUtils = require('../math/mathUtils'),\n\t\t\tVec3D = require('./Vec3D'),\n\t\t\tinternals = require('../internals');\n\n\t\t/**\n\t\t * @class This implementation of a {@link SurfaceFunction} samples a given\n\t\t * {@link Sphere} instance when called by the {@link SurfaceMeshBuilder}.\n\t\t * @member toxi\n\t\t */\n\t\tSphereFunction = function(sphere_or_radius) {\n\t\t\tif(sphere_or_radius === undefined){\n\t\t\t\tthis.sphere = new Sphere(new Vec3D(),1);\n\t\t\t}\n\n\t\t\tif(internals.is.Sphere( sphere_or_radius )){\n\t\t\t\tthis.sphere = sphere_or_radius;\n\t\t\t}\n\t\t\telse{\n\t\t\t\tthis.sphere = new Sphere(new Vec3D(),sphere_or_radius);\n\t\t\t}\n\t\t\tthis.phiRange = mathUtils.PI;\n\t\t\tthis.thetaRange = mathUtils.TWO_PI;\n\t\t};\n\n\t\tSphereFunction.prototype = {\n\t\t\tcomputeVertexFor: function(p,phi,theta) {\n\t\t\t\tphi -= mathUtils.HALF_PI;\n\t\t\t\tvar cosPhi = mathUtils.cos(phi);\n\t\t\t\tvar cosTheta = mathUtils.cos(theta);\n\t\t\t\tvar sinPhi = mathUtils.sin(phi);\n\t\t\t\tvar sinTheta = mathUtils.sin(theta);\n\t\t\t\tvar t = mathUtils.sign(cosPhi) * mathUtils.abs(cosPhi);\n\t\t\t\tp.x = t * mathUtils.sign(cosTheta) * mathUtils.abs(cosTheta);\n\t\t\t\tp.y = mathUtils.sign(sinPhi) * mathUtils.abs(sinPhi);\n\t\t\t\tp.z = t * mathUtils.sign(sinTheta) * mathUtils.abs(sinTheta);\n\t\t\t\treturn p.scaleSelf(this.sphere.radius).addSelf(this.sphere);\n\t\t\t},\n\t\t\tgetPhiRange: function() {\n\t\t\t\treturn this.phiRange;\n\t\t\t},\n\t\t\tgetPhiResolutionLimit: function(res) {\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tgetThetaRange: function() {\n\t\t\t\treturn this.thetaRange;\n\t\t\t},\n\t\t\tgetThetaResolutionLimit: function(res) {\n\t\t\t\treturn res;\n\t\t\t},\n\t\t\tsetMaxPhi: function(max) {\n\t\t\t\tthis.phiRange = mathUtils.min(max / 2, mathUtils.PI);\n\t\t\t},\n\t\t\tsetMaxTheta: function(max) {\n\t\t\t\tthis.thetaRange = mathUtils.min(max, mathUtils.TWO_PI);\n\t\t\t}\n\t\t};\n\t}( Sphere ));\n\n\tSphere.SphereFunction = SphereFunction;\n\tmodule.exports = Sphere;\n\n\n"]},"metadata":{},"sourceType":"script"}