{"ast":null,"code":"var Line2D = require('./Line2D');\n\nvar Polygon2D = require('./Polygon2D');\n\nvar ConvexPolygonClipper = function (polygonBounds) {\n  this.setBounds(polygonBounds);\n};\n\nConvexPolygonClipper.prototype = {\n  constructor: ConvexPolygonClipper,\n  clipPolygon: function (poly) {\n    //make a shallow copy to a new array\n    var points = poly.vertices.slice(0),\n        //hold clipped points\n    clipped,\n        //the boundary edges of the clipping path\n    boundsEdges = this.bounds.getEdges(),\n        //the current Line2D of the edge to clip along\n    clipEdge,\n        i = 0,\n        j = 0,\n        _tmp,\n        //point classification for testing\n    sign,\n        //vectors\n    p,\n        q; //add the first one as a double-entry\n\n\n    points.push(points[0]);\n\n    for (i = 0; i < boundsEdges.length; i++) {\n      clipEdge = boundsEdges[i];\n      clipped = [];\n      sign = clipEdge.classifyPoint(this.boundsCentroid);\n\n      for (j = 0; j < points.length - 1; j++) {\n        p = points[j];\n        q = points[j + 1];\n\n        if (clipEdge.classifyPoint(p) === sign) {\n          if (clipEdge.classifyPoint(q) === sign) {\n            clipped.push(q.copy());\n          } else {\n            clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));\n          }\n\n          continue;\n        }\n\n        if (clipEdge.classifyPoint(q) === sign) {\n          clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));\n          clipped.push(q.copy());\n        }\n      } //if points have been clipped, make sure the last entry is still the same\n      //as the first entry\n\n\n      if (clipped.length > 0 && clipped[0] !== clipped[clipped.length - 1]) {\n        clipped.push(clipped[0]);\n      }\n\n      _tmp = points;\n      points = clipped;\n      clipped = _tmp;\n    }\n\n    return new Polygon2D(points).removeDuplicates(0.001);\n  },\n  getBounds: function () {\n    return this.bounds;\n  },\n  _getClippedPosOnEdge: function (clipEdge, p, q) {\n    return clipEdge.intersectLine(new Line2D(p, q)).getPos();\n  },\n  //unused but included to match, source\n  _isKnownVertex: function (list, q) {\n    for (var i = 0, l = list.length; i < l; i++) {\n      if (list[i].equalsWitTolerance(q, 0.001)) {\n        return true;\n      }\n    }\n\n    return false;\n  },\n  setBounds: function (bounds) {\n    this.bounds = bounds;\n    this.boundsCentroid = this.bounds.getCentroid();\n  }\n};\nmodule.exports = ConvexPolygonClipper;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/ConvexPolygonClipper.js"],"names":["Line2D","require","Polygon2D","ConvexPolygonClipper","polygonBounds","setBounds","prototype","constructor","clipPolygon","poly","points","vertices","slice","clipped","boundsEdges","bounds","getEdges","clipEdge","i","j","_tmp","sign","p","q","push","length","classifyPoint","boundsCentroid","copy","_getClippedPosOnEdge","removeDuplicates","getBounds","intersectLine","getPos","_isKnownVertex","list","l","equalsWitTolerance","getCentroid","module","exports"],"mappings":"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","sourcesContent":["var Line2D = require('./Line2D');\nvar Polygon2D = require('./Polygon2D');\n\n    var ConvexPolygonClipper = function(polygonBounds){\n        this.setBounds(polygonBounds);\n    };\n\n\n    ConvexPolygonClipper.prototype = {\n        constructor: ConvexPolygonClipper,\n\n        clipPolygon: function(poly){\n\n            //make a shallow copy to a new array\n            var points = poly.vertices.slice(0),\n                //hold clipped points\n                clipped,\n                //the boundary edges of the clipping path\n                boundsEdges = this.bounds.getEdges(),\n                //the current Line2D of the edge to clip along\n                clipEdge,\n                i = 0,\n                j = 0,\n                _tmp,\n                //point classification for testing\n                sign,\n                //vectors\n                p,\n                q;\n\n            //add the first one as a double-entry\n            points.push(points[0]);\n\n            for( i = 0; i < boundsEdges.length; i++ ){\n                clipEdge = boundsEdges[i];\n\n                clipped = [];\n\n                sign = clipEdge.classifyPoint(this.boundsCentroid);\n\n                for( j = 0; j < points.length - 1; j++ ){\n                    p = points[j];\n                    q = points[j+1];\n\n                    if( clipEdge.classifyPoint(p) === sign ){\n                        if( clipEdge.classifyPoint(q) === sign ){\n                            clipped.push(q.copy());\n                        } else {\n                            clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));\n                        }\n                        continue;\n                    }\n                    if( clipEdge.classifyPoint(q) === sign ){\n                        clipped.push(this._getClippedPosOnEdge(clipEdge, p, q));\n                        clipped.push(q.copy());\n                    }\n                }\n                //if points have been clipped, make sure the last entry is still the same\n                //as the first entry\n                if( clipped.length > 0 && clipped[0] !== clipped[clipped.length-1] ){\n                    clipped.push(clipped[0]);\n                }\n\n                _tmp = points;\n                points = clipped;\n                clipped = _tmp;\n            }\n\n            return new Polygon2D(points).removeDuplicates(0.001);\n        },\n\n        getBounds: function(){\n            return this.bounds;\n        },\n\n        _getClippedPosOnEdge: function(clipEdge, p, q){\n            return clipEdge.intersectLine(new Line2D(p, q)).getPos();\n        },\n\n        //unused but included to match, source\n        _isKnownVertex: function(list, q){\n            for(var i=0, l=list.length; i<l; i++){\n                if( list[i].equalsWitTolerance(q, 0.001) ){\n                    return true;\n                }\n            }\n            return false;\n        },\n\n        setBounds: function(bounds){\n            this.bounds = bounds;\n            this.boundsCentroid = this.bounds.getCentroid();\n        }\n    };\n\n\n\n    module.exports = ConvexPolygonClipper;\n\n\n\n"]},"metadata":{},"sourceType":"script"}