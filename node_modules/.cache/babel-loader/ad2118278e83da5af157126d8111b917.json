{"ast":null,"code":"var Ray2D = require('./Ray2D'),\n    internals = require('../internals'),\n    mathUtils = require('../math/mathUtils');\n/**\n @class\n @member toxi\n */\n\n\nvar Line2D = function (a, b) {\n  this.a = a;\n  this.b = b;\n};\n\nLine2D.prototype = {\n  constructor: Line2D,\n\n  /**\n   * Computes the dot product of these 2 vectors: line start -> point\n   * and the perpendicular line direction if the result is negative.\n   *\n   * @param {Vec2D} p\n   * @return classifier Number\n   */\n  classifyPoint: function (p) {\n    var normal = this.b.sub(this.a).perpendicular();\n    var d = p.sub(this.a).dot(normal);\n    return mathUtils.sign(d);\n  },\n\n  /**\n     * Computes the closest point on this line to the point given.\n     *\n     * @param {Vec2D} p point to check against\n     * @return closest point on the line\n     */\n  closestPointTo: function (p) {\n    var v = this.b.sub(this.a);\n    var t = p.sub(this.a).dot(v) / v.magSquared(); // Check to see if t is beyond the extents of the line segment\n\n    if (t < 0.0) {\n      return this.a.copy();\n    } else if (t > 1.0) {\n      return this.b.copy();\n    } // Return the point between 'a' and 'b'\n\n\n    return this.a.add(v.scaleSelf(t));\n  },\n  copy: function () {\n    return new Line2D(this.a.copy(), this.b.copy());\n  },\n  distanceToPoint: function (p) {\n    return this.closestPointTo(p).distanceTo(p);\n  },\n  distanceToPointSquared: function (p) {\n    return this.closestPointTo(p).distanceToSquared(p);\n  },\n  equals: function (obj) {\n    if (this == obj) {\n      return true;\n    }\n\n    if (!internals.is.Line2D(obj)) {\n      return false;\n    }\n\n    var l = obj;\n    return (this.a.equals(l.a) || this.a.equals(l.b)) && (this.b.equals(l.b) || this.b.equals(l.a));\n  },\n  getDirection: function () {\n    return this.b.sub(this.a).normalize();\n  },\n  getHeading: function () {\n    return this.b.sub(this.a).heading();\n  },\n  getLength: function () {\n    return this.a.distanceTo(this.b);\n  },\n  getLengthSquared: function () {\n    return this.a.distanceToSquared(this.b);\n  },\n  getMidPoint: function () {\n    return this.a.add(this.b).scaleSelf(0.5);\n  },\n  getNormal: function () {\n    return this.b.sub(this.a).perpendicular();\n  },\n  getTheta: function () {\n    return this.a.angleBetween(this.b, true);\n  },\n  hasEndPoint: function (p) {\n    return this.a.equals(p) || this.b.equals(p);\n  },\n\n  /**\n     * Computes intersection between this and the given line. The returned value\n     * is a {@link LineIntersection} instance and contains both the type of\n     * intersection as well as the intersection point (if existing).\n     *\n     * Based on: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/\n     *\n     * @param l\n     *            line to intersect with\n     * @return intersection result\n     */\n  intersectLine: function (l) {\n    var Type = Line2D.LineIntersection.Type;\n    var isec,\n        denom = (l.b.y - l.a.y) * (this.b.x - this.a.x) - (l.b.x - l.a.x) * (this.b.y - this.a.y),\n        na = (l.b.x - l.a.x) * (this.a.y - l.a.y) - (l.b.y - l.a.y) * (this.a.x - l.a.x),\n        nb = (this.b.x - this.a.x) * (this.a.y - l.a.y) - (this.b.y - this.a.y) * (this.a.x - l.a.x);\n\n    if (denom !== 0) {\n      var ua = na / denom,\n          ub = nb / denom,\n          vecI = this.a.interpolateTo(this.b, ua);\n\n      if (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n        isec = new Line2D.LineIntersection(Type.INTERSECTING, vecI, ua, ub);\n      } else {\n        isec = new Line2D.LineIntersection(Type.NON_INTERSECTING, vecI, ua, ub);\n      }\n    } else {\n      if (na === 0 && nb === 0) {\n        if (this.distanceToPoint(l.a) === 0) {\n          isec = new Line2D.LineIntersection(Type.COINCIDENT, undefined);\n        } else {\n          isec = new Line2D.LineIntersection(Type.COINCIDENT_NO_INTERSECT, undefined);\n        }\n      } else {\n        isec = new Line2D.LineIntersection(Type.PARALLEL, undefined);\n      }\n    }\n\n    return isec;\n  },\n  offsetAndGrowBy: function (offset, scale, ref) {\n    var m = this.getMidPoint();\n    var d = this.getDirection();\n    var n = d.getPerpendicular();\n\n    if (ref !== undefined && m.sub(ref).dot(n) < 0) {\n      n.invert();\n    }\n\n    n.normalizeTo(offset);\n    this.a.addSelf(n);\n    this.b.addSelf(n);\n    d.scaleSelf(scale);\n    this.a.subSelf(d);\n    this.b.addSelf(d);\n    return this;\n  },\n  scale: function (scale) {\n    var delta = (1 - scale) * 0.5;\n    var newA = this.a.interpolateTo(this.b, delta);\n    this.b.interpolateToSelf(this.a, delta);\n    this.a.set(newA);\n    return this;\n  },\n  set: function (a, b) {\n    this.a = a;\n    this.b = b;\n    return this;\n  },\n  splitIntoSegments: function (segments, stepLength, addFirst) {\n    return Line2D.splitIntoSegments(this.a, this.b, stepLength, segments, addFirst);\n  },\n  toRay2D: function () {\n    var Ray2D = require('./Ray2D');\n\n    return new Ray2D(this.a.copy(), this.b.sub(this.a).normalize());\n  }\n};\n/**\n * Splits the line between A and B into segments of the given length,\n * starting at point A. The tweened points are added to the given result\n * list. The last point added is B itself and hence it is likely that the\n * last segment has a shorter length than the step length requested. The\n * first point (A) can be omitted and not be added to the list if so\n * desired.\n *\n * @param a start point\n * @param b end point (always added to results)\n * @param stepLength desired distance between points\n * @param segments existing array list for results (or a new list, if null)\n * @param addFirst false, if A is NOT to be added to results\n * @return list of result vectors\n */\n\nLine2D.splitIntoSegments = function (a, b, stepLength, segments, addFirst) {\n  if (segments === undefined) {\n    segments = [];\n  }\n\n  if (addFirst) {\n    segments.push(a.copy());\n  }\n\n  var dist = a.distanceTo(b);\n\n  if (dist > stepLength) {\n    var pos = a.copy();\n    var step = b.sub(a).limit(stepLength);\n\n    while (dist > stepLength) {\n      pos.addSelf(step);\n      segments.push(pos.copy());\n      dist -= stepLength;\n    }\n  }\n\n  segments.push(b.copy());\n  return segments;\n};\n/**\n * Internal class for LineIntersection\n * @param {Number} type one of the Line2D.LineIntersection.Type\n * @param {Vec2D} pos the intersected point\n * @param {Number} ua coefficient\n * @param {Number} ub coefficient\n */\n\n\nLine2D.LineIntersection = function (type, pos, ua, ub) {\n  this.type = type;\n  this.pos = pos;\n  this.coeff = [ua, ub];\n};\n\nLine2D.LineIntersection.prototype = {\n  getPos: function () {\n    return this.pos ? this.pos.copy() : undefined;\n  },\n  getCoefficients: function () {\n    return this.coeff;\n  },\n  getType: function () {\n    return this.type;\n  },\n  toString: function () {\n    return \"type: \" + this.type + \" pos: \" + this.pos;\n  }\n};\nLine2D.LineIntersection.Type = {\n  COINCIDENT: 0,\n  COINCIDENT_NO_INTERSECT: 4,\n  PARALLEL: 1,\n  NON_INTERSECTING: 2,\n  INTERSECTING: 3\n};\nmodule.exports = Line2D;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/Line2D.js"],"names":["Ray2D","require","internals","mathUtils","Line2D","a","b","prototype","constructor","classifyPoint","p","normal","sub","perpendicular","d","dot","sign","closestPointTo","v","t","magSquared","copy","add","scaleSelf","distanceToPoint","distanceTo","distanceToPointSquared","distanceToSquared","equals","obj","is","l","getDirection","normalize","getHeading","heading","getLength","getLengthSquared","getMidPoint","getNormal","getTheta","angleBetween","hasEndPoint","intersectLine","Type","LineIntersection","isec","denom","y","x","na","nb","ua","ub","vecI","interpolateTo","INTERSECTING","NON_INTERSECTING","COINCIDENT","undefined","COINCIDENT_NO_INTERSECT","PARALLEL","offsetAndGrowBy","offset","scale","ref","m","n","getPerpendicular","invert","normalizeTo","addSelf","subSelf","delta","newA","interpolateToSelf","set","splitIntoSegments","segments","stepLength","addFirst","toRay2D","push","dist","pos","step","limit","type","coeff","getPos","getCoefficients","getType","toString","module","exports"],"mappings":"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","sourcesContent":["\n\nvar\tRay2D = require('./Ray2D'),\n\tinternals = require('../internals'),\n    mathUtils = require('../math/mathUtils');\n\n\n/**\n @class\n @member toxi\n */\nvar Line2D = function( a, b) {\n\tthis.a = a;\n\tthis.b = b;\n};\n\n\nLine2D.prototype = {\n    constructor: Line2D,\n\n    /**\n     * Computes the dot product of these 2 vectors: line start -> point\n     * and the perpendicular line direction if the result is negative.\n     *\n     * @param {Vec2D} p\n     * @return classifier Number\n     */\n    classifyPoint: function(p){\n        var normal = this.b.sub(this.a).perpendicular();\n        var d = p.sub(this.a).dot(normal);\n        return mathUtils.sign(d);\n    },\n\n\t/**\n    * Computes the closest point on this line to the point given.\n    *\n    * @param {Vec2D} p point to check against\n    * @return closest point on the line\n    */\n\tclosestPointTo: function(p) {\n\t\tvar v = this.b.sub(this.a);\n\t\tvar t = p.sub(this.a).dot(v) / v.magSquared();\n\t\t// Check to see if t is beyond the extents of the line segment\n\t\tif (t < 0.0) {\n\t\t\treturn this.a.copy();\n\t\t} else if (t > 1.0) {\n\t\t\treturn this.b.copy();\n\t\t}\n\t\t// Return the point between 'a' and 'b'\n\t\treturn this.a.add(v.scaleSelf(t));\n\t},\n\n\tcopy: function() {\n\t\treturn new Line2D(this.a.copy(), this.b.copy());\n\t},\n\n    distanceToPoint: function(p){\n        return this.closestPointTo(p).distanceTo(p);\n    },\n\n    distanceToPointSquared: function(p){\n        return this.closestPointTo(p).distanceToSquared(p);\n    },\n\n\tequals: function(obj) {\n\t\tif (this == obj) {\n\t\t\treturn true;\n\t\t}\n\t\tif (!( internals.is.Line2D( obj ) ) ) {\n\t\t\treturn false;\n\t\t}\n\t\tvar l = obj;\n\t\treturn (this.a.equals(l.a) || this.a.equals(l.b)) && (this.b.equals(l.b) || this.b.equals(l.a));\n\t},\n\n\tgetDirection: function() {\n\t\treturn this.b.sub(this.a).normalize();\n\t},\n\n    getHeading: function(){\n        return this.b.sub(this.a).heading();\n    },\n\n\tgetLength: function() {\n\t\treturn this.a.distanceTo(this.b);\n\t},\n\n\tgetLengthSquared: function() {\n\t\treturn this.a.distanceToSquared(this.b);\n\t},\n\n\tgetMidPoint: function() {\n\t\treturn this.a.add(this.b).scaleSelf(0.5);\n\t},\n\n\tgetNormal: function() {\n\t\treturn this.b.sub(this.a).perpendicular();\n\t},\n\n\tgetTheta: function() {\n\t\treturn this.a.angleBetween(this.b, true);\n\t},\n\n\thasEndPoint: function(p) {\n\t\treturn this.a.equals(p) || this.b.equals(p);\n\t},\n\n\t/**\n    * Computes intersection between this and the given line. The returned value\n    * is a {@link LineIntersection} instance and contains both the type of\n    * intersection as well as the intersection point (if existing).\n    *\n    * Based on: http://local.wasp.uwa.edu.au/~pbourke/geometry/lineline2d/\n    *\n    * @param l\n    *            line to intersect with\n    * @return intersection result\n    */\n\tintersectLine: function(l) {\n\n        var Type = Line2D.LineIntersection.Type;\n\n\t\tvar isec,\n\t\t\tdenom = (l.b.y - l.a.y) * (this.b.x - this.a.x) - (l.b.x - l.a.x) * (this.b.y - this.a.y),\n\t\t\tna = (l.b.x - l.a.x) * (this.a.y - l.a.y) - (l.b.y - l.a.y) * (this.a.x - l.a.x),\n\t\t\tnb = (this.b.x - this.a.x) * (this.a.y - l.a.y) - (this.b.y - this.a.y) * (this.a.x - l.a.x);\n\t\tif (denom !== 0) {\n\t\t\tvar ua = na / denom,\n\t\t\t\tub = nb / denom,\n                vecI = this.a.interpolateTo(this.b, ua);\n\n\t\t\tif (ua >= 0.0 && ua <= 1.0 && ub >= 0.0 && ub <= 1.0) {\n\t\t\t\tisec =new Line2D.LineIntersection(Type.INTERSECTING, vecI, ua, ub);\n\t\t\t} else {\n\t\t\t\tisec = new Line2D.LineIntersection(Type.NON_INTERSECTING, vecI, ua, ub);\n\t\t\t}\n\t\t} else {\n\t\t\tif (na === 0 && nb === 0) {\n                if( this.distanceToPoint(l.a) === 0) {\n                    isec = new Line2D.LineIntersection(Type.COINCIDENT, undefined);\n                } else {\n                    isec = new Line2D.LineIntersection(Type.COINCIDENT_NO_INTERSECT, undefined);\n                }\n\t\t\t} else {\n\t\t\t\tisec = new Line2D.LineIntersection(Type.PARALLEL, undefined);\n\t\t\t}\n\t\t}\n\t\treturn isec;\n\t},\n\n\toffsetAndGrowBy: function(offset,scale, ref) {\n\t\tvar m = this.getMidPoint();\n\t\tvar d = this.getDirection();\n\t\tvar n = d.getPerpendicular();\n\t\tif (ref !== undefined && m.sub(ref).dot(n) < 0) {\n\t\t\tn.invert();\n\t\t}\n\t\tn.normalizeTo(offset);\n\t\tthis.a.addSelf(n);\n\t\tthis.b.addSelf(n);\n\t\td.scaleSelf(scale);\n\t\tthis.a.subSelf(d);\n\t\tthis.b.addSelf(d);\n\t\treturn this;\n\t},\n\n\tscale: function(scale) {\n\t\tvar delta = (1 - scale) * 0.5;\n\t\tvar newA = this.a.interpolateTo(this.b, delta);\n\t\tthis.b.interpolateToSelf(this.a, delta);\n\t\tthis.a.set(newA);\n\t\treturn this;\n\t},\n\n\tset: function(a, b) {\n\t\tthis.a = a;\n\t\tthis.b = b;\n\t\treturn this;\n\t},\n\n\tsplitIntoSegments: function(segments,stepLength,addFirst) {\n\t\treturn Line2D.splitIntoSegments(this.a, this.b, stepLength, segments, addFirst);\n\t},\n\n\ttoRay2D: function() {\n        var Ray2D = require('./Ray2D');\n\t\treturn new Ray2D(this.a.copy(), this.b.sub(this.a).normalize());\n\t}\n};\n\n\n\n/**\n * Splits the line between A and B into segments of the given length,\n * starting at point A. The tweened points are added to the given result\n * list. The last point added is B itself and hence it is likely that the\n * last segment has a shorter length than the step length requested. The\n * first point (A) can be omitted and not be added to the list if so\n * desired.\n *\n * @param a start point\n * @param b end point (always added to results)\n * @param stepLength desired distance between points\n * @param segments existing array list for results (or a new list, if null)\n * @param addFirst false, if A is NOT to be added to results\n * @return list of result vectors\n */\nLine2D.splitIntoSegments = function(a, b, stepLength, segments, addFirst) {\n\tif (segments === undefined) {\n\t\tsegments = [];\n\t}\n\tif (addFirst) {\n\t\tsegments.push(a.copy());\n\t}\n\tvar dist = a.distanceTo(b);\n\tif (dist > stepLength) {\n\t\tvar pos = a.copy();\n\t\tvar step = b.sub(a).limit(stepLength);\n\t\twhile (dist > stepLength) {\n\t\t\tpos.addSelf(step);\n\t\t\tsegments.push(pos.copy());\n\t\t\tdist -= stepLength;\n\t\t}\n\t}\n\tsegments.push(b.copy());\n\treturn segments;\n};\n\n\n/**\n * Internal class for LineIntersection\n * @param {Number} type one of the Line2D.LineIntersection.Type\n * @param {Vec2D} pos the intersected point\n * @param {Number} ua coefficient\n * @param {Number} ub coefficient\n */\nLine2D.LineIntersection = function(type, pos, ua, ub) {\n\tthis.type = type;\n\tthis.pos = pos;\n    this.coeff = [ua, ub];\n};\n\nLine2D.LineIntersection.prototype = {\n\tgetPos: function(){\n\t\treturn this.pos ? this.pos.copy() : undefined;\n\t},\n\n    getCoefficients: function(){\n        return this.coeff;\n    },\n\n\tgetType: function(){\n\t\treturn this.type;\n\t},\n\n\ttoString: function(){\n\t\treturn \"type: \"+this.type+ \" pos: \"+this.pos;\n\t}\n};\n\nLine2D.LineIntersection.Type = {\n    COINCIDENT: 0,\n\tCOINCIDENT_NO_INTERSECT: 4,\n    PARALLEL: 1,\n    NON_INTERSECTING: 2,\n\tINTERSECTING: 3,\n};\n\n\nmodule.exports = Line2D;\n\n"]},"metadata":{},"sourceType":"script"}