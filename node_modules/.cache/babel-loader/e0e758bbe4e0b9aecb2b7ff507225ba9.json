{"ast":null,"code":"var mathUtils = require('../../math/mathUtils');\n/**\n * construct a new `FloatRange`\n * provides utilities for dealing with a range of Numbers.\n * @param {Number} [min=0] the minimum in the range\n * @param {Number} [max=1.0] the maximum in the range\n * @constructor\n */\n\n\nvar FloatRange = function (min, max) {\n  min = min || 0.0;\n  max = typeof max === 'number' ? max : 1.0; // swap if necessary\n\n  if (min > max) {\n    var t = max;\n    max = min;\n    min = t;\n  }\n\n  this.min = min;\n  this.max = max;\n  this.currValue = min;\n};\n\nFloatRange.prototype = {\n  adjustCurrentBy: function (val) {\n    return this.setCurrent(this.currValue + val);\n  },\n  copy: function () {\n    var range = new FloatRange(this.min, this.max);\n    range.currValue = this.currValue;\n    return range;\n  },\n\n  /**\n   * Returns the value at the normalized position <code>(0.0 = min ... 1.0 =\n   * max-EPS)</code> within the range. Since the max value is exclusive, the\n   * value returned for position 1.0 is the range max value minus\n   * {@link MathUtils#EPS}. Also note the given position is not being clipped\n   * to the 0.0-1.0 interval, so when passing in values outside that interval\n   * will produce out-of-range values too.\n   * @param {Number} perc\n   * @return {Number} value within the range\n   */\n  getAt: function (perc) {\n    return this.min + (this.max - this.min - mathUtils.EPS) * perc;\n  },\n  getCurrent: function () {\n    return this.currValue;\n  },\n  getMedian: function () {\n    return (this.min + this.max) * 0.5;\n  },\n  getRange: function () {\n    return this.max - this.min;\n  },\n  isValueInRange: function (val) {\n    return val >= this.min && val <= this.max;\n  },\n  pickRandom: function () {\n    this.currValue = mathUtils.random(this.min, this.max);\n    return this.currValue;\n  },\n  setCurrent: function (val) {\n    this.currValue = mathUtils.clip(val, this.min, this.max);\n    return this.currValue;\n  },\n\n  /*\n  seed: function(seed){\n  \tthrow new Error(\"Not yet Implemented\");\n  },\n  setRandom: function(rnd){\n  \t\n  }\n  */\n  toArray: function (step) {\n    var range = [],\n        v = this.min;\n\n    while (v < this.max) {\n      range.push(v);\n      v += step;\n    }\n\n    return range;\n  },\n  toString: function () {\n    return \"FloatRange: \" + this.min + \" -> \" + this.max;\n  }\n};\nmodule.exports = FloatRange;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/util/datatypes/FloatRange.js"],"names":["mathUtils","require","FloatRange","min","max","t","currValue","prototype","adjustCurrentBy","val","setCurrent","copy","range","getAt","perc","EPS","getCurrent","getMedian","getRange","isValueInRange","pickRandom","random","clip","toArray","step","v","push","toString","module","exports"],"mappings":"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","sourcesContent":["\n\nvar mathUtils = require('../../math/mathUtils');\n\n/**\n * construct a new `FloatRange`\n * provides utilities for dealing with a range of Numbers.\n * @param {Number} [min=0] the minimum in the range\n * @param {Number} [max=1.0] the maximum in the range\n * @constructor\n */\nvar FloatRange = function(min, max){\n\tmin = min || 0.0;\n\tmax = typeof max === 'number' ? max : 1.0;\n\t// swap if necessary\n\tif(min > max){\n\t\tvar t= max;\n\t\tmax = min;\n\t\tmin = t;\n\t}\n\tthis.min = min;\n\tthis.max = max;\n\tthis.currValue = min;\n};\n\nFloatRange.prototype = {\n\tadjustCurrentBy: function(val){\n\t\treturn this.setCurrent(this.currValue + val);\n\t},\n\tcopy: function(){\n\t\tvar range = new FloatRange(this.min,this.max);\n\t\trange.currValue = this.currValue;\n\t\treturn range;\n\t},\n    /**\n     * Returns the value at the normalized position <code>(0.0 = min ... 1.0 =\n     * max-EPS)</code> within the range. Since the max value is exclusive, the\n     * value returned for position 1.0 is the range max value minus\n     * {@link MathUtils#EPS}. Also note the given position is not being clipped\n     * to the 0.0-1.0 interval, so when passing in values outside that interval\n     * will produce out-of-range values too.\n     * @param {Number} perc\n     * @return {Number} value within the range\n     */\n\tgetAt: function(perc){\n\t\treturn this.min + (this.max - this.min - mathUtils.EPS) * perc;\n\t},\n\tgetCurrent: function(){\n\t\treturn this.currValue;\n\t},\n\tgetMedian: function(){\n\t\treturn (this.min + this.max) * 0.5;\n\t},\n\tgetRange: function(){\n\t\treturn this.max - this.min;\n\t},\n\tisValueInRange: function(val){\n\t\treturn val >= this.min && val <= this.max;\n\t},\n\tpickRandom: function(){\n\t\tthis.currValue = mathUtils.random(this.min,this.max);\n\t\treturn this.currValue;\n\t},\n    setCurrent: function( val ){\n        this.currValue = mathUtils.clip( val, this.min, this.max );\n        return this.currValue;\n    },\n\t/*\n\tseed: function(seed){\n\t\tthrow new Error(\"Not yet Implemented\");\n\t},\n\tsetRandom: function(rnd){\n\t\t\n\t}\n\t*/\n\ttoArray: function(step){\n\t\tvar range = [],\n\t\t\tv = this.min;\n\t\twhile(v < this.max){\n\t\t\trange.push(v);\n\t\t\tv += step;\n\t\t}\n\t\treturn range;\n\t},\n\ttoString: function(){\n\t\treturn \"FloatRange: \" + this.min + \" -> \" + this.max;\n\t}\n};\n\nmodule.exports = FloatRange;\n\n"]},"metadata":{},"sourceType":"script"}