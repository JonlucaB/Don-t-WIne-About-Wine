{"ast":null,"code":"var extend = require('../../internals').extend,\n    AbstractWave = require('./AbstractWave');\n/**\n * @module toxi/math/waves/AMFMSineWave\n * @augments toxi/math/waves/AbstractWave\n */\n\n\nvar AMFMSineWave = function (a, b, c, d, e) {\n  if (typeof c == \"number\") {\n    AbstractWave.call(this, a, b, 1, c);\n    this.amod = d;\n    this.fmod = e;\n  } else {\n    AbstractWave.call(this, a, b);\n    this.amod = c;\n    this.fmod = d;\n  }\n};\n\nextend(AMFMSineWave, AbstractWave);\n\nAMFMSineWave.prototype.getClass = function () {\n  return \"AMFMSineWave\";\n};\n\nAMFMSineWave.prototype.pop = function () {\n  this.parent.pop.call(this);\n  this.amod.pop();\n  this.fmod.pop();\n};\n\nAMFMSineWave.prototype.push = function () {\n  this.parent.push.call(this);\n  this.amod.push();\n  this.fmod.push();\n};\n/**\n * Resets this wave and its modulating waves as well.\n *\n * @see toxi.math.waves.AbstractWave#reset()\n */\n\n\nAMFMSineWave.prototype.reset = function () {\n  this.parent.reset.call(this);\n  this.fmod.reset();\n  this.amod.reset();\n};\n/**\n * @class Progresses the wave and updates the result value. You must NEVER call the\n * update() method on the 2 modulating wave since this is handled\n * automatically by this method.\n  * @augments AbstractWave\n * @member toxi\n * @see toxi.math.waves.AbstractWave#update()\n */\n\n\nAMFMSineWave.prototype.update = function () {\n  this.amp = this.amod.update();\n  this.value = this.amp * Math.sin(this.phase) + this.offset;\n  this.cyclePhase(this.frequency + this.fmod.update());\n  return this.value;\n};\n\nmodule.exports = AMFMSineWave;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/math/waves/AMFMSineWave.js"],"names":["extend","require","AbstractWave","AMFMSineWave","a","b","c","d","e","call","amod","fmod","prototype","getClass","pop","parent","push","reset","update","amp","value","Math","sin","phase","offset","cyclePhase","frequency","module","exports"],"mappings":"AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,iBAAD,CAAP,CAA2BD,MAAxC;AAAA,IACCE,YAAY,GAAGD,OAAO,CAAC,gBAAD,CADvB;AAGA;AACA;AACA;AACA;;;AACA,IAAIE,YAAY,GAAG,UAASC,CAAT,EAAWC,CAAX,EAAaC,CAAb,EAAeC,CAAf,EAAiBC,CAAjB,EAAmB;AACrC,MAAG,OAAOF,CAAP,IAAY,QAAf,EAAwB;AACvBJ,IAAAA,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAuBL,CAAvB,EAAyBC,CAAzB,EAA2B,CAA3B,EAA6BC,CAA7B;AACA,SAAKI,IAAL,GAAYH,CAAZ;AACA,SAAKI,IAAL,GAAYH,CAAZ;AACA,GAJD,MAIM;AACLN,IAAAA,YAAY,CAACO,IAAb,CAAkB,IAAlB,EAAuBL,CAAvB,EAAyBC,CAAzB;AACA,SAAKK,IAAL,GAAYJ,CAAZ;AACA,SAAKK,IAAL,GAAYJ,CAAZ;AACA;AACD,CAVD;;AAYAP,MAAM,CAACG,YAAD,EAAcD,YAAd,CAAN;;AAEAC,YAAY,CAACS,SAAb,CAAuBC,QAAvB,GAAkC,YAAU;AAC3C,SAAO,cAAP;AACA,CAFD;;AAIAV,YAAY,CAACS,SAAb,CAAuBE,GAAvB,GAA6B,YAAU;AACtC,OAAKC,MAAL,CAAYD,GAAZ,CAAgBL,IAAhB,CAAqB,IAArB;AACA,OAAKC,IAAL,CAAUI,GAAV;AACA,OAAKH,IAAL,CAAUG,GAAV;AACA,CAJD;;AAMAX,YAAY,CAACS,SAAb,CAAuBI,IAAvB,GAA8B,YAAW;AACrC,OAAKD,MAAL,CAAYC,IAAZ,CAAiBP,IAAjB,CAAsB,IAAtB;AACA,OAAKC,IAAL,CAAUM,IAAV;AACA,OAAKL,IAAL,CAAUK,IAAV;AACH,CAJD;AAMA;AACA;AACA;AACA;AACA;;;AACAb,YAAY,CAACS,SAAb,CAAuBK,KAAvB,GAA+B,YAAU;AACxC,OAAKF,MAAL,CAAYE,KAAZ,CAAkBR,IAAlB,CAAuB,IAAvB;AACA,OAAKE,IAAL,CAAUM,KAAV;AACA,OAAKP,IAAL,CAAUO,KAAV;AACA,CAJD;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAd,YAAY,CAACS,SAAb,CAAuBM,MAAvB,GAAgC,YAAW;AACvC,OAAKC,GAAL,GAAW,KAAKT,IAAL,CAAUQ,MAAV,EAAX;AACA,OAAKE,KAAL,GAAa,KAAKD,GAAL,GAAWE,IAAI,CAACC,GAAL,CAAS,KAAKC,KAAd,CAAX,GAAkC,KAAKC,MAApD;AACA,OAAKC,UAAL,CAAgB,KAAKC,SAAL,GAAiB,KAAKf,IAAL,CAAUO,MAAV,EAAjC;AACA,SAAO,KAAKE,KAAZ;AACH,CALD;;AAOAO,MAAM,CAACC,OAAP,GAAiBzB,YAAjB","sourcesContent":["\n\nvar extend = require('../../internals').extend,\n\tAbstractWave = require('./AbstractWave');\n\n/**\n * @module toxi/math/waves/AMFMSineWave\n * @augments toxi/math/waves/AbstractWave\n */\nvar\tAMFMSineWave = function(a,b,c,d,e){\n\tif(typeof c == \"number\"){\n\t\tAbstractWave.call(this,a,b,1,c);\n\t\tthis.amod = d;\n\t\tthis.fmod = e;\n\t} else{\n\t\tAbstractWave.call(this,a,b);\n\t\tthis.amod = c;\n\t\tthis.fmod = d;\n\t}\n};\n\nextend(AMFMSineWave,AbstractWave);\n\nAMFMSineWave.prototype.getClass = function(){\n\treturn \"AMFMSineWave\";\n};\n\nAMFMSineWave.prototype.pop = function(){\n\tthis.parent.pop.call(this);\n\tthis.amod.pop();\n\tthis.fmod.pop();\n};\n\nAMFMSineWave.prototype.push = function() {\n    this.parent.push.call(this);\n    this.amod.push();\n    this.fmod.push();\n};\n\n/**\n * Resets this wave and its modulating waves as well.\n *\n * @see toxi.math.waves.AbstractWave#reset()\n */\nAMFMSineWave.prototype.reset = function(){\n\tthis.parent.reset.call(this);\n\tthis.fmod.reset();\n\tthis.amod.reset();\n};\n\n/**\n * @class Progresses the wave and updates the result value. You must NEVER call the\n * update() method on the 2 modulating wave since this is handled\n * automatically by this method.\n  * @augments AbstractWave\n * @member toxi\n * @see toxi.math.waves.AbstractWave#update()\n */\nAMFMSineWave.prototype.update = function() {\n    this.amp = this.amod.update();\n    this.value = this.amp * Math.sin(this.phase) + this.offset;\n    this.cyclePhase(this.frequency + this.fmod.update());\n    return this.value;\n};\n\nmodule.exports = AMFMSineWave;\n\n\n"]},"metadata":{},"sourceType":"script"}