{"ast":null,"code":"var extend = require('../internals').extend,\n    mathUtils = require('../math/mathUtils'),\n    Ray3D = require('./Ray3D'),\n    vectors = require('./vectors'),\n    Vec3D = vectors.Vec3D,\n    Vec2D = vectors.Vec2D,\n    TriangleMesh = require('./mesh/TriangleMesh');\n/**\n* @class\n* @member toxi\n* @augments Vec3D\n*/\n\n\nvar Plane = function (tri_or_origin, norm) {\n  var origin, normal;\n\n  if (arguments.length === 0) {\n    origin = new Vec3D();\n    normal = Vec3D.Y_AXIS.copy();\n  } else if (arguments.length == 1) {\n    //it should've been a Triangle\n    origin = arguments[0].computeCentroid();\n    normal = arguments[0].computeNormal();\n  } else {\n    //Vec3D, Vec3D\n    origin = arguments[0];\n    normal = arguments[1].getNormalized();\n  }\n\n  Vec3D.apply(this, [origin]);\n  this.normal = normal;\n};\n\nextend(Plane, Vec3D);\nPlane.Classifier = {\n  FRONT: \"front\",\n  BACK: \"back\",\n  ON_PLANE: \"on plane\"\n};\nPlane.XY = new Plane(new Vec3D(), Vec3D.Z_AXIS);\nPlane.XZ = new Plane(new Vec3D(), Vec3D.Y_AXIS);\nPlane.YZ = new Plane(new Vec3D(), Vec3D.X_AXIS);\n/**\n* Classifies the relative position of the given point to the plane using\n* the given tolerance.\n* @return One of the 3 classification types: FRONT, BACK, ON_PLANE\n*/\n\nPlane.prototype.classifyPoint = function (p, tolerance) {\n  var d = this.sub(p).normalize().dot(this.normal);\n\n  if (d < -tolerance) {\n    return Plane.Classifier.FRONT;\n  } else if (d > tolerance) {\n    return Plane.Classifier.BACK;\n  }\n\n  return Plane.Classifier.ON_PLANE;\n};\n\nPlane.prototype.containsPoint = function (p) {\n  return this.classifyPoint(p, mathUtils.EPS) == Plane.Classifier.ON_PLANE;\n};\n\nPlane.prototype.getDistanceToPoint = function (p) {\n  var sn = this.normal.dot(p.sub(this)),\n      sd = this.normal.magSquared(),\n      isec = p.add(this.normal.scale(sn / sd));\n  return isec.distanceTo(p);\n};\n\nPlane.prototype.getIntersectionWithRay = function (r) {\n  var denom = this.normal.dot(r.getDirection()),\n      u;\n\n  if (denom > mathUtils.EPS) {\n    u = this.normal.dot(this.sub(r)) / denom;\n    return r.getPointAtDistance(u);\n  } else {\n    return undefined;\n  }\n};\n\nPlane.prototype.getProjectedPoint = function (p) {\n  var dir, proj;\n\n  if (this.normal.dot(this.sub(p)) < 0) {\n    dir = this.normal.getInverted();\n  } else {\n    dir = this.normal;\n  }\n\n  proj = new Ray3D(p, dir).getPointAtDistance(this.getDistanceToPoint(p));\n  return proj;\n};\n/**\n* Calculates the distance of the vector to the given plane in the specified\n* direction. A plane is specified by a 3D point and a normal vector\n* perpendicular to the plane. Normalized directional vectors expected (for\n* rayDir and planeNormal).\n*\n* @param {Ray3D} ray intersection ray\n* @return {Number} distance to plane in world units, -1 if no intersection.\n*/\n\n\nPlane.prototype.intersectRayDistance = function (ray) {\n  var d = this.normal.dot(this),\n      numer = this.normal.dot(ray) + d,\n      denom = this.normal.dot(ray.dir); //normal is orthogonal to vector, cant intersect\n\n  if (mathUtils.abs(denom) < mathUtils.EPS) {\n    return -1;\n  }\n\n  return -(numer / denom);\n};\n/**\n* Creates a TriangleMesh representation of the plane as a finite, squared\n* quad of the requested size, centred around the current plane point.\n* @param {TriangleMesh} mesh (optional)\n* @param size desired edge length\n* @return mesh\n*/\n\n\nPlane.prototype.toMesh = function (mesh, size) {\n  if (arguments.length === 1 && typeof arguments[0] == 'number') {\n    size = mesh;\n    mesh = null;\n  }\n\n  mesh = mesh || new TriangleMesh(\"plane\", 4, 2);\n  var p = this.equalsWithTolerance(Vec3D.ZERO, 0.01) ? this.add(0.01, 0.01, 0.01) : this;\n  size *= 0.5;\n  var n = p.cross(this.normal).normalizeTo(size),\n      m = n.cross(this.normal).normalizeTo(size),\n      a = this.add(n).addSelf(m),\n      b = this.add(n).subSelf(m),\n      c = this.sub(n).subSelf(m),\n      d = this.sub(n).addSelf(m);\n  mesh.addFace(a, d, b, undefined, undefined, undefined, undefined);\n  mesh.addFace(b, d, c, undefined, undefined, undefined, undefined);\n  return mesh;\n};\n\nmodule.exports = Plane;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/Plane.js"],"names":["extend","require","mathUtils","Ray3D","vectors","Vec3D","Vec2D","TriangleMesh","Plane","tri_or_origin","norm","origin","normal","arguments","length","Y_AXIS","copy","computeCentroid","computeNormal","getNormalized","apply","Classifier","FRONT","BACK","ON_PLANE","XY","Z_AXIS","XZ","YZ","X_AXIS","prototype","classifyPoint","p","tolerance","d","sub","normalize","dot","containsPoint","EPS","getDistanceToPoint","sn","sd","magSquared","isec","add","scale","distanceTo","getIntersectionWithRay","r","denom","getDirection","u","getPointAtDistance","undefined","getProjectedPoint","dir","proj","getInverted","intersectRayDistance","ray","numer","abs","toMesh","mesh","size","equalsWithTolerance","ZERO","n","cross","normalizeTo","m","a","addSelf","b","subSelf","c","addFace","module","exports"],"mappings":"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","sourcesContent":["\n\n    var extend = require('../internals').extend,\n        mathUtils = require('../math/mathUtils'),\n        Ray3D = require('./Ray3D'),\n        vectors = require('./vectors'),\n        Vec3D = vectors.Vec3D,\n        Vec2D = vectors.Vec2D,\n        TriangleMesh = require('./mesh/TriangleMesh');\n\n    /**\n    * @class\n    * @member toxi\n    * @augments Vec3D\n    */\n    var\tPlane = function(tri_or_origin,norm) {\n        var origin, normal;\n        if(arguments.length === 0){\n            origin = new Vec3D();\n            normal = Vec3D.Y_AXIS.copy();\n        } else if(arguments.length == 1){ //it should've been a Triangle\n            origin = arguments[0].computeCentroid();\n            normal = arguments[0].computeNormal();\n        } else { //Vec3D, Vec3D\n            origin = arguments[0];\n            normal = arguments[1].getNormalized();\n        }\n        Vec3D.apply(this,[origin]);\n        this.normal = normal;\n    };\n    extend(Plane,Vec3D);\n    Plane.Classifier = {\n        FRONT: \"front\",\n        BACK: \"back\",\n        ON_PLANE: \"on plane\"\n    };\n    Plane.XY = new Plane(new Vec3D(), Vec3D.Z_AXIS);\n    Plane.XZ = new Plane(new Vec3D(), Vec3D.Y_AXIS);\n    Plane.YZ = new Plane(new Vec3D(), Vec3D.X_AXIS);\n\n\n    /**\n    * Classifies the relative position of the given point to the plane using\n    * the given tolerance.\n    * @return One of the 3 classification types: FRONT, BACK, ON_PLANE\n    */\n    Plane.prototype.classifyPoint = function(p, tolerance){\n        var d = this.sub(p).normalize().dot(this.normal);\n        if( d < -tolerance){\n            return Plane.Classifier.FRONT;\n        } else if( d > tolerance){\n            return Plane.Classifier.BACK;\n        }\n        return Plane.Classifier.ON_PLANE;\n    };\n\n    Plane.prototype.containsPoint = function(p){\n        return this.classifyPoint(p, mathUtils.EPS) == Plane.Classifier.ON_PLANE;\n    };\n\n    Plane.prototype.getDistanceToPoint = function(p){\n        var sn = this.normal.dot(p.sub(this)),\n            sd = this.normal.magSquared(),\n            isec = p.add(this.normal.scale(sn / sd));\n            return isec.distanceTo(p);\n    };\n\n    Plane.prototype.getIntersectionWithRay = function(r){\n        var denom = this.normal.dot(r.getDirection()),\n            u;\n        if(denom > mathUtils.EPS){\n            u = this.normal.dot(this.sub(r)) / denom;\n            return r.getPointAtDistance(u);\n        } else {\n            return undefined;\n        }\n    };\n\n    Plane.prototype.getProjectedPoint = function(p){\n        var dir, proj;\n        if(this.normal.dot(this.sub(p)) < 0){\n            dir = this.normal.getInverted();\n        } else {\n            dir = this.normal;\n        }\n        proj = new Ray3D(p,dir).getPointAtDistance(this.getDistanceToPoint(p));\n        return proj;\n    };\n    /**\n    * Calculates the distance of the vector to the given plane in the specified\n    * direction. A plane is specified by a 3D point and a normal vector\n    * perpendicular to the plane. Normalized directional vectors expected (for\n    * rayDir and planeNormal).\n    *\n    * @param {Ray3D} ray intersection ray\n    * @return {Number} distance to plane in world units, -1 if no intersection.\n    */\n\n    Plane.prototype.intersectRayDistance = function(ray){\n        var d = this.normal.dot(this),\n            numer = this.normal.dot(ray) + d,\n            denom = this.normal.dot(ray.dir);\n\n            //normal is orthogonal to vector, cant intersect\n            if(mathUtils.abs(denom) < mathUtils.EPS){\n                return -1;\n            }\n            return - (numer / denom);\n    };\n\n    /**\n    * Creates a TriangleMesh representation of the plane as a finite, squared\n    * quad of the requested size, centred around the current plane point.\n    * @param {TriangleMesh} mesh (optional)\n    * @param size desired edge length\n    * @return mesh\n    */\n    Plane.prototype.toMesh = function( mesh, size ){\n        if( arguments.length === 1 && typeof arguments[0] == 'number' ){\n            size = mesh;\n            mesh = null;\n        }\n        mesh = mesh || new TriangleMesh(\"plane\", 4, 2);\n        var p = this.equalsWithTolerance(Vec3D.ZERO, 0.01) ? this.add(0.01, 0.01, 0.01) : this;\n        size *= 0.5;\n        var n = p.cross(this.normal).normalizeTo(size),\n            m = n.cross(this.normal).normalizeTo(size),\n            a = this.add(n).addSelf(m),\n            b = this.add(n).subSelf(m),\n            c = this.sub(n).subSelf(m),\n            d = this.sub(n).addSelf(m);\n\n        mesh.addFace(a, d, b, undefined, undefined, undefined, undefined);\n        mesh.addFace(b, d, c, undefined, undefined, undefined, undefined);\n        return mesh;\n    };\n\n\n    module.exports = Plane;\n\n\n\n"]},"metadata":{},"sourceType":"script"}