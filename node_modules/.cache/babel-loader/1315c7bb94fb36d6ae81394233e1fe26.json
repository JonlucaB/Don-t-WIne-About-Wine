{"ast":null,"code":"var ArraySet = require('./ArraySet'); //wrap connections in this before passing them out\n//this way the rest of the lib can treat it like a Java Collection\n\n/*var __NodeCollection = function(nodes){\n\tvar self = this;\n\tfor(var i=0,len = nodes.length;i<len;i++){\n\t\tthis[i] = nodes[i];\n\t}\n};\n__NodeCollection.prototype = {\n\tcontains: function(el){\n\t\treturn this[el] !== undefined;\n\t},\n\tsize: function(){\n\t\tvar i = 0;\n\t\tfor(var prop in this){\n\t\t\tif(this.hasOwnProperty(prop)){\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n};*/\n\n/**\n * @exports UndirectedGraph as toxi.UndirectedGraph\n */\n\n\nvar UndirectedGraph = function () {\n  this._nodeLinks = {};\n  this._nodeIDs = [];\n};\n\nUndirectedGraph.prototype = {\n  add: function (node) {\n    if (this._nodeLinks[node] !== undefined) {\n      return;\n    }\n\n    this._nodeLinks[node] = new ArraySet();\n\n    this._nodeIDs.push(node);\n  },\n  connect: function (nodeA, nodeB) {\n    if (this._nodeLinks[nodeA] === undefined) {\n      throw new Error(\"nodeA has not been added\");\n    }\n\n    if (this._nodeLinks[nodeB] === undefined) {\n      throw new Error(\"nodeB has not been added\");\n    }\n\n    this._nodeLinks[nodeA].push(nodeB);\n\n    this._nodeLinks[nodeB].push(nodeA);\n  },\n  disconnect: function (nodeA, nodeB) {\n    if (this._nodeLinks[nodeA] === undefined) {\n      throw new Error(\"nodeA has not been added\");\n    }\n\n    if (this._nodeLinks[nodeB] === undefined) {\n      throw new Error(\"nodeB has not been added\");\n    }\n\n    this._nodeLinks[nodeA].splice(this._nodeLinks[nodeA].indexOf(nodeB), 1);\n\n    this._nodeLinks[nodeB].splice(this._nodeLinks[nodeB].indexOf(nodeA), 1);\n  },\n  getConnectedNodesFor: function (node) {\n    if (this._nodeLinks[node] === undefined) {\n      throw new Error(\"node has not been added\");\n    }\n\n    return this._nodeLinks[node];\n  },\n  getNodes: function () {\n    return this._nodeIDs;\n  },\n  remove: function (node) {\n    var connections = this._nodeLinks[node];\n\n    if (connections === undefined) {\n      return;\n    }\n\n    for (var i = 0, len = connections.length; i < len; i++) {\n      var neighbor = connections[i];\n      var nodeI = neighbor.indexOf(node);\n      neighbor.splice(nodeI, 1);\n    }\n\n    delete this._nodeLinks[node];\n\n    var i = this._nodeIDs.indexOf(node);\n\n    this._nodeIDs.splice(node, 1);\n  }\n};\nmodule.exports = UndirectedGraph;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/util/datatypes/UndirectedGraph.js"],"names":["ArraySet","require","UndirectedGraph","_nodeLinks","_nodeIDs","prototype","add","node","undefined","push","connect","nodeA","nodeB","Error","disconnect","splice","indexOf","getConnectedNodesFor","getNodes","remove","connections","i","len","length","neighbor","nodeI","module","exports"],"mappings":"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","sourcesContent":["\n\nvar ArraySet = require('./ArraySet');\n\n\n//wrap connections in this before passing them out\n//this way the rest of the lib can treat it like a Java Collection\n/*var __NodeCollection = function(nodes){\n\tvar self = this;\n\tfor(var i=0,len = nodes.length;i<len;i++){\n\t\tthis[i] = nodes[i];\n\t}\n};\n__NodeCollection.prototype = {\n\tcontains: function(el){\n\t\treturn this[el] !== undefined;\n\t},\n\tsize: function(){\n\t\tvar i = 0;\n\t\tfor(var prop in this){\n\t\t\tif(this.hasOwnProperty(prop)){\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t\treturn i;\n\t}\n};*/\n\n\n/**\n * @exports UndirectedGraph as toxi.UndirectedGraph\n */\nvar UndirectedGraph = function(){\n\tthis._nodeLinks = {};\n\tthis._nodeIDs = [];\n};\n\n\nUndirectedGraph.prototype = {\n\tadd: function(node){\n\t\tif(this._nodeLinks[node] !== undefined){\n\t\t\treturn;\n\t\t}\n\t\tthis._nodeLinks[node] = new ArraySet();\n\t\tthis._nodeIDs.push(node);\n\t},\n\tconnect: function(nodeA,nodeB){\n\t\tif(this._nodeLinks[nodeA] === undefined){\n\t\t\tthrow new Error(\"nodeA has not been added\");\n\t\t}\n\t\tif(this._nodeLinks[nodeB] === undefined){\n\t\t\tthrow new Error(\"nodeB has not been added\");\n\t\t}\n\t\tthis._nodeLinks[nodeA].push(nodeB);\n\t\tthis._nodeLinks[nodeB].push(nodeA);\n\t},\n\tdisconnect: function(nodeA,nodeB){\n\t\tif(this._nodeLinks[nodeA] === undefined){\n\t\t\tthrow new Error(\"nodeA has not been added\");\n\t\t}\n\t\tif(this._nodeLinks[nodeB] === undefined){\n\t\t\tthrow new Error(\"nodeB has not been added\");\n\t\t}\n\t\tthis._nodeLinks[nodeA].splice(this._nodeLinks[nodeA].indexOf(nodeB),1);\n\t\tthis._nodeLinks[nodeB].splice(this._nodeLinks[nodeB].indexOf(nodeA),1);\n\t},\n\tgetConnectedNodesFor: function(node){\n\t\tif(this._nodeLinks[node] === undefined){\n\t\t\tthrow new Error(\"node has not been added\");\n\t\t}\n\t\treturn this._nodeLinks[node];\n\t},\n\tgetNodes: function(){\n\t\treturn this._nodeIDs;\n\t},\n\tremove: function(node){\n\t\tvar connections = this._nodeLinks[node];\n\t\tif(connections === undefined){\n\t\t\treturn;\n\t\t}\n\n\t\tfor(var i = 0,len = connections.length;i<len;i++){\n\t\t\tvar neighbor = connections[i];\n\t\t\tvar\tnodeI = neighbor.indexOf(node);\n\t\t\tneighbor.splice(nodeI,1);\n\t\t}\n\t\tdelete this._nodeLinks[node];\n\t\tvar i = this._nodeIDs.indexOf(node);\n\t\tthis._nodeIDs.splice(node,1);\n\t}\n};\n\nmodule.exports = UndirectedGraph;\n\n"]},"metadata":{},"sourceType":"script"}