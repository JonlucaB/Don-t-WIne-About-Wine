{"ast":null,"code":"var extend = require('../internals/extend'),\n    has = require('../internals/has'),\n    is = require('../internals/is'),\n    mathUtils = require('../math/mathUtils'),\n    Vec2D = require('./Vec2D'); //declared in this module\n\n\nvar Ellipse, Circle;\n/**\n * @class defines a 2D ellipse and provides several utility methods for it.\n * @member toxi\n * @augments Vec2D\n */\n\nEllipse = function (a, b, c, d) {\n  this.radius = new Vec2D();\n\n  if (arguments.length === 0) {\n    Vec2D.apply(this, [0, 0]);\n    this.setRadii(1, 1);\n  } else if (has.XY(a)) {\n    Vec2D.apply(this, [a.x, a.y]);\n\n    if (has.XY(b)) {\n      this.setRadii(b.x, b.y);\n    } else {\n      this.setRadii(b, c);\n    }\n  } else {\n    if (d === undefined) {\n      if (c === undefined) {\n        Vec2D.call(this, 0, 0);\n        this.setRadii(a, b);\n      } else {\n        Vec2D.call(this, a, b);\n        this.setRadii(c, c);\n      }\n    } else {\n      Vec2D.call(this, a, b);\n      this.setRadii(c, d);\n    }\n  }\n};\n\nextend(Ellipse, Vec2D);\n\nEllipse.prototype.containsPoint = function (p) {\n  // Immediately reject points outside the containing rectangle\n  if (mathUtils.abs(p.x - this.x) > this.radius.x || mathUtils.abs(p.y - this.y) > this.radius.y) {\n    return false;\n  }\n\n  var foci = this.getFoci();\n  return p.distanceTo(foci[0]) + p.distanceTo(foci[1]) < 2 * mathUtils.max(this.radius.x, this.radius.y);\n};\n/**\n * Computes the area covered by the ellipse.\n */\n\n\nEllipse.prototype.getArea = function () {\n  return mathUtils.PI * this.radius.x * this.radius.y;\n};\n/**\n * Computes the approximate circumference of the ellipse, using this\n * equation: <code>2 * PI * sqrt(1/2 * (rx*rx+ry*ry))</code>.\n *\n * The precise value is an infinite series elliptical integral, but the\n * approximation comes sufficiently close. See Wikipedia for more details:\n *\n * http://en.wikipedia.org/wiki/Ellipse\n *\n * @return circumference\n */\n\n\nEllipse.prototype.getCircumference = function () {\n  // wikipedia solution:\n  // return (float) (MathUtils.PI * (3 * (radius.x + radius.y) - Math\n  // .sqrt((3 * radius.x + radius.y) * (radius.x + 3 * radius.y))));\n  return Math.sqrt(0.5 * this.radius.magSquared()) * mathUtils.TWO_PI;\n};\n/**\n * @return the focus\n */\n\n\nEllipse.prototype.getFoci = function () {\n  if (this.radius.x > this.radius.y) {\n    return [this.sub(this.focus, 0), this.add(this.focus, 0)];\n  }\n\n  return [this.sub(0, this.focus), this.add(0, this.focus)];\n};\n/**\n * @return the 2 radii of the ellipse as a Vec2D\n */\n\n\nEllipse.prototype.getRadii = function () {\n  return this.radius.copy();\n};\n/**\n * Sets the radii of the ellipse to the new values.\n *\n * @param rx\n * @param ry\n * @return itself\n */\n\n\nEllipse.prototype.setRadii = function (rx, ry) {\n  if (has.XY(rx)) {\n    ry = rx.y;\n    rx = rx.x;\n  }\n\n  this.radius.set(rx, ry);\n\n  if (this.radius.x > this.radius.y) {\n    this.focus = Math.sqrt(this.radius.x * this.radius.x - this.radius.y * this.radius.y);\n  } else {\n    this.focus = Math.sqrt(this.radius.y * this.radius.y - this.radius.x * this.radius.x);\n  }\n\n  return this;\n};\n/**\n * Creates a {@link Polygon2D} instance of the ellipse sampling it at the\n * given resolution.\n *\n * @param res\n *            number of steps\n * @return ellipse as polygon\n */\n\n\nEllipse.prototype.toPolygon2D = function (res) {\n  var Polygon2D = require('./Polygon2D');\n\n  var poly = new Polygon2D();\n  var step = mathUtils.TWO_PI / res;\n\n  for (var i = 0; i < res; i++) {\n    var v = Vec2D.fromTheta(i * step).scaleSelf(this.radius).addSelf(this);\n    poly.add(v);\n  }\n\n  return poly;\n};\n\nexports = module.exports = Ellipse;\n/**\n * Circle\n * @class This class overrides {@link Ellipse} to define a 2D circle and provides\n * several utility methods for it, including factory methods to construct\n * circles from points.\n * @member toxi\n * @augments Ellipse\n */\n\nCircle = function (a, b, c) {\n  if (arguments.length == 1) {\n    if (is.Circle(a)) {\n      Ellipse.apply(this, [a, a.radius.x]);\n    } else {\n      Ellipse.apply(this, [0, 0, a]);\n    }\n  } else if (arguments.length == 2) {\n    Ellipse.apply(this, [a, b]);\n  } else {\n    Ellipse.apply(this, [a, b, c, c]);\n  }\n};\n\nextend(Circle, Ellipse);\n/**\n * Factory method to construct a circle which has the two given points lying\n * on its perimeter. If the points are coincident, the circle will have a\n * radius of zero.\n *\n * @param p1\n * @param p2\n * @return new circle instance\n */\n\nCircle.from2Points = function (p1, p2) {\n  var m = p1.interpolateTo(p2, 0.5);\n  var distanceTo = m.distanceTo(p1);\n  return new Circle(m, distanceTo);\n};\n/**\n * Factory method to construct a circle which has the three given points\n * lying on its perimeter. The function returns null, if the 3 points are\n * co-linear (in which case it's impossible to find a circle).\n *\n * Based on CPP code by Paul Bourke:\n * http://local.wasp.uwa.edu.au/~pbourke/geometry/circlefrom3/\n *\n * @param p1\n * @param p2\n * @param p3\n * @return new circle instance or null\n */\n\n\nCircle.from3Points = function (p1, p2, p3) {\n  var circle,\n      deltaA = p2.sub(p1),\n      deltaB = p3.sub(p2),\n      centroid,\n      radius;\n\n  if (mathUtils.abs(deltaA.x) <= 0.0000001 && mathUtils.abs(deltaB.y) <= 0.0000001) {\n    centroid = new Vec2D(p2.x + p3.x, p1.y + p2.y).scaleSelf(0.5);\n    radius = centroid.distanceTo(p1);\n    circle = new Circle(centroid, radius);\n  } else {\n    var aSlope = deltaA.y / deltaA.x;\n    var bSlope = deltaB.y / deltaB.x;\n\n    if (mathUtils.abs(aSlope - bSlope) > 0.0000001 && aSlope !== 0) {\n      var x = (aSlope * bSlope * (p1.y - p3.y) + bSlope * (p1.x + p2.x) - aSlope * (p2.x + p3.x)) / (2 * (bSlope - aSlope));\n      var y = -(x - (p1.x + p2.x) / 2) / aSlope + (p1.y + p2.y) / 2;\n      centroid = new Vec2D(x, y);\n      radius = centroid.distanceTo(p1);\n      circle = new Circle(centroid, radius);\n    }\n  }\n\n  return circle;\n};\n\nCircle.newBoundingCircle = function (vertices) {\n  var origin = new Vec2D();\n  var maxD = 0;\n  var i = 0;\n  var l = vertices.length;\n\n  for (; i < l; i++) {\n    origin.addSelf(vertices[i]);\n  }\n\n  origin.scaleSelf(1 / vertices.length);\n\n  for (i = 0; i < l; i++) {\n    var d = origin.distanceToSquared(vertices[i]);\n\n    if (d > maxD) {\n      maxD = d;\n    }\n  }\n\n  return new Circle(origin, Math.sqrt(maxD));\n};\n\nCircle.prototype.containsPoint = function (p) {\n  return this.distanceToSquared(p) <= this.radius.x * this.radius.x;\n};\n\nCircle.prototype.getCircumference = function () {\n  return mathUtils.TWO_PI * this.radius.x;\n};\n\nCircle.prototype.getRadius = function () {\n  return this.radius.x;\n};\n\nCircle.prototype.getTangentPoints = function (p) {\n  var m = this.interpolateTo(p, 0.5);\n  return this.intersectsCircle(new Circle(m, m.distanceTo(p)));\n};\n\nCircle.prototype.intersectsCircle = function (c) {\n  var res,\n      delta = c.sub(this),\n      d = delta.magnitude(),\n      r1 = this.radius.x,\n      r2 = c.radius.x;\n\n  if (d <= r1 + r2 && d >= Math.abs(r1 - r2)) {\n    var a = (r1 * r1 - r2 * r2 + d * d) / (2.0 * d);\n    d = 1 / d;\n    var p = this.add(delta.scale(a * d));\n    var h = Math.sqrt(r1 * r1 - a * a);\n    delta.perpendicular().scaleSelf(h * d);\n    var i1 = p.add(delta);\n    var i2 = p.sub(delta);\n    res = [i1, i2];\n  }\n\n  return res;\n};\n\nCircle.prototype.setRadius = function (r) {\n  this.setRadii(r, r);\n  return this;\n};\n\nexports.Circle = Circle;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/geom/Ellipse.js"],"names":["extend","require","has","is","mathUtils","Vec2D","Ellipse","Circle","a","b","c","d","radius","arguments","length","apply","setRadii","XY","x","y","undefined","call","prototype","containsPoint","p","abs","foci","getFoci","distanceTo","max","getArea","PI","getCircumference","Math","sqrt","magSquared","TWO_PI","sub","focus","add","getRadii","copy","rx","ry","set","toPolygon2D","res","Polygon2D","poly","step","i","v","fromTheta","scaleSelf","addSelf","exports","module","from2Points","p1","p2","m","interpolateTo","from3Points","p3","circle","deltaA","deltaB","centroid","aSlope","bSlope","newBoundingCircle","vertices","origin","maxD","l","distanceToSquared","getRadius","getTangentPoints","intersectsCircle","delta","magnitude","r1","r2","scale","h","perpendicular","i1","i2","setRadius","r"],"mappings":"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","sourcesContent":["\n\nvar extend = require('../internals/extend'),\n\thas = require('../internals/has'),\n\tis = require('../internals/is'),\n\tmathUtils = require('../math/mathUtils'),\n\tVec2D = require('./Vec2D');\n\n\n//declared in this module\nvar Ellipse, Circle;\n\n/**\n * @class defines a 2D ellipse and provides several utility methods for it.\n * @member toxi\n * @augments Vec2D\n */\n\nEllipse = function(a,b,c,d) {\n\tthis.radius = new Vec2D();\n\tif(arguments.length === 0){\n\t\tVec2D.apply(this,[0,0]);\n\t\tthis.setRadii(1,1);\n\t} else if( has.XY( a ) ) {\n\t\tVec2D.apply(this,[a.x,a.y]);\n\t\tif( has.XY( b ) ){\n\t\t\tthis.setRadii(b.x,b.y);\n\t\t} else {\n\t\t\tthis.setRadii(b,c);\n\t\t}\n\t} else {\n\t\tif(d === undefined) {\n\t\t\tif(c === undefined) {\n\t\t\t\tVec2D.call(this, 0, 0 );\n\t\t\t\tthis.setRadii(a,b);\n\t\t\t} else {\n\t\t\t\tVec2D.call(this, a, b );\n\t\t\t\tthis.setRadii(c,c);\n\t\t\t}\n\t\t} else {\n\t\t\tVec2D.call(this, a,b);\n\t\t\tthis.setRadii(c,d);\n\t\t}\n\t}\n};\n\nextend(Ellipse,Vec2D);\n\nEllipse.prototype.containsPoint = function(p) {\n    // Immediately reject points outside the containing rectangle\n    if (mathUtils.abs(p.x - this.x) > this.radius.x ||\n        mathUtils.abs(p.y - this.y) > this.radius.y) {\n        return false;\n    }\n    var foci = this.getFoci();\n    return p.distanceTo(foci[0]) + p.distanceTo(foci[1]) < 2 * mathUtils.max(this.radius.x, this.radius.y);\n};\n\n/**\n * Computes the area covered by the ellipse.\n */\nEllipse.prototype.getArea = function() {\n    return mathUtils.PI * this.radius.x * this.radius.y;\n};\n\n/**\n * Computes the approximate circumference of the ellipse, using this\n * equation: <code>2 * PI * sqrt(1/2 * (rx*rx+ry*ry))</code>.\n *\n * The precise value is an infinite series elliptical integral, but the\n * approximation comes sufficiently close. See Wikipedia for more details:\n *\n * http://en.wikipedia.org/wiki/Ellipse\n *\n * @return circumference\n */\nEllipse.prototype.getCircumference = function() {\n    // wikipedia solution:\n    // return (float) (MathUtils.PI * (3 * (radius.x + radius.y) - Math\n    // .sqrt((3 * radius.x + radius.y) * (radius.x + 3 * radius.y))));\n    return Math.sqrt(0.5 * this.radius.magSquared()) * mathUtils.TWO_PI;\n};\n\n/**\n * @return the focus\n */\nEllipse.prototype.getFoci = function() {\n    if (this.radius.x > this.radius.y) {\n        return [\n            this.sub(this.focus, 0),\n            this.add(this.focus, 0)\n        ];\n    }\n    return [\n        this.sub(0, this.focus),\n        this.add(0, this.focus)\n    ];\n};\n\n/**\n * @return the 2 radii of the ellipse as a Vec2D\n */\nEllipse.prototype.getRadii = function() {\n    return this.radius.copy();\n};\n\n\n/**\n * Sets the radii of the ellipse to the new values.\n *\n * @param rx\n * @param ry\n * @return itself\n */\nEllipse.prototype.setRadii = function(rx,ry) {\n\tif( has.XY( rx ) ){\n\t\try = rx.y;\n\t\trx = rx.x;\n\t}\n    this.radius.set(rx, ry);\n\n    if (this.radius.x > this.radius.y) {\n        this.focus = Math.sqrt(this.radius.x * this.radius.x - this.radius.y * this.radius.y);\n    } else {\n        this.focus = Math.sqrt(this.radius.y * this.radius.y - this.radius.x * this.radius.x);\n    }\n\n    return this;\n};\n\n/**\n * Creates a {@link Polygon2D} instance of the ellipse sampling it at the\n * given resolution.\n *\n * @param res\n *            number of steps\n * @return ellipse as polygon\n */\nEllipse.prototype.toPolygon2D = function(res) {\n    var Polygon2D = require('./Polygon2D');\n    var poly = new Polygon2D();\n    var step = mathUtils.TWO_PI / res;\n    for (var i = 0; i < res; i++) {\n\t\tvar v = Vec2D.fromTheta(i * step).scaleSelf(this.radius).addSelf(this);\n\t\tpoly.add(v);\n\t}\n    return poly;\n};\n\n\nexports = module.exports = Ellipse;\n\n/**\n * Circle\n * @class This class overrides {@link Ellipse} to define a 2D circle and provides\n * several utility methods for it, including factory methods to construct\n * circles from points.\n * @member toxi\n * @augments Ellipse\n */\nCircle = function(a,b,c) {\n\tif(arguments.length == 1){\n\t\tif( is.Circle( a ) ){\n\t\t\tEllipse.apply(this,[a,a.radius.x]);\n\t\t} else {\n\t\t\tEllipse.apply(this,[0,0,a]);\n\t\t}\n\t} else if(arguments.length == 2){\n\t\tEllipse.apply(this,[a,b]);\n\t} else {\n\t\tEllipse.apply(this,[a,b,c,c]);\n\t}\n};\n\nextend(Circle,Ellipse);\n\n\n\n\n\n/**\n * Factory method to construct a circle which has the two given points lying\n * on its perimeter. If the points are coincident, the circle will have a\n * radius of zero.\n *\n * @param p1\n * @param p2\n * @return new circle instance\n */\nCircle.from2Points = function(p1,p2) {\n    var m = p1.interpolateTo(p2, 0.5);\n    var distanceTo = m.distanceTo(p1);\n    return new Circle(m, distanceTo);\n};\n\n/**\n * Factory method to construct a circle which has the three given points\n * lying on its perimeter. The function returns null, if the 3 points are\n * co-linear (in which case it's impossible to find a circle).\n *\n * Based on CPP code by Paul Bourke:\n * http://local.wasp.uwa.edu.au/~pbourke/geometry/circlefrom3/\n *\n * @param p1\n * @param p2\n * @param p3\n * @return new circle instance or null\n */\nCircle.from3Points = function(p1,p2,p3) {\n    var circle,\n\t\tdeltaA = p2.sub(p1),\n\t\tdeltaB = p3.sub(p2),\n\t\tcentroid,\n\t\tradius;\n\tif (mathUtils.abs(deltaA.x) <= 0.0000001 && mathUtils.abs(deltaB.y) <= 0.0000001) {\n\t\tcentroid = new Vec2D(p2.x + p3.x, p1.y + p2.y).scaleSelf(0.5);\n\t\tradius = centroid.distanceTo(p1);\n\t\tcircle = new Circle(centroid, radius);\n\t} else {\n\t\tvar aSlope = deltaA.y / deltaA.x;\n\t\tvar bSlope = deltaB.y / deltaB.x;\n\t\tif (mathUtils.abs(aSlope - bSlope) > 0.0000001 && aSlope !== 0) {\n\t\t\tvar x = (aSlope * bSlope * (p1.y - p3.y) + bSlope * (p1.x + p2.x) - aSlope * (p2.x + p3.x)) / (2 * (bSlope - aSlope));\n\t\t\tvar y = -(x - (p1.x + p2.x) / 2) / aSlope + (p1.y + p2.y) / 2;\n\t\t\tcentroid = new Vec2D(x, y);\n\t\t\tradius = centroid.distanceTo(p1);\n\t\t\tcircle = new Circle(centroid, radius);\n\t\t}\n\t}\n    return circle;\n};\n\n\nCircle.newBoundingCircle = function( vertices ){\n\tvar origin = new Vec2D();\n\tvar maxD = 0;\n\tvar i = 0;\n\tvar l = vertices.length;\n\tfor( ; i<l; i++ ){\n\t\torigin.addSelf( vertices[i] );\n\t}\n\torigin.scaleSelf( 1 / vertices.length );\n\tfor( i = 0; i<l; i++ ){\n\t\tvar d = origin.distanceToSquared( vertices[i] );\n\t\tif( d > maxD ) {\n\t\t\tmaxD = d;\n\t\t}\n\t}\n\treturn new Circle( origin, Math.sqrt( maxD ) );\n};\n\n\n\n\nCircle.prototype.containsPoint = function(p) {\n    return this.distanceToSquared(p) <= this.radius.x * this.radius.x;\n};\n\nCircle.prototype.getCircumference = function() {\n    return mathUtils.TWO_PI * this.radius.x;\n};\n\nCircle.prototype.getRadius = function() {\n    return this.radius.x;\n};\n\nCircle.prototype.getTangentPoints = function(p) {\n    var m = this.interpolateTo(p, 0.5);\n    return this.intersectsCircle(new Circle(m, m.distanceTo(p)));\n};\n\n\nCircle.prototype.intersectsCircle = function(c) {\n    var res,\n\t\tdelta = c.sub(this),\n\t\td = delta.magnitude(),\n\t\tr1 = this.radius.x,\n\t\tr2 = c.radius.x;\n    if (d <= r1 + r2 && d >= Math.abs(r1 - r2)) {\n        var a = (r1 * r1 - r2 * r2 + d * d) / (2.0 * d);\n        d = 1 / d;\n        var p = this.add(delta.scale(a * d));\n        var h = Math.sqrt(r1 * r1 - a * a);\n        delta.perpendicular().scaleSelf(h * d);\n        var i1 = p.add(delta);\n        var i2 = p.sub(delta);\n        res = [i1, i2 ];\n    }\n    return res;\n};\n\nCircle.prototype.setRadius = function(r) {\n    this.setRadii(r, r);\n    return this;\n};\n\n\nexports.Circle = Circle;\n\n\n"]},"metadata":{},"sourceType":"script"}