{"ast":null,"code":"var Cone = require('./Cone');\n/** \n @member toxi\n @constructor\n @description An Abstract (don't use this directly) Axis-aligned Cylinder class\n */\n\n\nvar AxisAlignedCylinder = function (pos, radius, length) {\n  this.pos = pos === undefined ? undefined : pos.copy();\n  this.setRadius(radius);\n  this.setLength(length);\n};\n\nAxisAlignedCylinder.prototype = {\n  /**\n  Checks if the given point is inside the cylinder. \n  @param p\n  @return true, if inside\n  */\n  containsPoint: function (p) {\n    throw Error(\"AxisAlignedCylinder.containsPoint(): not implmented\");\n  },\n\n  /**\n  @return the length\n  */\n  getLength: function () {\n    return this.length;\n  },\n\n  /**\n  @return the cylinder's orientation axis\n  */\n  getMajorAxis: function () {\n    throw Error(\"AxisAlignedCylinder.getMajorAxis(): not implemented\");\n  },\n\n  /**\n  Returns the cylinder's position (centroid).\n  @return the pos\n  */\n  getPosition: function () {\n    return this.pos.copy();\n  },\n\n  /**\n  @return the cylinder radius\n  */\n  getRadius: function () {\n    return this.radius;\n  },\n\n  /**\n  @param length the length to set\n  */\n  setLength: function (length) {\n    this.length = length;\n  },\n\n  /**\n  @param pos the pos to set\n  */\n  setPosition: function (pos) {\n    this.pos.set(pos);\n  },\n  setRadius: function (radius) {\n    this.radius = radius;\n    this.radiusSquared = radius * radius;\n  },\n\n  /**\n  Builds a TriangleMesh representation of the cylinder at a default\n  resolution 30 degrees. \n  @return mesh instance\n  */\n  toMesh: function (a, b, c) {\n    var opts = {\n      mesh: undefined,\n      steps: 12,\n      thetaOffset: 0\n    };\n\n    if (arguments.length == 1 && typeof arguments[0] == 'object') {\n      //options object\n      for (var prop in arguments[0]) {\n        opts[prop] = arguments[0][prop];\n      }\n    } else if (arguments.length == 2) {\n      opts.steps = arguments[0];\n      opts.thetaOffset = arguments[1];\n    }\n\n    var cone = new Cone(this.pos, this.getMajorAxis().getVector(), this.radius, this.radius, this.length);\n    return cone.toMesh(opts.mesh, opts.steps, opts.thetaOffset, true, true);\n  }\n};\nmodule.exports = AxisAlignedCylinder;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/AxisAlignedCylinder.js"],"names":["Cone","require","AxisAlignedCylinder","pos","radius","length","undefined","copy","setRadius","setLength","prototype","containsPoint","p","Error","getLength","getMajorAxis","getPosition","getRadius","setPosition","set","radiusSquared","toMesh","a","b","c","opts","mesh","steps","thetaOffset","arguments","prop","cone","getVector","module","exports"],"mappings":"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","sourcesContent":["\n\nvar Cone = require('./Cone');\n\n/** \n @member toxi\n @constructor\n @description An Abstract (don't use this directly) Axis-aligned Cylinder class\n */\nvar\tAxisAlignedCylinder = function(pos,radius,length) {\n\tthis.pos = (pos===undefined)? undefined: pos.copy();\n\tthis.setRadius(radius);\n\tthis.setLength(length);\n};\n\nAxisAlignedCylinder.prototype = {\n\t/**\n\tChecks if the given point is inside the cylinder. \n\t@param p\n\t@return true, if inside\n\t*/\n\tcontainsPoint: function(p){\n\t\tthrow Error(\"AxisAlignedCylinder.containsPoint(): not implmented\");\n\t},\n\n\t/**\n\t@return the length\n\t*/\n\tgetLength: function() {\n\t\treturn this.length;\n\t},\n\n\t/**\n\t@return the cylinder's orientation axis\n\t*/\n\tgetMajorAxis: function(){\n\t\tthrow Error(\"AxisAlignedCylinder.getMajorAxis(): not implemented\");\n\t},\n\n\t/**\n\tReturns the cylinder's position (centroid).\n\t@return the pos\n\t*/\n\tgetPosition: function() {\n\t\treturn this.pos.copy();\n\t},\n\n\t/**\n\t@return the cylinder radius\n\t*/\n\tgetRadius: function() {\n\t\treturn this.radius;\n\t},\n\n\t/**\n\t@param length the length to set\n\t*/\n\tsetLength: function(length) {\n\t\tthis.length = length;\n\t},\n\n\t/**\n\t@param pos the pos to set\n\t*/\n\tsetPosition: function(pos) {\n\t\tthis.pos.set(pos);\n\t},\n\n   setRadius: function(radius) {\n\t\tthis.radius = radius;\n\t\tthis.radiusSquared = radius * radius;\n\t},\n\n\t/**\n\tBuilds a TriangleMesh representation of the cylinder at a default\n\tresolution 30 degrees. \n\t@return mesh instance\n\t*/\n\ttoMesh: function(a,b,c) {\n\t\tvar opts = {\n\t\t\tmesh: undefined,\n\t\t\tsteps: 12,\n\t\t\tthetaOffset: 0\n\t\t};\n\t\tif(arguments.length == 1 && typeof arguments[0] == 'object'){ //options object\n\t\t\tfor(var prop in arguments[0]){\n\t\t\t\topts[prop] = arguments[0][prop];\n\t\t\t}\n\t\t} else if(arguments.length == 2){\n\t\t\topts.steps = arguments[0];\n\t\t\topts.thetaOffset = arguments[1];\n\t\t}\n\t\tvar cone = new Cone(this.pos,this.getMajorAxis().getVector(), this.radius, this.radius, this.length);\n\t\treturn cone.toMesh(opts.mesh,opts.steps,opts.thetaOffset,true,true);\n\t}\n};\n\nmodule.exports = AxisAlignedCylinder;\n\n"]},"metadata":{},"sourceType":"script"}