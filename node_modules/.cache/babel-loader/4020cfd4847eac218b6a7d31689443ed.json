{"ast":null,"code":"var mathUtils = require('./mathUtils'),\n    LinearInterpolation = require('./LinearInterpolation');\n\nvar _Range = function (min, max) {\n  this.min = min;\n  this.max = max;\n};\n\n_Range.prototype.toString = function () {\n  return \"{ min: \" + this.min + \", max: \" + this.max + \"}\";\n};\n/**\n * @class This class maps values from one interval into another. By default the mapping\n * is using linear projection, but can be changed by using alternative\n * {@link math.InterpolateStrategy} implementations to achieve a\n * non-regular mapping.\n *\n * @member toxi\n *\n * @description Creates a new instance to map values between the 2 number ranges\n * specified. By default linear projection is used.\n * @param {Number} minIn\n * @param {Number} maxIn\n * @param {Number} minOut\n * @param {Number} maxOut\n */\n\n\nvar ScaleMap = function (minIn, maxIn, minOut, maxOut) {\n  if (arguments.length == 1 && arguments[0].input !== undefined && arguments[0].output !== undefined) {\n    //opts object\n    var arg = arguments[0];\n    minOut = arg.output.min;\n    maxOut = arg.output.max;\n    maxIn = arg.input.max;\n    minIn = arg.input.min;\n  }\n\n  this.mapFunction = new LinearInterpolation();\n  this.setInputRange(minIn, maxIn);\n  this.setOutputRange(minOut, maxOut);\n};\n\nScaleMap.prototype = {\n  /**\n   * Computes mapped value in the target interval and ensures the input value\n   * is clipped to source interval.\n   * \n   * @param val\n   * @return mapped value\n   */\n  getClippedValueFor: function (val) {\n    var t = mathUtils.clipNormalized((val - this._in.min) / this._interval);\n    return this.mapFunction.interpolate(0, this.mapRange, t) + this._out.min;\n  },\n\n  /**\n   * @return the middle value of the input range.\n   */\n  getInputMedian: function () {\n    return (this._in.min + this._in.max) * 0.5;\n  },\n\n  /**\n   * @return the in\n   */\n  getInputRange: function () {\n    return this._in;\n  },\n\n  /**\n   * @return the mapped middle value of the output range. Depending on the\n   *         mapping function used, this value might be different to the one\n   *         returned by {@link #getOutputMedian()}.\n   */\n  getMappedMedian: function () {\n    return this.getMappedValueFor(0.5);\n  },\n\n  /**\n   * Computes mapped value in the target interval. Does check if input value\n   * is outside the input range.\n   * \n   * @param val\n   * @return mapped value\n   */\n  getMappedValueFor: function (val) {\n    var t = (val - this._in.min) / this._interval;\n    return this.mapFunction.interpolate(0, this.mapRange, t) + this._out.min;\n  },\n\n  /**\n   * @return the middle value of the output range\n   */\n  getOutputMedian: function () {\n    return (this._out.min + this._out.max) * 0.5;\n  },\n\n  /**\n   * @return the output range\n   */\n  getOutputRange: function () {\n    return this._out;\n  },\n\n  /**\n   * Sets new minimum & maximum values for the input range\n   * \n   * @param min\n   * @param max\n   */\n  setInputRange: function (min, max) {\n    this._in = new _Range(min, max);\n    this._interval = max - min;\n  },\n\n  /**\n   * Overrides the mapping function used for the scale conversion.\n   * \n   * @param func\n   *            interpolate strategy implementation\n   */\n  setMapFunction: function (func) {\n    this.mapFunction = func;\n  },\n\n  /**\n   * Sets new minimum & maximum values for the output/target range\n   * \n   * @param min\n   *            new min output value\n   * @param max\n   *            new max output value\n   */\n  setOutputRange: function (min, max) {\n    this._out = new _Range(min, max);\n    this.mapRange = max - min;\n  },\n  toString: function () {\n    return \"ScaleMap, inputRange: \" + this._in.toString() + \" outputRange: \" + this._out.toString();\n  }\n};\nmodule.exports = ScaleMap;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/math/ScaleMap.js"],"names":["mathUtils","require","LinearInterpolation","_Range","min","max","prototype","toString","ScaleMap","minIn","maxIn","minOut","maxOut","arguments","length","input","undefined","output","arg","mapFunction","setInputRange","setOutputRange","getClippedValueFor","val","t","clipNormalized","_in","_interval","interpolate","mapRange","_out","getInputMedian","getInputRange","getMappedMedian","getMappedValueFor","getOutputMedian","getOutputRange","setMapFunction","func","module","exports"],"mappings":"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","sourcesContent":["\n\nvar mathUtils = require('./mathUtils'),\n    LinearInterpolation = require('./LinearInterpolation');\n\n\nvar _Range = function(min,max){\n\tthis.min = min;\n\tthis.max = max;\n};\n_Range.prototype.toString = function(){\n\treturn \"{ min: \"+this.min+ \", max: \"+this.max+\"}\";\n};\n\n\n/**\n * @class This class maps values from one interval into another. By default the mapping\n * is using linear projection, but can be changed by using alternative\n * {@link math.InterpolateStrategy} implementations to achieve a\n * non-regular mapping.\n *\n * @member toxi\n *\n * @description Creates a new instance to map values between the 2 number ranges\n * specified. By default linear projection is used.\n * @param {Number} minIn\n * @param {Number} maxIn\n * @param {Number} minOut\n * @param {Number} maxOut\n */ \nvar ScaleMap = function(minIn, maxIn, minOut, maxOut) {\n\tif(arguments.length == 1 && arguments[0].input !== undefined && arguments[0].output !== undefined){ //opts object\n\t\tvar arg = arguments[0];\n\t\tminOut = arg.output.min;\n\t\tmaxOut = arg.output.max;\n        maxIn = arg.input.max;\n        minIn = arg.input.min;\n\t}\n\tthis.mapFunction = new LinearInterpolation();\n\tthis.setInputRange(minIn, maxIn);\n\tthis.setOutputRange(minOut, maxOut);\n};\n\n\nScaleMap.prototype = {\n\t\n    /**\n     * Computes mapped value in the target interval and ensures the input value\n     * is clipped to source interval.\n     * \n     * @param val\n     * @return mapped value\n     */\n   getClippedValueFor: function(val) {\n        var t = mathUtils.clipNormalized( ((val - this._in.min) / this._interval));\n        return this.mapFunction.interpolate(0, this.mapRange, t) + this._out.min;\n    },\n\n    /**\n     * @return the middle value of the input range.\n     */\n    getInputMedian: function() {\n        return (this._in.min + this._in.max) * 0.5;\n    },\n\n    /**\n     * @return the in\n     */\n    getInputRange: function() {\n        return this._in;\n    },\n\n    /**\n     * @return the mapped middle value of the output range. Depending on the\n     *         mapping function used, this value might be different to the one\n     *         returned by {@link #getOutputMedian()}.\n     */\n    getMappedMedian: function() {\n        return this.getMappedValueFor(0.5);\n    },\n\n    /**\n     * Computes mapped value in the target interval. Does check if input value\n     * is outside the input range.\n     * \n     * @param val\n     * @return mapped value\n     */\n    getMappedValueFor: function(val) {\n        var t = ((val - this._in.min) / this._interval);\n        return this.mapFunction.interpolate(0,  this.mapRange, t) + this._out.min;\n    },\n\n    /**\n     * @return the middle value of the output range\n     */\n    getOutputMedian:function() {\n        return (this._out.min + this._out.max) * 0.5;\n    },\n\n    /**\n     * @return the output range\n     */\n    getOutputRange: function() {\n        return this._out;\n    },\n\n    /**\n     * Sets new minimum & maximum values for the input range\n     * \n     * @param min\n     * @param max\n     */\n    setInputRange: function(min,max) {\n        this._in = new _Range(min,max);\n        this._interval = max - min;\n    },\n\n    /**\n     * Overrides the mapping function used for the scale conversion.\n     * \n     * @param func\n     *            interpolate strategy implementation\n     */\n    setMapFunction: function(func) {\n        this.mapFunction = func;\n    },\n\n    /**\n     * Sets new minimum & maximum values for the output/target range\n     * \n     * @param min\n     *            new min output value\n     * @param max\n     *            new max output value\n     */\n    setOutputRange: function(min, max) {\n        this._out = new _Range(min, max);\n        this.mapRange = max - min;\n    },\n    \n    toString: function(){\n\t\treturn \"ScaleMap, inputRange: \"+this._in.toString() + \" outputRange: \"+this._out.toString();\n    }\n};\n\nmodule.exports = ScaleMap;\n\n"]},"metadata":{},"sourceType":"script"}