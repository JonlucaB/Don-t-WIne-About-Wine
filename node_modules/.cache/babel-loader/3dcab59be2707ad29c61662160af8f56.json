{"ast":null,"code":"var extend = require('../internals').extend,\n    Vec3D = require('./Vec3D'),\n    TriangleMesh = require('./mesh/TriangleMesh');\n/**\n * @class A geometric definition of a cone (and cylinder as a special case) with\n * support for mesh creation/representation. The class is currently still\n * incomplete in that it doesn't provide any other features than the\n * construction of a cone shaped mesh.\n * @augments toxi.Vec3D\n * @member toxi\n * @param pos\n *            centre position\n * @param dir\n *            direction vector\n * @param rNorth\n *            radius on the side in the forward direction\n * @param rSouth\n *            radius on the side in the opposite direction\n * @param len\n *            length of the cone\n */\n\n\nfunction err(param) {\n  throw Error(\"Missing parameter: \" + param);\n}\n\nvar Cone = function (pos, dir, rNorth, rSouth, len) {\n  //if its a parameter object\n  var self = this;\n\n  if (typeof pos === 'object' && arguments.length === 1) {\n    process(pos.pos || pos.position || new Vec3D(), pos.dir || pos.direction || err(\"direction\"), pos.rNorth || pos.radiusNorth || err(\"radiusNorth\"), pos.rSouth || pos.radiusSouth || err(\"radiusSouth\"), pos.len || pos.length || err(\"length\"));\n  } else {\n    process(pos, dir, rNorth, rSouth, len);\n  }\n\n  function process(pos, dir, radiusNorth, radiusSouth, length) {\n    Vec3D.apply(self, [pos]);\n    self.dir = dir.getNormalized();\n    self.radiusNorth = radiusNorth;\n    self.radiusSouth = radiusSouth;\n    self.length = length;\n  }\n};\n\nextend(Cone, Vec3D);\n\nCone.prototype.toMesh = function (args) {\n  var opts = {\n    mesh: undefined,\n    steps: NaN,\n    thetaOffset: 0,\n    topClosed: true,\n    bottomClosed: true\n  };\n\n  if (arguments.length == 1) {\n    if (typeof arguments[0] == 'object') {\n      //##then it was a javascript option-object\n      var optionsObject = arguments[0];\n      opts.mesh = optionsObject.mesh;\n      opts.steps = optionsObject.steps || optionsObject.resolution || optionsObject.res;\n      opts.thetaOffset = optionsObject.thetaOffset || opts.thetaOffset;\n      opts.topClosed = optionsObject.topClosed || opts.topClosed;\n      opts.bottomClosed = optionsObject.bottomClosed || opts.bottomClosed;\n    } else {\n      opts.steps = arguments[0];\n    }\n  } else if (arguments.length == 2) {\n    opts.steps = arguments[0];\n    opts.thetaOffset = arguments[1];\n  } else if (arguments.length == 5) {\n    opts.mesh = arguments[0];\n    opts.steps = arguments[1];\n    opts.thetaOffset = arguments[2];\n    opts.topClosed = arguments[3];\n    opts.bottomClosed = arguments[4];\n  }\n\n  var c = this.add(0.01, 0.01, 0.01),\n      n = c.cross(this.dir.getNormalized()).normalize(),\n      halfAxis = this.dir.scale(this.length * 0.5),\n      p = this.sub(halfAxis),\n      q = this.add(halfAxis),\n      south = [],\n      north = [],\n      phi = Math.PI * 2 / opts.steps;\n  var i = 0,\n      j = 1;\n\n  for (i = 0; i < opts.steps; i++) {\n    var theta = i * phi + opts.thetaOffset;\n    var nr = n.getRotatedAroundAxis(this.dir, theta);\n    south[i] = nr.scale(this.radiusSouth).addSelf(p);\n    north[i] = nr.scale(this.radiusNorth).addSelf(q);\n  }\n\n  var numV = opts.steps * 2 + 2,\n      numF = opts.steps * 2 + (opts.topClosed ? opts.steps : 0) + (opts.bottomClosed ? opts.steps : 0),\n      mesh = opts.mesh || new TriangleMesh(\"cone\", numV, numF);\n\n  for (i = 0; i < opts.steps; i++, j++) {\n    if (j == opts.steps) {\n      j = 0;\n    }\n\n    mesh.addFace(south[i], north[i], south[j], undefined, undefined, undefined, undefined);\n    mesh.addFace(south[j], north[i], north[j], undefined, undefined, undefined, undefined);\n\n    if (opts.bottomClosed) {\n      mesh.addFace(p, south[i], south[j], undefined, undefined, undefined, undefined);\n    }\n\n    if (opts.topClosed) {\n      mesh.addFace(north[i], q, north[j], undefined, undefined, undefined, undefined);\n    }\n  }\n\n  return mesh;\n};\n\nmodule.exports = Cone;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/geom/Cone.js"],"names":["extend","require","Vec3D","TriangleMesh","err","param","Error","Cone","pos","dir","rNorth","rSouth","len","self","arguments","length","process","position","direction","radiusNorth","radiusSouth","apply","getNormalized","prototype","toMesh","args","opts","mesh","undefined","steps","NaN","thetaOffset","topClosed","bottomClosed","optionsObject","resolution","res","c","add","n","cross","normalize","halfAxis","scale","p","sub","q","south","north","phi","Math","PI","i","j","theta","nr","getRotatedAroundAxis","addSelf","numV","numF","addFace","module","exports"],"mappings":"AAEA,IAAIA,MAAM,GAAGC,OAAO,CAAC,cAAD,CAAP,CAAwBD,MAArC;AAAA,IACCE,KAAK,GAAGD,OAAO,CAAC,SAAD,CADhB;AAAA,IAECE,YAAY,GAAGF,OAAO,CAAC,qBAAD,CAFvB;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAEA,SAASG,GAAT,CAAcC,KAAd,EAAqB;AACpB,QAAMC,KAAK,CAAC,wBAAwBD,KAAzB,CAAX;AACA;;AACD,IAAIE,IAAI,GAAG,UAASC,GAAT,EAAaC,GAAb,EAAiBC,MAAjB,EAAyBC,MAAzB,EAAgCC,GAAhC,EAAqC;AAC/C;AACA,MAAIC,IAAI,GAAG,IAAX;;AACA,MAAK,OAAOL,GAAP,KAAe,QAAf,IAA2BM,SAAS,CAACC,MAAV,KAAqB,CAArD,EAAwD;AACvDC,IAAAA,OAAO,CACNR,GAAG,CAACA,GAAJ,IAAWA,GAAG,CAACS,QAAf,IAA2B,IAAIf,KAAJ,EADrB,EAENM,GAAG,CAACC,GAAJ,IAAWD,GAAG,CAACU,SAAf,IAA4Bd,GAAG,CAAE,WAAF,CAFzB,EAGNI,GAAG,CAACE,MAAJ,IAAcF,GAAG,CAACW,WAAlB,IAAiCf,GAAG,CAAC,aAAD,CAH9B,EAINI,GAAG,CAACG,MAAJ,IAAcH,GAAG,CAACY,WAAlB,IAAiChB,GAAG,CAAC,aAAD,CAJ9B,EAKNI,GAAG,CAACI,GAAJ,IAAWJ,GAAG,CAACO,MAAf,IAAyBX,GAAG,CAAC,QAAD,CALtB,CAAP;AAOA,GARD,MAQO;AACNY,IAAAA,OAAO,CAAER,GAAF,EAAOC,GAAP,EAAYC,MAAZ,EAAoBC,MAApB,EAA4BC,GAA5B,CAAP;AACA;;AACD,WAASI,OAAT,CAAkBR,GAAlB,EAAuBC,GAAvB,EAA4BU,WAA5B,EAAyCC,WAAzC,EAAsDL,MAAtD,EAA8D;AAC7Db,IAAAA,KAAK,CAACmB,KAAN,CAAYR,IAAZ,EAAiB,CAACL,GAAD,CAAjB;AACAK,IAAAA,IAAI,CAACJ,GAAL,GAAWA,GAAG,CAACa,aAAJ,EAAX;AACAT,IAAAA,IAAI,CAACM,WAAL,GAAmBA,WAAnB;AACAN,IAAAA,IAAI,CAACO,WAAL,GAAmBA,WAAnB;AACAP,IAAAA,IAAI,CAACE,MAAL,GAAcA,MAAd;AACA;AACD,CArBD;;AAuBAf,MAAM,CAACO,IAAD,EAAML,KAAN,CAAN;;AAEAK,IAAI,CAACgB,SAAL,CAAeC,MAAf,GAAwB,UAASC,IAAT,EAAe;AACtC,MAAIC,IAAI,GAAG;AACVC,IAAAA,IAAI,EAAGC,SADG;AAEVC,IAAAA,KAAK,EAAGC,GAFE;AAGVC,IAAAA,WAAW,EAAG,CAHJ;AAIVC,IAAAA,SAAS,EAAG,IAJF;AAKVC,IAAAA,YAAY,EAAG;AALL,GAAX;;AASA,MAAKnB,SAAS,CAACC,MAAV,IAAoB,CAAzB,EAA4B;AAC3B,QAAI,OAAOD,SAAS,CAAC,CAAD,CAAhB,IAAuB,QAA3B,EAAqC;AACpC;AACA,UAAIoB,aAAa,GAAGpB,SAAS,CAAC,CAAD,CAA7B;AACAY,MAAAA,IAAI,CAACC,IAAL,GAAYO,aAAa,CAACP,IAA1B;AACAD,MAAAA,IAAI,CAACG,KAAL,GAAaK,aAAa,CAACL,KAAd,IAAuBK,aAAa,CAACC,UAArC,IAAmDD,aAAa,CAACE,GAA9E;AACAV,MAAAA,IAAI,CAACK,WAAL,GAAmBG,aAAa,CAACH,WAAd,IAA6BL,IAAI,CAACK,WAArD;AACAL,MAAAA,IAAI,CAACM,SAAL,GAAiBE,aAAa,CAACF,SAAd,IAA2BN,IAAI,CAACM,SAAjD;AACAN,MAAAA,IAAI,CAACO,YAAL,GAAoBC,aAAa,CAACD,YAAd,IAA8BP,IAAI,CAACO,YAAvD;AACA,KARD,MAQO;AACNP,MAAAA,IAAI,CAACG,KAAL,GAAaf,SAAS,CAAC,CAAD,CAAtB;AACA;AACD,GAZD,MAaK,IAAKA,SAAS,CAACC,MAAV,IAAoB,CAAzB,EAA6B;AACjCW,IAAAA,IAAI,CAACG,KAAL,GAAaf,SAAS,CAAC,CAAD,CAAtB;AACAY,IAAAA,IAAI,CAACK,WAAL,GAAmBjB,SAAS,CAAC,CAAD,CAA5B;AACA,GAHI,MAIA,IAAKA,SAAS,CAACC,MAAV,IAAoB,CAAzB,EAA6B;AACjCW,IAAAA,IAAI,CAACC,IAAL,GAAYb,SAAS,CAAC,CAAD,CAArB;AACAY,IAAAA,IAAI,CAACG,KAAL,GAAaf,SAAS,CAAC,CAAD,CAAtB;AACAY,IAAAA,IAAI,CAACK,WAAL,GAAmBjB,SAAS,CAAC,CAAD,CAA5B;AACAY,IAAAA,IAAI,CAACM,SAAL,GAAiBlB,SAAS,CAAC,CAAD,CAA1B;AACAY,IAAAA,IAAI,CAACO,YAAL,GAAoBnB,SAAS,CAAC,CAAD,CAA7B;AACA;;AAED,MAAIuB,CAAC,GAAG,KAAKC,GAAL,CAAS,IAAT,EAAe,IAAf,EAAqB,IAArB,CAAR;AAAA,MACCC,CAAC,GAAGF,CAAC,CAACG,KAAF,CAAQ,KAAK/B,GAAL,CAASa,aAAT,EAAR,EAAkCmB,SAAlC,EADL;AAAA,MAECC,QAAQ,GAAG,KAAKjC,GAAL,CAASkC,KAAT,CAAe,KAAK5B,MAAL,GAAc,GAA7B,CAFZ;AAAA,MAGC6B,CAAC,GAAG,KAAKC,GAAL,CAASH,QAAT,CAHL;AAAA,MAICI,CAAC,GAAG,KAAKR,GAAL,CAASI,QAAT,CAJL;AAAA,MAKCK,KAAK,GAAG,EALT;AAAA,MAMCC,KAAK,GAAG,EANT;AAAA,MAOCC,GAAG,GAAIC,IAAI,CAACC,EAAL,GAAQ,CAAT,GAAczB,IAAI,CAACG,KAP1B;AAUA,MAAIuB,CAAC,GAAG,CAAR;AAAA,MAAWC,CAAC,GAAC,CAAb;;AACA,OAAID,CAAC,GAAC,CAAN,EAAQA,CAAC,GAAC1B,IAAI,CAACG,KAAf,EAAqBuB,CAAC,EAAtB,EAAyB;AACxB,QAAIE,KAAK,GAAGF,CAAC,GAAGH,GAAJ,GAAUvB,IAAI,CAACK,WAA3B;AACA,QAAIwB,EAAE,GAAGhB,CAAC,CAACiB,oBAAF,CAAuB,KAAK/C,GAA5B,EAAgC6C,KAAhC,CAAT;AAEAP,IAAAA,KAAK,CAACK,CAAD,CAAL,GAAWG,EAAE,CAACZ,KAAH,CAAS,KAAKvB,WAAd,EAA2BqC,OAA3B,CAAmCb,CAAnC,CAAX;AACAI,IAAAA,KAAK,CAACI,CAAD,CAAL,GAAWG,EAAE,CAACZ,KAAH,CAAS,KAAKxB,WAAd,EAA2BsC,OAA3B,CAAmCX,CAAnC,CAAX;AACA;;AAGD,MAAIY,IAAI,GAAGhC,IAAI,CAACG,KAAL,GAAa,CAAb,GAAiB,CAA5B;AAAA,MACC8B,IAAI,GAAGjC,IAAI,CAACG,KAAL,GAAa,CAAb,IAAkBH,IAAI,CAACM,SAAL,GAAiBN,IAAI,CAACG,KAAtB,GAA8B,CAAhD,KAAsDH,IAAI,CAACO,YAAL,GAAoBP,IAAI,CAACG,KAAzB,GAAiC,CAAvF,CADR;AAAA,MAECF,IAAI,GAAGD,IAAI,CAACC,IAAL,IAAa,IAAIxB,YAAJ,CAAiB,MAAjB,EAAwBuD,IAAxB,EAA6BC,IAA7B,CAFrB;;AAIA,OAAIP,CAAC,GAAC,CAAN,EAASA,CAAC,GAAC1B,IAAI,CAACG,KAAhB,EAAuBuB,CAAC,IAAIC,CAAC,EAA7B,EAAgC;AAC/B,QAAGA,CAAC,IAAI3B,IAAI,CAACG,KAAb,EAAmB;AAClBwB,MAAAA,CAAC,GAAG,CAAJ;AACA;;AACD1B,IAAAA,IAAI,CAACiC,OAAL,CAAab,KAAK,CAACK,CAAD,CAAlB,EAAsBJ,KAAK,CAACI,CAAD,CAA3B,EAA+BL,KAAK,CAACM,CAAD,CAApC,EAAwCzB,SAAxC,EAAkDA,SAAlD,EAA4DA,SAA5D,EAAsEA,SAAtE;AACAD,IAAAA,IAAI,CAACiC,OAAL,CAAab,KAAK,CAACM,CAAD,CAAlB,EAAsBL,KAAK,CAACI,CAAD,CAA3B,EAA+BJ,KAAK,CAACK,CAAD,CAApC,EAAwCzB,SAAxC,EAAkDA,SAAlD,EAA4DA,SAA5D,EAAsEA,SAAtE;;AACA,QAAGF,IAAI,CAACO,YAAR,EAAqB;AACpBN,MAAAA,IAAI,CAACiC,OAAL,CAAahB,CAAb,EAAgBG,KAAK,CAACK,CAAD,CAArB,EAA0BL,KAAK,CAACM,CAAD,CAA/B,EAAoCzB,SAApC,EAA8CA,SAA9C,EAAwDA,SAAxD,EAAkEA,SAAlE;AACA;;AACD,QAAGF,IAAI,CAACM,SAAR,EAAkB;AACjBL,MAAAA,IAAI,CAACiC,OAAL,CAAaZ,KAAK,CAACI,CAAD,CAAlB,EAAuBN,CAAvB,EAA0BE,KAAK,CAACK,CAAD,CAA/B,EAAoCzB,SAApC,EAA8CA,SAA9C,EAAwDA,SAAxD,EAAkEA,SAAlE;AACA;AACD;;AAED,SAAOD,IAAP;AACA,CA1ED;;AA4EAkC,MAAM,CAACC,OAAP,GAAiBvD,IAAjB","sourcesContent":["\n\nvar extend = require('../internals').extend,\n\tVec3D = require('./Vec3D'),\n\tTriangleMesh = require('./mesh/TriangleMesh');\n\n/**\n * @class A geometric definition of a cone (and cylinder as a special case) with\n * support for mesh creation/representation. The class is currently still\n * incomplete in that it doesn't provide any other features than the\n * construction of a cone shaped mesh.\n * @augments toxi.Vec3D\n * @member toxi\n * @param pos\n *            centre position\n * @param dir\n *            direction vector\n * @param rNorth\n *            radius on the side in the forward direction\n * @param rSouth\n *            radius on the side in the opposite direction\n * @param len\n *            length of the cone\n */\n\nfunction err( param ){\n\tthrow Error(\"Missing parameter: \" + param);\n}\nvar\tCone = function(pos,dir,rNorth, rSouth,len) {\n\t//if its a parameter object\n\tvar self = this;\n\tif ( typeof pos === 'object' && arguments.length === 1 ){\n\t\tprocess(\n\t\t\tpos.pos || pos.position || new Vec3D(),\n\t\t\tpos.dir || pos.direction || err( \"direction\" ),\n\t\t\tpos.rNorth || pos.radiusNorth || err(\"radiusNorth\"),\n\t\t\tpos.rSouth || pos.radiusSouth || err(\"radiusSouth\"),\n\t\t\tpos.len || pos.length || err(\"length\")\n\t\t);\n\t} else {\n\t\tprocess( pos, dir, rNorth, rSouth, len );\n\t}\n\tfunction process( pos, dir, radiusNorth, radiusSouth, length ){\n\t\tVec3D.apply(self,[pos]);\n\t\tself.dir = dir.getNormalized();\n\t\tself.radiusNorth = radiusNorth;\n\t\tself.radiusSouth = radiusSouth;\n\t\tself.length = length;\n\t}\n};\n\nextend(Cone,Vec3D);\n\nCone.prototype.toMesh = function(args) {\n\tvar opts = {\n\t\tmesh : undefined,\n\t\tsteps : NaN,\n\t\tthetaOffset : 0,\n\t\ttopClosed : true,\n\t\tbottomClosed : true\n\t};\n\t\n\t\t\n\tif ( arguments.length == 1) {\n\t\tif (typeof arguments[0] == 'object') {\n\t\t\t//##then it was a javascript option-object\n\t\t\tvar optionsObject = arguments[0];\n\t\t\topts.mesh = optionsObject.mesh;\n\t\t\topts.steps = optionsObject.steps || optionsObject.resolution || optionsObject.res;\n\t\t\topts.thetaOffset = optionsObject.thetaOffset || opts.thetaOffset;\n\t\t\topts.topClosed = optionsObject.topClosed || opts.topClosed;\n\t\t\topts.bottomClosed = optionsObject.bottomClosed || opts.bottomClosed;\n\t\t} else {\n\t\t\topts.steps = arguments[0];\n\t\t}\n\t}\n\telse if ( arguments.length == 2 ) {\n\t\topts.steps = arguments[0];\n\t\topts.thetaOffset = arguments[1];\n\t}\n\telse if ( arguments.length == 5 ) {\n\t\topts.mesh = arguments[0];\n\t\topts.steps = arguments[1];\n\t\topts.thetaOffset = arguments[2];\n\t\topts.topClosed = arguments[3];\n\t\topts.bottomClosed = arguments[4];\n\t}\n\t\n\tvar c = this.add(0.01, 0.01, 0.01),\n\t\tn = c.cross(this.dir.getNormalized()).normalize(),\n\t\thalfAxis = this.dir.scale(this.length * 0.5),\n\t\tp = this.sub(halfAxis),\n\t\tq = this.add(halfAxis),\n\t\tsouth = [],\n\t\tnorth = [],\n\t\tphi = (Math.PI*2) / opts.steps;\n\t\n\t\n\tvar i = 0, j=1;\n\tfor(i=0;i<opts.steps;i++){\n\t\tvar theta = i * phi + opts.thetaOffset;\n\t\tvar nr = n.getRotatedAroundAxis(this.dir,theta);\n\t\t\t\n\t\tsouth[i] = nr.scale(this.radiusSouth).addSelf(p);\n\t\tnorth[i] = nr.scale(this.radiusNorth).addSelf(q);\n\t}\n\t\n\t\n\tvar numV = opts.steps * 2 + 2,\n\t\tnumF = opts.steps * 2 + (opts.topClosed ? opts.steps : 0) + (opts.bottomClosed ? opts.steps : 0),\n\t\tmesh = opts.mesh || new TriangleMesh(\"cone\",numV,numF);\n\n\tfor(i=0; i<opts.steps; i++, j++){\n\t\tif(j == opts.steps){\n\t\t\tj = 0;\n\t\t}\n\t\tmesh.addFace(south[i],north[i],south[j],undefined,undefined,undefined,undefined);\n\t\tmesh.addFace(south[j],north[i],north[j],undefined,undefined,undefined,undefined);\n\t\tif(opts.bottomClosed){\n\t\t\tmesh.addFace(p, south[i], south[j], undefined,undefined,undefined,undefined);\n\t\t}\n\t\tif(opts.topClosed){\n\t\t\tmesh.addFace(north[i], q, north[j], undefined,undefined,undefined,undefined);\n\t\t}\n\t}\n\t\n\treturn mesh;\n};\n\nmodule.exports = Cone;\n\n\n"]},"metadata":{},"sourceType":"script"}