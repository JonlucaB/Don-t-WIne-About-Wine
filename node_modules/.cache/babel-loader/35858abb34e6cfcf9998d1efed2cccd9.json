{"ast":null,"code":"var TriangleMesh, WETriangleMesh, Terrain, SurfaceMeshBuilder;\nvar precision = 1000000;\n\nvar format = function (n) {\n  return Math.floor(n * precision) / precision;\n}; //private: way of generating object keys for point map in meshes\n\n\nfunction vertexKeyGenerator(v) {\n  //this will hold the ids consistently between vertex and vec3ds\n  return \"[ x: \" + format(v.x) + \", y: \" + format(v.y) + \", z: \" + format(v.z) + \"]\";\n} //private: used for tracking edges in the internals.LinkedMap\n\n\nfunction edgeKeyGenerator(edge) {\n  return edge.a.id + '->' + edge.b.id;\n} //#TriangleMesh\n\n\n(function () {\n  var internals = require('../../internals'),\n      mathUtils = require('../../math/mathUtils'),\n      Matrix4x4 = require('../Matrix4x4'),\n      Face = require('./Face'),\n      Vec3D = require('../Vec3D'),\n      Triangle3D = require('../Triangle3D'),\n      TriangleIntersector = require('../TriangleIntersector'),\n      Quaternion = require('../Quaternion'),\n      Vertex = require('./Vertex');\n  /**\n   * @class\n   * @member toxi\n   */\n  //java TriangleMesh constructor is (name, numVertices, numFaces)\n  //numVertices, numFaces is irrelevant with js arrays\n\n\n  TriangleMesh = function (name) {\n    if (name === undefined) name = \"untitled\";\n    this.init(name);\n    return this;\n  };\n\n  TriangleMesh.__vertexKeyGenerator = vertexKeyGenerator; //statics\n\n  TriangleMesh.DEFAULT_NUM_VERTICES = 1000;\n  TriangleMesh.DEFAULT_NUM_FACES = 3000;\n  TriangleMesh.DEFAULT_STRIDE = 4;\n  TriangleMesh.prototype = {\n    /**\n     * add a Face to the mesh\n     * @param {Vec3D} a\n     * @param {Vec3D} b\n     * @param {Vec3D} c\n     * @param {Vec3D} [n] the normal\n     * @param {Vec2D} [uvA]\n     * @param {Vec2D} [uvB]\n     * @param {Vec2D} [uvC]\n     * @returns itself\n     */\n    addFace: function (a, b, c, n, uvA, uvB, uvC) {\n      //can be 3 args, 4 args, 6 args, or 7 args\n      //if it was 6 swap vars around,\n      if (arguments.length == 6) {\n        uvC = uvB;\n        uvB = uvA;\n        uvA = n;\n        n = undefined;\n      } //7 param method\n\n\n      var va = this.__checkVertex(a);\n\n      var vb = this.__checkVertex(b);\n\n      var vc = this.__checkVertex(c);\n\n      if (va.id === vb.id || va.id === vc.id || vb.id === vc.id) {//console.log(\"ignoring invalid face: \"+a + \", \" +b+ \", \"+c);\n      } else {\n        if (n != null) {\n          var nc = va.sub(vc).crossSelf(va.sub(vb));\n\n          if (n.dot(nc) < 0) {\n            var t = va;\n            va = vb;\n            vb = t;\n          }\n        }\n\n        var f = new Face(va, vb, vc, uvA, uvB, uvC);\n        this.faces.push(f);\n      }\n\n      return this;\n    },\n\n    /**\n     * add the contents of a TriangleMesh to this TriangleMesh\n     * @param {TriangleMesh} m\n     * @returns itself\n     */\n    addMesh: function (m) {\n      var l = m.getFaces().length;\n\n      for (var i = 0; i < l; i++) {\n        var f = m.getFaces()[i];\n        this.addFace(f.a, f.b, f.c);\n      }\n\n      return this;\n    },\n    center: function (origin) {\n      this.computeCentroid();\n      var delta = origin != null ? origin.sub(this.centroid) : this.centroid.getInverted();\n      var l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = this.vertices[i];\n        v.addSelf(delta);\n      }\n\n      return this.getBoundingBox();\n    },\n    __checkVertex: function (v) {\n      var vertex = this.vertexMap.get(v);\n\n      if (!vertex) {\n        vertex = this._createVertex(v, this.uniqueVertexID++);\n        this.vertexMap.put(vertex, vertex);\n      }\n\n      return vertex;\n    },\n    clear: function () {\n      this.vertexMap = new internals.LinkedMap(vertexKeyGenerator);\n      this.vertices = this.vertexMap.getArray();\n      this.faces = [];\n      this.bounds = undefined;\n      return this;\n    },\n    computeCentroid: function () {\n      this.centroid.clear();\n      var l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        this.centroid.addSelf(this.vertices[i]);\n      }\n\n      return this.centroid.scaleSelf(1.0 / this.vertexMap.size()).copy();\n    },\n    computeFaceNormals: function () {\n      var l = this.faces.length;\n\n      for (var i = 0; i < l; i++) {\n        this.faces[i].computeNormal();\n      }\n    },\n    computeVertexNormals: function () {\n      var l = this.vertices.length,\n          i = 0;\n\n      for (i = 0; i < l; i++) {\n        this.vertices[i].clearNormal();\n      }\n\n      l = this.faces.length;\n\n      for (i = 0; i < l; i++) {\n        var f = this.faces[i];\n        f.a.addFaceNormal(f.normal);\n        f.b.addFaceNormal(f.normal);\n        f.c.addFaceNormal(f.normal);\n      }\n\n      l = this.vertices.length;\n\n      for (i = 0; i < l; i++) {\n        this.vertices[i].computeNormal();\n      }\n\n      return this;\n    },\n    copy: function () {\n      var m = new TriangleMesh(this.name + \"-copy\", this.vertexMap.size(), this.faces.length);\n      var l = this.faces.length;\n\n      for (var i = 0; i < l; i++) {\n        var f = this.faces[i];\n        m.addFace(f.a, f.b, f.c, f.normal, f.uvA, f.uvB, f.uvC);\n      }\n\n      return m;\n    },\n    _createVertex: function (vec3D, id) {\n      var vertex = new Vertex(vec3D, id);\n      return vertex;\n    },\n    faceOutwards: function () {\n      this.computeCentroid();\n      var l = this.faces.length;\n\n      for (var i = 0; i < l; i++) {\n        var f = this.faces[i];\n        var n = f.getCentroid().sub(this.centroid);\n        var dot = n.dot(f.normal);\n\n        if (dot < 0) {\n          f.flipVertexOrder();\n        }\n      }\n\n      return this;\n    },\n    flipVertexOrder: function () {\n      var l = this.faces.length,\n          tuv;\n\n      for (var i = 0; i < l; i++) {\n        var f = this.faces[i];\n        var t = f.a;\n        f.a = f.b;\n        f.b = t;\n\n        if (f.uvA) {\n          tuv = f.uvA;\n          f.uvA = f.uvB;\n          f.uvB = tuv;\n        }\n\n        f.normal.invert();\n      }\n\n      return this;\n    },\n    flipYAxis: function () {\n      this.transform(new Matrix4x4().scaleSelf(1, -1, 1));\n      this.flipVertexOrder();\n      return this;\n    },\n    getBoundingBox: function () {\n      var AABB = require('../AABB');\n\n      var self = this;\n      var minBounds = Vec3D.MAX_VALUE.copy();\n      var maxBounds = Vec3D.MIN_VALUE.copy();\n      var l = self.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = self.vertices[i];\n        minBounds.minSelf(v);\n        maxBounds.maxSelf(v);\n      }\n\n      self.bounds = AABB.fromMinMax(minBounds, maxBounds);\n      return self.bounds;\n    },\n    getBoundingSphere: function () {\n      var Sphere = require('../Sphere');\n\n      var radius = 0;\n      this.computeCentroid();\n      var l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = this.vertices[i];\n        radius = mathUtils.max(radius, v.distanceToSquared(this.centroid));\n      }\n\n      var sph = new Sphere(this.centroid, Math.sqrt(radius));\n      return sph;\n    },\n    getClosestVertexToPoint: function (p) {\n      var closest,\n          minDist = Number.MAX_VALUE,\n          l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = this.vertices[i];\n        var d = v.distanceToSquared(p);\n\n        if (d < minDist) {\n          closest = v;\n          minDist = d;\n        }\n      }\n\n      return closest;\n    },\n\n    /**\n     * Creates an array of unravelled normal coordinates. For each vertex the\n     * normal vector of its parent face is used. This method can be used to\n     * translate the internal mesh data structure into a format suitable for\n     * OpenGL Vertex Buffer Objects (by choosing stride=4). For more detail,\n     * please see {@link #getMeshAsVertexArray(float[], int, int)}\n     *\n     * @see #getMeshAsVertexArray(float[], int, int)\n     *\n     * @param normals existing float array or null to automatically create one\n     * @param offset start index in array to place normals\n     * @param stride stride/alignment setting for individual coordinates (min value = 3)\n     * @return array of xyz normal coords\n     */\n    getFaceNormalsAsArray: function (normals, offset, stride) {\n      if (arguments.length === 0) {\n        normals = undefined;\n        offset = 0;\n        stride = TriangleMesh.DEFAULT_STRIDE;\n      } else if (arguments.length == 1 && typeof arguments[0] == 'object') {\n        //options object\n        var opts = arguments[0];\n        normals = opts.normals;\n        offset = opts.offset;\n        stride = opts.stride;\n      }\n\n      stride = mathUtils.max(stride, 3);\n\n      if (normals === undefined) {\n        normals = [];\n      }\n\n      var i = offset;\n      var l = this.faces.length;\n\n      for (var j = 0; j < l; j++) {\n        var f = this.faces[j];\n        normals[i] = f.normal.x;\n        normals[i + 1] = f.normal.y;\n        normals[i + 2] = f.normal.z;\n        i += stride;\n        normals[i] = f.normal.x;\n        normals[i + 1] = f.normal.y;\n        normals[i + 2] = f.normal.z;\n        i += stride;\n        normals[i] = f.normal.x;\n        normals[i + 1] = f.normal.y;\n        normals[i + 2] = f.normal.z;\n        i += stride;\n      }\n\n      return normals;\n    },\n    getFaces: function () {\n      return this.faces;\n    },\n\n    /**\n     * Builds an array of vertex indices of all faces. Each vertex ID\n     * corresponds to its position in the vertices Array. The\n     * resulting array will be 3 times the face count.\n     * please see {@link #getUniqueVerticesAsArray([array])}\n              * and {@link #getUniqueVertexNormalsAsArray([array])}\n     *\n     * @see #getUniqueVerticesAsArray([array])\n              * @see #getUniqueVertexNormalsAsArray([array])\n     *\n              * @param {Array|Unit16Array} [faceList] optionally provide an array or typed-array\n     * @return array of vertex indices\n     */\n    getFacesAsArray: function (faceList) {\n      faceList = faceList || [];\n      var i = 0;\n      var l = this.faces.length;\n\n      for (var j = 0; j < l; j++) {\n        var f = this.faces[j];\n        faceList[i++] = f.a.id;\n        faceList[i++] = f.b.id;\n        faceList[i++] = f.c.id;\n      }\n\n      return faceList;\n    },\n    getIntersectionData: function () {\n      return this.intersector.getIntersectionData();\n    },\n\n    /**\n     * Creates an array of unravelled vertex coordinates for all faces. This\n     * method can be used to translate the internal mesh data structure into a\n     * format suitable for OpenGL Vertex Buffer Objects (by choosing stride=4).\n     * The order of the array will be as follows:\n     *\n     * <ul>\n     * <li>Face 1:\n     * <ul>\n     * <li>Vertex #1\n     * <ul>\n     * <li>x</li>\n     * <li>y</li>\n     * <li>z</li>\n     * <li>[optional empty indices to match stride setting]</li>\n     * </ul>\n     * </li>\n     * <li>Vertex #2\n     * <ul>\n     * <li>x</li>\n     * <li>y</li>\n     * <li>z</li>\n     * <li>[optional empty indices to match stride setting]</li>\n     * </ul>\n     * </li>\n     * <li>Vertex #3\n     * <ul>\n     * <li>x</li>\n     * <li>y</li>\n     * <li>z</li>\n     * <li>[optional empty indices to match stride setting]</li>\n     * </ul>\n     * </li>\n     * </ul>\n     * <li>Face 2:\n     * <ul>\n     * <li>Vertex #1</li>\n     * <li>...etc.</li>\n     * </ul>\n     * </ul>\n     *\n     * @param verts  an existing target array or null to automatically create one\n     * @param offset start index in arrtay to place vertices\n     * @param stride stride/alignment setting for individual coordinates\n     * @return array of xyz vertex coords\n     */\n    getMeshAsVertexArray: function (verts, offset, stride) {\n      if (verts === undefined) {\n        verts = undefined;\n      }\n\n      if (offset === undefined) {\n        offset = 0;\n      }\n\n      if (stride === undefined) {\n        stride = TriangleMesh.DEFAULT_STRIDE;\n      }\n\n      stride = mathUtils.max(stride, 3);\n\n      if (verts === undefined) {\n        verts = [];\n      }\n\n      var i = 0,\n          //offset\n      l = this.faces.length;\n\n      for (var j = 0; j < l; ++j) {\n        var f = this.faces[j];\n        verts[i] = f.a.x;\n        verts[i + 1] = f.a.y;\n        verts[i + 2] = f.a.z;\n        i += stride;\n        verts[i] = f.b.x;\n        verts[i + 1] = f.b.y;\n        verts[i + 2] = f.b.z;\n        i += stride;\n        verts[i] = f.c.x;\n        verts[i + 1] = f.c.y;\n        verts[i + 2] = f.c.z;\n        i += stride;\n      }\n\n      return verts;\n    },\n    getNumFaces: function () {\n      return this.faces.length;\n    },\n    getNumVertices: function () {\n      return this.vertexMap.size();\n    },\n    getRotatedAroundAxis: function (axis, theta) {\n      return this.copy().rotateAroundAxis(axis, theta);\n    },\n    getRotatedX: function (theta) {\n      return this.copy().rotateX(theta);\n    },\n    getRotatedY: function (theta) {\n      return this.copy().rotateY(theta);\n    },\n    getRotatedZ: function (theta) {\n      return this.copy().rotateZ(theta);\n    },\n    getScaled: function (scale) {\n      return this.copy().scale(scale);\n    },\n    getTranslated: function (trans) {\n      return this.copy().translate(trans);\n    },\n\n    /**\n     * flatten each vertex once into an array, useful for OpenGL attributes\n     * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n     * @return {Array|Float32Array}\n     */\n    getUniqueVerticesAsArray: function (array) {\n      array = array || [];\n      var i = 0;\n      var l = this.vertices.length;\n\n      for (var j = 0; j < l; j++) {\n        var v = this.vertices[j];\n        array[i++] = v.x;\n        array[i++] = v.y;\n        array[i++] = v.z;\n      }\n\n      return array;\n    },\n\n    /**\n     * flatten each vertex normal once into an array, useful for OpenGL attributes\n     * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n     * @return {Array|Float32Array}\n     */\n    getUniqueVertexNormalsAsArray: function (array) {\n      array = array || [];\n      var n = 0;\n\n      for (i = 0; i < this.vertices.length; i++) {\n        var v = this.vertices[i];\n        array[n++] = v.normal.x;\n        array[n++] = v.normal.y;\n        array[n++] = v.normal.z;\n      }\n\n      return array;\n    },\n\n    /**\n     * get the UVs of all faces in flattened array that is, usefl for OpenGL attributes\n     * any missing UV coordinates are returned as 0\n     * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n     * @return {Array|Float32Array}\n     */\n    getUVsAsArray: function (array) {\n      array = array || [];\n      var i = 0;\n\n      for (f = 0; f < this.faces.length; f++) {\n        var face = this.faces[f];\n        array[i++] = face.uvA ? face.uvA.x : 0;\n        array[i++] = face.uvA ? face.uvA.y : 0;\n        array[i++] = face.uvB ? face.uvB.x : 0;\n        array[i++] = face.uvB ? face.uvB.y : 0;\n        array[i++] = face.uvC ? face.uvC.x : 0;\n        array[i++] = face.uvC ? face.uvC.y : 0;\n      }\n\n      return array;\n    },\n    getVertexAtPoint: function (v) {\n      var index;\n\n      for (var i = 0; i < this.vertices.length; i++) {\n        if (this.vertices[i].equals(v)) {\n          index = i;\n        }\n      }\n\n      return this.vertices[index];\n    },\n    //my own method to help\n    getVertexIndex: function (vec) {\n      var matchedVertex = -1;\n      var l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var vert = this.vertices[i];\n\n        if (vert.equals(vec)) {\n          matchedVertex = i;\n        }\n      }\n\n      return matchedVertex;\n    },\n    getVertexForID: function (id) {\n      var vertex,\n          l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = this.vertices[i];\n\n        if (v.id == id) {\n          vertex = v;\n          break;\n        }\n      }\n\n      return vertex;\n    },\n\n    /**\n     * Creates an array of unravelled vertex normal coordinates for all faces.\n     * This method can be used to translate the internal mesh data structure\n     * into a format suitable for OpenGL Vertex Buffer Objects (by choosing\n     * stride=4). For more detail, please see\n     * {@link #getMeshAsVertexArray(float[], int, int)}\n     *\n     * @see #getMeshAsVertexArray(float[], int, int)\n     *\n     * @param normals existing float array or null to automatically create one\n     * @param offset start index in array to place normals\n     * @param stride stride/alignment setting for individual coordinates (min value\n     *            = 3)\n     * @return array of xyz normal coords\n     */\n    getVertexNormalsAsArray: function (normals, offset, stride) {\n      if (offset === undefined) offset = 0;\n      if (stride === undefined) stride = TriangleMesh.DEFAULT_STRIDE;\n      stride = mathUtils.max(stride, 3);\n\n      if (normals === undefined) {\n        normals = [];\n      }\n\n      var i = offset;\n      var l = this.faces.length;\n\n      for (var j = 0; j < l; j++) {\n        var f = this.faces[j];\n        normals[i] = f.a.normal.x;\n        normals[i + 1] = f.a.normal.y;\n        normals[i + 2] = f.a.normal.z;\n        i += stride;\n        normals[i] = f.b.normal.x;\n        normals[i + 1] = f.b.normal.y;\n        normals[i + 2] = f.b.normal.z;\n        i += stride;\n        normals[i] = f.c.normal.x;\n        normals[i + 1] = f.c.normal.y;\n        normals[i + 2] = f.c.normal.z;\n        i += stride;\n      }\n\n      return normals;\n    },\n    getVertices: function () {\n      return this.vertices;\n    },\n    handleSaveAsSTL: function (stl, useFlippedY) {\n      /*f (useFlippedY) {\n      \tstl.setScale(new Vec3D(1, -1, 1));\n      \tfor (Face f : faces) {\n      \t\tstl.face(f.a, f.b, f.c, f.normal, STLWriter.DEFAULT_RGB);\n      \t}\n      } else {\n      \tfor (Face f : faces) {\n      \t\tstl.face(f.b, f.a, f.c, f.normal, STLWriter.DEFAULT_RGB);\n      \t}\n      }\n      stl.endSave();\n      console.log(numFaces + \" faces written\");\n      */\n      throw new Error(\"TriangleMesh.handleSaveAsSTL() currently not implemented\");\n    },\n    init: function (name) {\n      this.setName(name);\n      this.matrix = new Matrix4x4();\n      this.centroid = new Vec3D();\n      this.vertexMap = new internals.LinkedMap(vertexKeyGenerator); //used for checking if theres an existing Vertex\n\n      this.vertices = this.vertexMap.getArray();\n      this.faces = [];\n      this.uniqueVertexID = 0;\n      this.intersector = new TriangleIntersector();\n    },\n    intersectsRay: function (ray) {\n      var tri = this.intersector.getTriangle();\n      var l = this.faces.length;\n      var f;\n\n      for (var i = 0; i < l; i++) {\n        f = this.faces[i];\n        tri.a = f.a;\n        tri.b = f.b;\n        tri.c = f.c;\n\n        if (this.intersector.intersectsRay(ray)) {\n          return true;\n        }\n      }\n\n      return false;\n    },\n    perforateFace: function (f, size) {\n      var centroid = f.getCentroid();\n      var d = 1 - size;\n      var a2 = f.a.interpolateTo(centroid, d);\n      var b2 = f.b.interpolateTo(centroid, d);\n      var c2 = f.c.interpolateTo(centroid, d);\n      this.removeFace(f);\n      this.addFace(f.a, b2, a2);\n      this.addFace(f.a, f.b, b2);\n      this.addFace(f.b, c2, b2);\n      this.addFace(f.b, f.c, c2);\n      this.addFace(f.c, a2, c2);\n      this.addFace(f.c, f.a, a2);\n      return new Triangle3D(a2, b2, c2);\n    },\n\n    /**\n     * Rotates the mesh in such a way so that its \"forward\" axis is aligned with\n     * the given direction. This version uses the positive Z-axis as default\n     * forward direction.\n     *\n     * @param dir, new target direction to point in\n     * @param [forward], optional vector, defaults to Vec3D.Z_AXIS\n     * @return itself\n     */\n    pointTowards: function (dir, forward) {\n      forward = forward || Vec3D.Z_AXIS;\n      return this.transform(Quaternion.getAlignmentQuat(dir, forward).toMatrix4x4(this.matrix), true);\n    },\n    removeFace: function (f) {\n      var index = -1;\n      var l = this.faces.length;\n\n      for (var i = 0; i < l; i++) {\n        if (this.faces[i] == f) {\n          index = i;\n          break;\n        }\n      }\n\n      if (index > -1) {\n        this.faces.splice(index, 1);\n      }\n    },\n    rotateAroundAxis: function (axis, theta) {\n      return this.transform(this.matrix.identity().rotateAroundAxis(axis, theta));\n    },\n    rotateX: function (theta) {\n      return this.transform(this.matrix.identity().rotateX(theta));\n    },\n    rotateY: function (theta) {\n      return this.transform(this.matrix.identity().rotateY(theta));\n    },\n    rotateZ: function (theta) {\n      return this.transform(this.matrix.identity().rotateZ(theta));\n    },\n    saveAsOBJ: function (obj, saveNormals) {\n      if (saveNormals === undefined) {\n        saveNormals = true;\n      }\n\n      var vOffset = obj.getCurrVertexOffset() + 1,\n          nOffset = obj.getCurrNormalOffset() + 1;\n      obj.newObject(this.name); //vertices\n\n      var v = 0,\n          f = 0,\n          vlen = this.vertices.length,\n          flen = this.faces.length,\n          face;\n\n      for (v = 0; v < vlen; v++) {\n        obj.vertex(this.vertices[v]);\n      } //faces\n\n\n      if (saveNormals) {\n        //normals\n        for (v = 0; v < vlen; v++) {\n          obj.normal(this.vertices[v].normal);\n        }\n\n        for (f = 0; f < flen; f++) {\n          face = this.faces[f];\n          obj.faceWithNormals(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset, face.b.id + nOffset, face.a.id + nOffset, face.c.id + nOffset);\n        }\n      } else {\n        for (f = 0; f < flen; f++) {\n          face = this.faces[f];\n          obj.face(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset);\n        }\n      }\n    },\n    saveAsSTL: function (a, b, c) {\n      throw new Error(\"TriangleMesh.saveAsSTL() currently not implemented\");\n    },\n    scale: function (scale) {\n      return this.transform(this.matrix.identity().scaleSelf(scale));\n    },\n    setName: function (name) {\n      this.name = name;\n      return this;\n    },\n    toString: function () {\n      return \"TriangleMesh: \" + this.name + \" vertices: \" + this.getNumVertices() + \" faces: \" + this.getNumFaces();\n    },\n    toWEMesh: function () {\n      return new WETriangleMesh(this.name).addMesh(this);\n    },\n\n    /**\n    * Applies the given matrix transform to all mesh vertices. If the\n    * updateNormals flag is true, all face normals are updated automatically,\n    * however vertex normals need a manual update.\n    * @param mat\n    * @param updateNormals\n    * @return itself\n    */\n    transform: function (mat, updateNormals) {\n      if (updateNormals === undefined) {\n        updateNormals = true;\n      }\n\n      var l = this.vertices.length;\n\n      for (var i = 0; i < l; i++) {\n        var v = this.vertices[i];\n        v.set(mat.applyTo(v));\n      }\n\n      if (updateNormals) {\n        this.computeFaceNormals();\n      }\n\n      return this;\n    },\n    translate: function (x, y, z) {\n      if (arguments.length == 1) {\n        y = x.y;\n        z = x.z;\n        x = x.x;\n      }\n\n      return this.transform(this.matrix.identity().translateSelf(x, y, z));\n    },\n    updateVertex: function (origVec3D, newPos) {\n      var vertex = this.vertexMap.get(origVec3D);\n\n      if (vertex !== undefined) {\n        this.vertexMap.remove(vertex);\n        vertex.set(newPos);\n        this.vertexMap.put(newPos, vertex);\n      }\n\n      return this;\n    }\n  };\n})(); //define WETriangleMesh\n\n\n(function (TriangleMesh) {\n  //dependenecies\n  var internals = require('../../internals');\n\n  var Line3D = require('../Line3D');\n\n  var Vec3D = require('../Vec3D');\n\n  var WEVertex = require('./Vertex').WEVertex;\n\n  var WEFace = require('./Face').WEFace;\n\n  var WingedEdge = require('./WingedEdge');\n\n  var MidpointSubdivision = require('./subdiv/MidpointSubdivision'); //locals\n\n\n  var proto; //constructor\n\n  WETriangleMesh = function (name) {\n    name = name || \"untitled\";\n    TriangleMesh.call(this, name);\n  }; //passing these on to match java api\n\n\n  WETriangleMesh.DEFAULT_NUM_FACES = TriangleMesh.DEFAULT_NUM_FACES;\n  WETriangleMesh.DEFAULT_NUM_VERTICES = TriangleMesh.DEFAULT_NUM_VERTICES;\n  internals.extend(WETriangleMesh, TriangleMesh);\n  proto = WETriangleMesh.prototype;\n\n  proto.addFace = function (a, b, c, norm, uvA, uvB, uvC) {\n    if (arguments.length === 6) {\n      //6-arg a,b,c,uvA,uvB,uvC pass everything up one\n      uvC = uvB;\n      uvB = uvA;\n      uvA = norm;\n      norm = undefined;\n    }\n\n    var va = this.__checkVertex(a),\n        vb = this.__checkVertex(b),\n        vc = this.__checkVertex(c),\n        nc,\n        t,\n        f;\n\n    if (va.id === vb.id || va.id === vc.id || vb.id === vc.id) {\n      console.log('Ignoring invalid face: ' + a + ',' + b + ',' + c);\n    } else {\n      if (norm !== undefined && norm !== null) {\n        nc = va.sub(vc).crossSelf(va.sub(vb));\n\n        if (norm.dot(nc) < 0) {\n          t = va;\n          va = vb;\n          vb = t;\n        }\n      }\n\n      f = new WEFace(va, vb, vc, uvA, uvB, uvC);\n      this.faces.push(f);\n      this.updateEdge(va, vb, f);\n      this.updateEdge(vb, vc, f);\n      this.updateEdge(vc, va, f);\n    }\n\n    return this;\n  };\n\n  proto.center = function (origin, callback) {\n    TriangleMesh.prototype.center.call(this, origin, callback);\n    this.rebuildIndex();\n  };\n\n  proto.clear = function () {\n    TriangleMesh.prototype.clear.call(this);\n    this.edgeMap = new internals.LinkedMap(edgeKeyGenerator);\n    this.edges = this.edgeMap.getArray();\n    return this;\n  };\n\n  proto.copy = function () {\n    var m = new WETriangleMesh(this.name + \"-copy\");\n    var i, l, f;\n    l = this.faces.length;\n\n    for (i = 0; i < l; i++) {\n      f = this.faces[i];\n      m.addFace(f.a, f.b, f.c, f.normal, f.uvA, f.uvB, f.uvC);\n    }\n\n    return m;\n  };\n\n  proto._createVertex = function (vec3D, id) {\n    var vertex = new WEVertex(vec3D, id);\n    return vertex;\n  }; //TODO: numEdges currently not hooked up\n\n\n  proto.getNumEdges = function () {\n    return this.edgeMap.size();\n  };\n\n  proto.init = function (name) {\n    TriangleMesh.prototype.init.call(this, name); //this.edgeMap.put(va.toString()+vb.toString(), {WingedEdge} );\n\n    this.edgeMap = new internals.LinkedMap(edgeKeyGenerator);\n    this.edges = this.edgeMap.getArray();\n    this.__edgeCheck = new Line3D(new Vec3D(), new Vec3D());\n    this.__uniqueEdgeID = 0;\n  };\n\n  proto.rebuildIndex = function () {\n    //if vertices have moved / transformed a new vertexMap and edgeMap must be made\n    //in order to have updated string keys of new positions\n    //newVertexDictionary[{String}] = {Vertex}\n    var newVertexMap = new internals.LinkedMap(vertexKeyGenerator);\n    var newEdgeMap = new internals.LinkedMap(edgeKeyGenerator);\n    var i = 0,\n        arr = this.vertexMap.getArray();\n\n    for (i = 0; i < arr.length; i++) {\n      newVertexMap.put(arr[i], arr[i]);\n    }\n\n    arr = this.edgeMap.getArray();\n\n    for (i = 0; i < arr.length; i++) {\n      newEdgeMap.put(arr[i], arr[i]);\n    }\n\n    this.vertexMap = newVertexMap;\n    this.vertices = newVertexMap.getArray();\n    this.edgeMap = newEdgeMap;\n    this.edges = newEdgeMap.getArray();\n  };\n\n  proto.removeEdge = function (edge) {\n    edge.remove();\n    var v = edge.a;\n\n    if (v.edges.length === 0) {\n      this.vertexMap.remove(v);\n    }\n\n    v = edge.b;\n\n    if (v.edges.length === 0) {\n      this.vertexMap.remove(v);\n    }\n\n    for (var i = 0; i < edge.faces.length; i++) {\n      this.removeFace(edge.faces[i]);\n    }\n\n    var removed = this.edgeMap.remove(this.__edgeCheck.set(edge.a, edge.b));\n\n    if (!removed) {\n      this.edgeMap.remove(this.__edgeCheck.set(edge.b, edge.a));\n    }\n\n    if (removed !== edge) {\n      throw new Error(\"Can't remove edge\");\n    }\n  };\n\n  proto.removeFace = function (face) {\n    var i = this.faces.indexOf(face);\n\n    if (i > -1) {\n      this.faces.splice(i, 1);\n    }\n\n    i = 0;\n    var edge;\n\n    for (i = 0; i < face.edges.length; i++) {\n      edge = face.edges[i];\n      edge.faces.splice(edge.faces.indexOf(face), 1);\n\n      if (edge.faces.length === 0) {\n        this.removeEdge(edge);\n      }\n    }\n  }; //FIXME (FIXME in original java source)\n  //TODO UNIT TEST .splice\n\n\n  proto.removeUnusedVertices = function () {\n    internals.each(this.vertices, function (vertex, i) {\n      var isUsed = false;\n      internals.each(this.faces, function (f) {\n        if (f.a == vertex || f.b == vertex || f.c == vertex) {\n          isUsed = true;\n          return;\n        }\n      });\n\n      if (!isUsed) {\n        this.vertices.splice(i, 1);\n      }\n    });\n  };\n  /**\n  * @param {Vertex[] | Vertex{}} selection, array or object of Vertex's to remove\n  */\n\n\n  proto.removeVertices = function (selection) {\n    internals.each(selection, function (vertex) {\n      //WingedEdgeVertex\n      internals.each(vertex.edges, function (edge) {\n        internals.each(edge.faces, function (face) {\n          this.removeFace(face);\n        });\n      });\n    });\n  }; //@param {Vec3D | WingedEdge} a or edge\n  //@param {Vec3D | SubdivisionStrategy} b or strategy if edge supplied\n  //@param {SubdivisionStrategy} [subDiv] or undefined\n\n\n  proto.splitEdge = function (a, b, subDiv) {\n    var edge, mid;\n\n    if (arguments.length === 3) {\n      edge = this.edgeMap.get(this.__edgeCheck.set(a, b));\n\n      if (!edge) {\n        this.edgeMap.get(this.__edgeCheck.set(b, a));\n      }\n    } else if (arguments.length == 2) {\n      edge = a;\n      subDiv = b;\n    }\n\n    mid = subDiv.computeSplitPoints(edge);\n    this.splitFace(edge.faces[0], edge, mid);\n\n    if (edge.faces.length > 1) {\n      this.splitFace(edge.faces[1], edge, mid);\n    }\n\n    this.removeEdge(edge);\n  }; //@param {WEFace} face,\n  //@param {WingedEdge} edge,\n  //@param {Vec3D[]} midPoints\n\n\n  proto.splitFace = function (face, edge, midPoints) {\n    var p, i, ec, prev, num, mid;\n\n    for (i = 0; i < 3; i++) {\n      ec = face.edges[i];\n\n      if (!ec.equals(edge)) {\n        if (ec.a.equals(edge.a) || ec.a.equals(edge.b)) {\n          p = ec.b;\n        } else {\n          p = ec.a;\n        }\n\n        break;\n      }\n    }\n\n    num = midPoints.length;\n\n    for (i = 0; i < num; i++) {\n      mid = midPoints[i];\n\n      if (i === 0) {\n        this.addFace(p, edge.a, mid, face.normal);\n      } else {\n        this.addFace(p, prev, mid, face.normal);\n      }\n\n      if (i === num - 1) {\n        this.addFace(p, mid, edge.b, face.normal);\n      }\n\n      prev = mid;\n    }\n  }; //@param {SubdivisionStrategy | Number} subDiv or minLength\n  //@param {Number} [minLength] if also supplying subDiv\n\n\n  proto.subdivide = function (subDiv, minLength) {\n    if (arguments.length === 1) {\n      minLength = subDiv;\n      subDiv = new MidpointSubdivision();\n    }\n\n    this.subdivideEdges(this.edges.slice(0), subDiv, minLength);\n  };\n\n  proto.subdivideEdges = function (origEdges, subDiv, minLength) {\n    origEdges.sort(subDiv.getEdgeOrdering());\n    minLength *= minLength;\n    var i = 0,\n        l = origEdges.length;\n\n    for (i = 0; i < l; i++) {\n      var e = origEdges[i];\n\n      if (this.edges.indexOf(e) > -1) {\n        if (e.getLengthSquared() >= minLength) {\n          this.splitEdge(e, subDiv);\n        }\n      }\n    }\n  };\n\n  proto.subdivideFaceEdges = function (faces, subDiv, minLength) {\n    var fedges = [],\n        i,\n        j,\n        f,\n        e,\n        fl,\n        el;\n    fl = this.faces.length;\n\n    for (i = 0; i < fl; i++) {\n      f = this.faces[i];\n      el = f.edges.length;\n\n      for (j = 0; j < el; j++) {\n        e = f.edges[j];\n\n        if (fedges.indexOf(e) < 0) {\n          fedges.push(e);\n        }\n      }\n    }\n\n    this.subdividEdges(fedges, subDiv, minLength);\n  };\n\n  proto.toString = function () {\n    return \"WETriangleMesh: \" + this.name + \" vertices: \" + this.getNumVertices() + \" faces: \" + this.getNumFaces() + \" edges:\" + this.getNumEdges();\n  };\n  /**\n  * Applies the given matrix transform to all mesh vertices. If the\n  * updateNormals flag is true, all face normals are updated automatically,\n  * however vertex normals still need a manual update.\n  * @param {toxi.geom.Matrix4x4} matrix\n  * @param {Boolean} [updateNormals]\n  */\n\n\n  proto.transform = function (matrix, updateNormals) {\n    if (updateNormals === undefined || updateNormals === null) {\n      updateNormals = true;\n    }\n\n    for (var i = 0, l = this.vertices.length; i < l; i++) {\n      matrix.applyToSelf(this.vertices[i]);\n    }\n\n    this.rebuildIndex();\n\n    if (updateNormals) {\n      this.computeFaceNormals();\n    }\n\n    return this;\n  };\n\n  proto.updateEdge = function (va, vb, face) {\n    //dictionary key is va.toString() + vb.toString()\n    //because Line3D toString would be different than WingedEdge toString()\n    this.__edgeCheck.set(va, vb);\n\n    var e = this.edgeMap.get(this.__edgeCheck);\n\n    if (!e) {\n      //edge could be as b->a or a->b\n      this.__edgeCheck.set(vb, va);\n\n      e = this.edgeMap.get(this.__edgeCheck);\n    }\n\n    if (e !== undefined) {\n      e.addFace(face);\n    } else {\n      e = new WingedEdge(va, vb, face, this.__uniqueEdgeID++);\n      this.edgeMap.put(e, e);\n      va.addEdge(e);\n      vb.addEdge(e);\n    }\n\n    face.addEdge(e);\n  };\n})(TriangleMesh); //Terrain\n\n\n(function (TriangleMesh) {\n  var internals = require('../../internals'),\n      mathUtils = require('../../math/mathUtils'),\n      Interpolation2D = require('../../math/Interpolation2D'),\n      Ray3D = require('../Ray3D'),\n      TriangleIntersector = require('../TriangleIntersector'),\n      Triangle3D = require('../Triangle3D'),\n      IsectData3D = require('../IsectData3D'),\n      Vec2D = require('../vectors').Vec2D,\n      Vec3D = require('../vectors').Vec3D;\n  /**\n  * Constructs a new and initially flat terrain of the given size in the XZ\n  * plane, centred around the world origin.\n  *\n  * @param {Number} width\n  * @param {Number} depth\n  * @param {toxi.geom.Vec2D | Number} scale\n  */\n\n\n  Terrain = function (width, depth, scale) {\n    this.width = width;\n    this._depth = depth;\n\n    if (!internals.has.XY(scale)) {\n      scale = new Vec2D(scale, scale);\n    }\n\n    this.setScale(scale);\n    this.elevation = [];\n    var i = 0,\n        len = width * depth;\n\n    for (i = 0; i < len; i++) {\n      this.elevation[i] = 0;\n    }\n\n    this.__elevationLength = this.width * this._depth;\n    this.vertices = [];\n    var offset = new Vec3D(parseInt(this.width / 2, 10), 0, parseInt(this._depth / 2, 10)),\n        scaleXZ = this.getScale().to3DXZ();\n    i = 0;\n\n    for (var z = 0; z < this._depth; z++) {\n      for (var x = 0; x < this.width; x++) {\n        this.vertices[i++] = new Vec3D(x, 0, z).subSelf(offset).scaleSelf(scaleXZ);\n      }\n    }\n  };\n\n  Terrain.prototype = {\n    /**\n    * @return number of grid cells along the Z axis.\n    */\n    getDepth: function () {\n      return this._depth;\n    },\n    getElevation: function () {\n      return this.elevation;\n    },\n\n    /**\n    * @param {Number} x\n    * @param {Number} z\n    * @return the elevation at grid point\n    */\n    getHeightAtCell: function (x, z) {\n      //console.log(\"[\"+x+\",\"+z+\"]\");\n      return this.elevation[this._getIndex(x, z)];\n    },\n\n    /**\n    * Computes the elevation of the terrain at the given 2D world coordinate\n    * (based on current terrain scale).\n    *\n    * @param {Number} x scaled world coord x\n    * @param {Number} z scaled world coord z\n    * @return {Number} interpolated elevation\n    */\n    getHeightAtPoint: function (x, z) {\n      var xx = x / this._scale.x + this.width * 0.5,\n          zz = z / this._scale.y + this._depth * 0.5,\n          y = 0,\n          flxx = ~~x,\n          flzz = ~~zz;\n\n      if (xx >= 0 & xx < this.width && zz >= 0 && zz < this._depth) {\n        var x2 = ~~Math.min(xx + 1, this.width - 1),\n            z2 = ~~Math.min(zz + 1, this._depth - 1);\n        var a = this.getHeightAtCell(flxx, flzz),\n            b = this.getHeightAtCell(x2, flzz),\n            c = this.getHeightAtCell(flxx, z2),\n            d = this.getHeightAtCell(x2, z2);\n        y = Interpolation2D.bilinear(xx, zz, flxx, flzz, x2, z2, a, b, c, d);\n      }\n\n      return y;\n    },\n\n    /**\n    * Computes the array index for the given cell coords & checks if they're in\n    * bounds. If not an {@link IndexOutOfBoundsException} is thrown.\n    * @param {Number} x\n    * @param {Number} z\n    * @return {Number} array index\n    */\n    _getIndex: function (x, z) {\n      var idx = z * this.width + x;\n\n      if (idx < 0 || idx > this.__elevationLength) {\n        throw new Error(\"the given terrain cell is invalid: \" + x + \";\" + z);\n      }\n\n      return idx;\n    },\n\n    /**\n     * @return {Vec2D} the scale\n     */\n    getScale: function () {\n      return this._scale;\n    },\n    getVertexAtCell: function (x, z) {\n      return this.vertices[this._getIndex(x, z)];\n    },\n\n    /**\n     * @return {Number} number of grid cells along X axis\n     */\n    getWidth: function () {\n      return this.width;\n    },\n\n    /**\n    * Computes the 3D position (with elevation) and normal vector at the given\n    * 2D location in the terrain. The position is in scaled world coordinates\n    * based on the given terrain scale. The returned data is encapsulated in a\n    * {@link toxi.geom.IsectData3D} instance.\n    * @param {Number} x\n    * @param {Number} z\n    * @return {IsectData3D} intersection data parcel\n    */\n    intersectAtPoint: function (x, z) {\n      var xx = x / this._scale.x + this.width * 0.5,\n          zz = z / this._scale.y + this._depth * 0.5,\n          isec = new IsectData3D();\n\n      if (xx >= 0 && xx < this.width && zz >= 0 && zz < this._depth) {\n        var x2 = ~~Math.min(xx + 1, this.width - 1),\n            z2 = ~~Math.min(zz + 1, this._depth - 1),\n            flxx = ~~xx,\n            flzz = ~~zz,\n            a = this.getVertexAtCell(flxx, flzz),\n            b = this.getVertexAtCell(x2, flzz),\n            c = this.getVertexAtCell(x2, z2),\n            d = this.getVertexAtCell(flxx, z2),\n            r = new Ray3D(new Vec3D(x, 10000, z), new Vec3D(0, -1, 0)),\n            i = new TriangleIntersector(new Triangle3D(a, b, d));\n\n        if (i.intersectsRay(r)) {\n          isec = i.getIntersectionData();\n        } else {\n          i.setTriangle(new Triangle3D(b, c, d));\n          i.intersectsRay(r);\n          isec = i.getIntersectionData();\n        }\n      }\n\n      return isec;\n    },\n\n    /**\n    * Sets the elevation of all cells to those of the given array values.\n    * @param {Array} elevation array of height values\n    * @return itself\n    */\n    setElevation: function (elevation) {\n      if (this.__elevationLength == elevation.length) {\n        for (var i = 0, len = elevation.length; i < len; i++) {\n          this.vertices[i].y = this.elevation[i] = elevation[i];\n        }\n      } else {\n        throw new Error(\"the given elevation array size does not match terrain\");\n      }\n\n      return this;\n    },\n\n    /**\n    * Sets the elevation for a single given grid cell.\n    * @param {Number} x\n    * @param {Number} z\n    * @param {Number} h new elevation value\n    * @return itself\n    */\n    setHeightAtCell: function (x, z, h) {\n      var index = this._getIndex(x, z);\n\n      this.elevation[index] = h;\n      this.vertices[index].y = h;\n      return this;\n    },\n    setScale: function (scale) {\n      if (!internals.has.XY(scale)) {\n        scale = new Vec2D(scale, scale);\n      }\n\n      this._scale = scale;\n    },\n    toMesh: function () {\n      var opts = {\n        mesh: undefined,\n        minX: 0,\n        minZ: 0,\n        maxX: this.width,\n        maxZ: this._depth\n      };\n      var v = this.vertices,\n          w = this.width,\n          d = this._depth;\n\n      if (arguments.length == 1 && typeof arguments[0] == 'object') {\n        //options object\n        var args = arguments[0];\n        opts.mesh = args.mesh || new TriangleMesh(\"terrain\");\n        opts.minX = args.minX || opts.minX;\n        opts.minZ = args.minZ || opts.minZ;\n        opts.maxX = args.maxX || opts.maxX;\n        opts.maxZ = args.maxZ || opts.maxZ;\n      } else if (arguments.length >= 5) {\n        opts.mesh = arguments[0];\n        opts.minX = arguments[1];\n        opts.minZ = arguments[2];\n        opts.maxX = arguments[3];\n        opts.maxZ = arguments[4];\n      }\n\n      opts.mesh = opts.mesh || new TriangleMesh(\"terrain\");\n      opts.minX = mathUtils.clip(opts.minX, 0, w - 1);\n      opts.maxX = mathUtils.clip(opts.maxX, 0, w);\n      opts.minZ = mathUtils.clip(opts.minZ, 0, d - 1);\n      opts.maxZ = mathUtils.clip(opts.maxZ, 0, d);\n      opts.minX++;\n      opts.minZ++;\n\n      for (var z = opts.minZ, idx = opts.minX * w; z < opts.maxZ; z++, idx += w) {\n        for (var x = opts.minX; x < opts.maxX; x++) {\n          opts.mesh.addFace(v[idx - w + x - 1], v[idx - w + x], v[idx + x - 1]);\n          opts.mesh.addFace(v[idx - w + x], v[idx + x], v[idx + x - 1]);\n        }\n      }\n\n      return opts.mesh;\n    }\n  };\n})(TriangleMesh); //SurfaceMeshBuilder\n\n\n(function (TriangleMesh) {\n  var Vec3D = require('../Vec3D'),\n      Vec2D = require('../Vec2D');\n  /**\n   * @class An extensible builder class for {@link TriangleMesh}es based on 3D surface\n   * functions using spherical coordinates. In order to create mesh, you'll need\n   * to supply a {@link SurfaceFunction} implementation to the builder.\n   * @member toxi\n   */\n\n\n  SurfaceMeshBuilder = function (func) {\n    this.func = func;\n  };\n\n  SurfaceMeshBuilder.prototype = {\n    /*\n    \tcreate a mesh from a surface,\n    \tparameter options:\n    \t\t1 - Object options\n    \t\t1 - Number resolution\n    \t\t3 - TriangleMesh mesh, Number resolution, Number size\n    \t\t4 - TriangleMesh mesh, Number resolution, Number size, boolean isClosed\n    */\n    createMesh: function () {\n      var opts = {\n        mesh: undefined,\n        resolution: 0,\n        size: 1,\n        isClosed: true\n      };\n\n      if (arguments.length == 1) {\n        if (typeof arguments[0] == 'object') {\n          //options object\n          var arg = arguments[0]; //if a mesh was provided as an option, use it, otherwise make one\n\n          opts.mesh = arg.mesh;\n          opts.resolution = arg.res || arg.resoultion || 0;\n\n          if (arg.size !== undefined) {\n            opts.size = arg.size;\n          }\n\n          if (arg.isClosed !== undefined) {\n            opts.isClosed = arg.isClosed;\n          }\n        } else {\n          //resolution Number\n          opts.resolution = arguments[0];\n        }\n      } else if (arguments.length > 2) {\n        opts.mesh = arguments[0];\n        opts.resolution = arguments[1];\n        opts.size = arguments[2];\n\n        if (arguments.length == 4) {\n          opts.isClosed = arguments[3];\n        }\n      }\n\n      var mesh = opts.mesh;\n\n      if (mesh === undefined || mesh === null) {\n        mesh = new TriangleMesh();\n      }\n\n      var a = new Vec3D(),\n          b = new Vec3D(),\n          pa = new Vec3D(),\n          pb = new Vec3D(),\n          a0 = new Vec3D(),\n          b0 = new Vec3D(),\n          phiRes = this.func.getPhiResolutionLimit(opts.resolution),\n          phiRange = this.func.getPhiRange(),\n          thetaRes = this.func.getThetaResolutionLimit(opts.resolution),\n          thetaRange = this.func.getThetaRange(),\n          pres = 1.0 / phiRes,\n          //(1 == opts.resolution % 2 ? opts.resolution - 0 : opts.resolution);\n      tres = 1.0 / thetaRes,\n          ires = 1.0 / opts.resolution,\n          pauv = new Vec2D(),\n          pbuv = new Vec2D(),\n          auv = new Vec2D(),\n          buv = new Vec2D();\n\n      for (var p = 0; p < phiRes; p++) {\n        var phi = p * phiRange * ires;\n        var phiNext = (p + 1) * phiRange * ires;\n\n        for (var t = 0; t <= thetaRes; t++) {\n          var theta = t * thetaRange * ires;\n          var func = this.func;\n          a = func.computeVertexFor(a, phiNext, theta).scaleSelf(opts.size);\n          auv.set(t * tres, 1 - (p + 1) * pres);\n          b = func.computeVertexFor(b, phi, theta).scaleSelf(opts.size);\n          buv.set(t * tres, 1 - p * pres);\n\n          if (b.equalsWithTolerance(a, 0.0001)) {\n            b.set(a);\n          }\n\n          if (t > 0) {\n            if (t == thetaRes && opts.isClosed) {\n              a.set(a0);\n              b.set(b0);\n            }\n\n            mesh.addFace(pa, pb, a, pauv.copy(), pbuv.copy(), auv.copy());\n            mesh.addFace(pb, b, a, pbuv.copy(), buv.copy(), auv.copy());\n          } else {\n            a0.set(a);\n            b0.set(b);\n          }\n\n          pa.set(a);\n          pb.set(b);\n          pauv.set(auv);\n          pbuv.set(buv);\n        }\n      }\n\n      return mesh;\n    },\n\n    /**\n    @return the function\n    */\n    getFunction: function () {\n      return this.func;\n    },\n    setFunction: function (func) {\n      this.func = func;\n    }\n  };\n})(TriangleMesh);\n\nexports.TriangleMesh = TriangleMesh;\nexports.WETriangleMesh = WETriangleMesh;\nexports.Terrain = Terrain;\nexports.SurfaceMeshBuilder = SurfaceMeshBuilder;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/geom/mesh/meshCommon.js"],"names":["TriangleMesh","WETriangleMesh","Terrain","SurfaceMeshBuilder","precision","format","n","Math","floor","vertexKeyGenerator","v","x","y","z","edgeKeyGenerator","edge","a","id","b","internals","require","mathUtils","Matrix4x4","Face","Vec3D","Triangle3D","TriangleIntersector","Quaternion","Vertex","name","undefined","init","__vertexKeyGenerator","DEFAULT_NUM_VERTICES","DEFAULT_NUM_FACES","DEFAULT_STRIDE","prototype","addFace","c","uvA","uvB","uvC","arguments","length","va","__checkVertex","vb","vc","nc","sub","crossSelf","dot","t","f","faces","push","addMesh","m","l","getFaces","i","center","origin","computeCentroid","delta","centroid","getInverted","vertices","addSelf","getBoundingBox","vertex","vertexMap","get","_createVertex","uniqueVertexID","put","clear","LinkedMap","getArray","bounds","scaleSelf","size","copy","computeFaceNormals","computeNormal","computeVertexNormals","clearNormal","addFaceNormal","normal","vec3D","faceOutwards","getCentroid","flipVertexOrder","tuv","invert","flipYAxis","transform","AABB","self","minBounds","MAX_VALUE","maxBounds","MIN_VALUE","minSelf","maxSelf","fromMinMax","getBoundingSphere","Sphere","radius","max","distanceToSquared","sph","sqrt","getClosestVertexToPoint","p","closest","minDist","Number","d","getFaceNormalsAsArray","normals","offset","stride","opts","j","getFacesAsArray","faceList","getIntersectionData","intersector","getMeshAsVertexArray","verts","getNumFaces","getNumVertices","getRotatedAroundAxis","axis","theta","rotateAroundAxis","getRotatedX","rotateX","getRotatedY","rotateY","getRotatedZ","rotateZ","getScaled","scale","getTranslated","trans","translate","getUniqueVerticesAsArray","array","getUniqueVertexNormalsAsArray","getUVsAsArray","face","getVertexAtPoint","index","equals","getVertexIndex","vec","matchedVertex","vert","getVertexForID","getVertexNormalsAsArray","getVertices","handleSaveAsSTL","stl","useFlippedY","Error","setName","matrix","intersectsRay","ray","tri","getTriangle","perforateFace","a2","interpolateTo","b2","c2","removeFace","pointTowards","dir","forward","Z_AXIS","getAlignmentQuat","toMatrix4x4","splice","identity","saveAsOBJ","obj","saveNormals","vOffset","getCurrVertexOffset","nOffset","getCurrNormalOffset","newObject","vlen","flen","faceWithNormals","saveAsSTL","toString","toWEMesh","mat","updateNormals","set","applyTo","translateSelf","updateVertex","origVec3D","newPos","remove","Line3D","WEVertex","WEFace","WingedEdge","MidpointSubdivision","proto","call","extend","norm","console","log","updateEdge","callback","rebuildIndex","edgeMap","edges","getNumEdges","__edgeCheck","__uniqueEdgeID","newVertexMap","newEdgeMap","arr","removeEdge","removed","indexOf","removeUnusedVertices","each","isUsed","removeVertices","selection","splitEdge","subDiv","mid","computeSplitPoints","splitFace","midPoints","ec","prev","num","subdivide","minLength","subdivideEdges","slice","origEdges","sort","getEdgeOrdering","e","getLengthSquared","subdivideFaceEdges","fedges","fl","el","subdividEdges","applyToSelf","addEdge","Interpolation2D","Ray3D","IsectData3D","Vec2D","width","depth","_depth","has","XY","setScale","elevation","len","__elevationLength","parseInt","scaleXZ","getScale","to3DXZ","subSelf","getDepth","getElevation","getHeightAtCell","_getIndex","getHeightAtPoint","xx","_scale","zz","flxx","flzz","x2","min","z2","bilinear","idx","getVertexAtCell","getWidth","intersectAtPoint","isec","r","setTriangle","setElevation","setHeightAtCell","h","toMesh","mesh","minX","minZ","maxX","maxZ","w","args","clip","func","createMesh","resolution","isClosed","arg","res","resoultion","pa","pb","a0","b0","phiRes","getPhiResolutionLimit","phiRange","getPhiRange","thetaRes","getThetaResolutionLimit","thetaRange","getThetaRange","pres","tres","ires","pauv","pbuv","auv","buv","phi","phiNext","computeVertexFor","equalsWithTolerance","getFunction","setFunction","exports"],"mappings":"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","sourcesContent":["\n\n\tvar TriangleMesh, WETriangleMesh, Terrain, SurfaceMeshBuilder;\n\n    var precision = 1000000;\n    var format = function( n ){\n        return Math.floor(n*precision) / precision;\n    };\n\t//private: way of generating object keys for point map in meshes\n\tfunction vertexKeyGenerator( v ){\n\t\t//this will hold the ids consistently between vertex and vec3ds\n\t\treturn \"[ x: \"+format(v.x)+ \", y: \"+format(v.y)+ \", z: \"+format(v.z)+\"]\";\n\t}\n\t//private: used for tracking edges in the internals.LinkedMap\n\tfunction edgeKeyGenerator( edge ){\n        return edge.a.id + '->'+ edge.b.id;\n\t}\n\n\n\t//#TriangleMesh\n\t(function(){\n\t\tvar\tinternals = require('../../internals'),\n\t\t\tmathUtils = require('../../math/mathUtils'),\n\t\t\tMatrix4x4 = require('../Matrix4x4'),\n\t\t\tFace = require('./Face'),\n\t\t\tVec3D = require('../Vec3D'),\n\t\t\tTriangle3D = require('../Triangle3D'),\n            TriangleIntersector = require('../TriangleIntersector'),\n\t\t\tQuaternion = require('../Quaternion'),\n\t\t\tVertex = require('./Vertex');\n\n\t\t/**\n\t\t * @class\n\t\t * @member toxi\n\t\t */\n\t\t//java TriangleMesh constructor is (name, numVertices, numFaces)\n\t\t//numVertices, numFaces is irrelevant with js arrays\n\t\tTriangleMesh = function(name){\n\t\t\tif(name === undefined)name = \"untitled\";\n\t\t\tthis.init( name );\n\t\t\treturn this;\n\t\t};\n\n\t\tTriangleMesh.__vertexKeyGenerator = vertexKeyGenerator;\n\n\n\t\t//statics\n\t\tTriangleMesh.DEFAULT_NUM_VERTICES = 1000;\n\t\tTriangleMesh.DEFAULT_NUM_FACES = 3000;\n\t\tTriangleMesh.DEFAULT_STRIDE = 4;\n\n\t\tTriangleMesh.prototype = {\n            /**\n             * add a Face to the mesh\n             * @param {Vec3D} a\n             * @param {Vec3D} b\n             * @param {Vec3D} c\n             * @param {Vec3D} [n] the normal\n             * @param {Vec2D} [uvA]\n             * @param {Vec2D} [uvB]\n             * @param {Vec2D} [uvC]\n             * @returns itself\n             */\n\t\t\taddFace: function(a,b,c,n,uvA,uvB,uvC){\n\t\t\t\t//can be 3 args, 4 args, 6 args, or 7 args\n\t\t\t\t//if it was 6 swap vars around,\n\t\t\t\tif( arguments.length == 6 ){\n\t\t\t\t\tuvC = uvB;\n\t\t\t\t\tuvB = uvA;\n\t\t\t\t\tuvA = n;\n\t\t\t\t\tn = undefined;\n\t\t\t\t}\n\t\t\t\t//7 param method\n\t\t\t\tvar va = this.__checkVertex(a);\n\t\t\t\tvar vb = this.__checkVertex(b);\n\t\t\t\tvar vc = this.__checkVertex(c);\n\n\t\t\t\tif(va.id === vb.id || va.id === vc.id || vb.id === vc.id){\n\t\t\t\t\t//console.log(\"ignoring invalid face: \"+a + \", \" +b+ \", \"+c);\n\t\t\t\t} else {\n\t\t\t\t\tif(n != null ){\n\t\t\t\t\t\tvar nc = va.sub(vc).crossSelf(va.sub(vb));\n\t\t\t\t\t\tif(n.dot(nc)<0){\n\t\t\t\t\t\t\tvar t = va;\n\t\t\t\t\t\t\tva = vb;\n\t\t\t\t\t\t\tvb = t;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tvar f = new Face(va,vb,vc,uvA,uvB,uvC);\n\t\t\t\t\tthis.faces.push(f);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n            /**\n             * add the contents of a TriangleMesh to this TriangleMesh\n             * @param {TriangleMesh} m\n             * @returns itself\n             */\n\t\t\taddMesh: function(m){\n\t\t\t\tvar l = m.getFaces().length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar f = m.getFaces()[i];\n\t\t\t\t\tthis.addFace(f.a,f.b,f.c);\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tcenter: function(origin){\n\t\t\t\tthis.computeCentroid();\n\t\t\t\tvar delta = (origin != null) ? origin.sub(this.centroid) : this.centroid.getInverted();\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar v = this.vertices[i];\n\t\t\t\t\tv.addSelf(delta);\n\t\t\t\t}\n\n\t\t\t\treturn this.getBoundingBox();\n\t\t\t},\n\n\t\t\t__checkVertex: function(v){\n\t\t\t\tvar vertex = this.vertexMap.get(v);\n\t\t\t\tif(!vertex){\n\t\t\t\t\tvertex = this._createVertex(v,this.uniqueVertexID++);\n\t\t\t\t\tthis.vertexMap.put( vertex, vertex );\n\t\t\t\t}\n\t\t\t\treturn vertex;\n\t\t\t},\n\n\t\t\tclear: function(){\n\t\t\t\tthis.vertexMap = new internals.LinkedMap( vertexKeyGenerator );\n\t\t\t\tthis.vertices = this.vertexMap.getArray();\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.bounds = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tcomputeCentroid: function(){\n\t\t\t\tthis.centroid.clear();\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tthis.centroid.addSelf(this.vertices[i]);\n\t\t\t\t}\n\t\t\t\treturn this.centroid.scaleSelf(1.0/this.vertexMap.size()).copy();\n\t\t\t},\n\n\t\t\tcomputeFaceNormals: function(){\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tthis.faces[i].computeNormal();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tcomputeVertexNormals: function(){\n\t\t\t\tvar l = this.vertices.length,\n\t\t\t\t\ti = 0;\n\t\t\t\tfor(i=0;i<l;i++){\n\t\t\t\t\tthis.vertices[i].clearNormal();\n\t\t\t\t}\n\t\t\t\tl = this.faces.length;\n\t\t\t\tfor(i=0;i<l;i++){\n\t\t\t\t\tvar f = this.faces[i];\n\t\t\t\t\tf.a.addFaceNormal(f.normal);\n\t\t\t\t\tf.b.addFaceNormal(f.normal);\n\t\t\t\t\tf.c.addFaceNormal(f.normal);\n\t\t\t\t}\n\t\t\t\tl = this.vertices.length;\n\t\t\t\tfor(i=0;i<l;i++){\n\t\t\t\t\tthis.vertices[i].computeNormal();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tcopy: function(){\n\t\t\t\tvar m = new TriangleMesh(this.name+\"-copy\",this.vertexMap.size(),this.faces.length);\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar f = this.faces[i];\n\t\t\t\t\tm.addFace(f.a,f.b,f.c,f.normal,f.uvA,f.uvB,f.uvC);\n\t\t\t\t}\n\t\t\t\treturn m;\n\t\t\t},\n\n\t\t\t_createVertex: function(vec3D,id){\n\t\t\t\tvar vertex = new Vertex( vec3D, id );\n\t\t\t\treturn vertex;\n\t\t\t},\n\n\t\t\tfaceOutwards: function(){\n\t\t\t\tthis.computeCentroid();\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar f = this.faces[i];\n\t\t\t\t\tvar n = f.getCentroid().sub(this.centroid);\n\t\t\t\t\tvar dot = n.dot(f.normal);\n\t\t\t\t\tif(dot <0) {\n\t\t\t\t\t\tf.flipVertexOrder();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tflipVertexOrder: function(){\n\t\t\t\tvar l = this.faces.length,\n                    tuv;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar f = this.faces[i];\n\t\t\t\t\tvar t = f.a;\n\t\t\t\t\tf.a = f.b;\n\t\t\t\t\tf.b = t;\n                    if( f.uvA ){\n                        tuv = f.uvA;\n                        f.uvA = f.uvB;\n                        f.uvB = tuv;\n                    }\n\t\t\t\t\tf.normal.invert();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tflipYAxis: function(){\n\t\t\t\tthis.transform(new Matrix4x4().scaleSelf(1,-1,1));\n\t\t\t\tthis.flipVertexOrder();\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\tgetBoundingBox: function( ){\n\t\t\t\tvar AABB = require('../AABB');\n\t\t\t\tvar self = this;\n\t\t\t\tvar minBounds = Vec3D.MAX_VALUE.copy();\n\t\t\t\tvar maxBounds = Vec3D.MIN_VALUE.copy();\n\t\t\t\tvar l = self.vertices.length;\n\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar v = self.vertices[i];\n\t\t\t\t\tminBounds.minSelf(v);\n\t\t\t\t\tmaxBounds.maxSelf(v);\n\t\t\t\t}\n\t\t\t\tself.bounds = AABB.fromMinMax(minBounds,maxBounds);\n\t\t\t\treturn self.bounds;\n\t\t\t},\n\n\t\t\tgetBoundingSphere:function(){\n\t\t\t\tvar Sphere = require('../Sphere');\n\t\t\t\tvar radius = 0;\n\t\t\t\tthis.computeCentroid();\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar v = this.vertices[i];\n\t\t\t\t\tradius = mathUtils.max(radius,v.distanceToSquared(this.centroid));\n\t\t\t\t}\n\t\t\t\tvar sph = new Sphere(this.centroid,Math.sqrt(radius));\n\t\t\t\treturn sph;\n\t\t\t},\n\n\t\t\tgetClosestVertexToPoint: function(p){\n\t\t\t\tvar closest,\n\t\t\t\t\tminDist = Number.MAX_VALUE,\n\t\t\t\t\tl = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar v = this.vertices[i];\n\t\t\t\t\tvar d = v.distanceToSquared(p);\n\t\t\t\t\tif(d<minDist){\n\t\t\t\t\t\tclosest = v;\n\t\t\t\t\t\tminDist = d;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn closest;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates an array of unravelled normal coordinates. For each vertex the\n\t\t\t * normal vector of its parent face is used. This method can be used to\n\t\t\t * translate the internal mesh data structure into a format suitable for\n\t\t\t * OpenGL Vertex Buffer Objects (by choosing stride=4). For more detail,\n\t\t\t * please see {@link #getMeshAsVertexArray(float[], int, int)}\n\t\t\t *\n\t\t\t * @see #getMeshAsVertexArray(float[], int, int)\n\t\t\t *\n\t\t\t * @param normals existing float array or null to automatically create one\n\t\t\t * @param offset start index in array to place normals\n\t\t\t * @param stride stride/alignment setting for individual coordinates (min value = 3)\n\t\t\t * @return array of xyz normal coords\n\t\t\t */\n\t\t\tgetFaceNormalsAsArray: function(normals, offset, stride) {\n\t\t\t\tif(arguments.length === 0){\n\t\t\t\t\tnormals = undefined;\n\t\t\t\t\toffset = 0;\n\t\t\t\t\tstride = TriangleMesh.DEFAULT_STRIDE;\n\t\t\t\t} else if(arguments.length == 1 && typeof(arguments[0]) == 'object'){ //options object\n\t\t\t\t\tvar opts = arguments[0];\n\t\t\t\t\tnormals = opts.normals;\n\t\t\t\t\toffset = opts.offset;\n\t\t\t\t\tstride = opts.stride;\n\t\t\t\t}\n\t\t\t\tstride = mathUtils.max(stride, 3);\n\t\t\t\tif (normals === undefined) {\n\t\t\t\t\tnormals = [];\n\t\t\t\t}\n\t\t\t\tvar i = offset;\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor (var j=0;j<l;j++) {\n\t\t\t\t\tvar f = this.faces[j];\n\t\t\t\t\tnormals[i] = f.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tnormals[i] = f.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tnormals[i] = f.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t}\n\t\t\t\treturn normals;\n\t\t\t},\n\n\t\t\tgetFaces: function() {\n\t\t\t\treturn this.faces;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Builds an array of vertex indices of all faces. Each vertex ID\n\t\t\t * corresponds to its position in the vertices Array. The\n\t\t\t * resulting array will be 3 times the face count.\n\t\t\t * please see {@link #getUniqueVerticesAsArray([array])}\n             * and {@link #getUniqueVertexNormalsAsArray([array])}\n\t\t\t *\n\t\t\t * @see #getUniqueVerticesAsArray([array])\n             * @see #getUniqueVertexNormalsAsArray([array])\n\t\t\t *\n             * @param {Array|Unit16Array} [faceList] optionally provide an array or typed-array\n\t\t\t * @return array of vertex indices\n\t\t\t */\n\t\t\tgetFacesAsArray: function(faceList) {\n\t\t\t\tfaceList = faceList || [];\n\t\t\t\tvar i = 0;\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor (var j=0;j<l;j++) {\n\t\t\t\t\tvar f = this.faces[j];\n\t\t\t\t\tfaceList[i++] = f.a.id;\n\t\t\t\t\tfaceList[i++] = f.b.id;\n\t\t\t\t\tfaceList[i++] = f.c.id;\n\t\t\t\t}\n\t\t\t\treturn faceList;\n\t\t\t},\n\n\t\t\tgetIntersectionData: function() {\n\t\t\t\treturn this.intersector.getIntersectionData();\n\t\t\t},\n\n\n\t\t\t/**\n\t\t\t * Creates an array of unravelled vertex coordinates for all faces. This\n\t\t\t * method can be used to translate the internal mesh data structure into a\n\t\t\t * format suitable for OpenGL Vertex Buffer Objects (by choosing stride=4).\n\t\t\t * The order of the array will be as follows:\n\t\t\t *\n\t\t\t * <ul>\n\t\t\t * <li>Face 1:\n\t\t\t * <ul>\n\t\t\t * <li>Vertex #1\n\t\t\t * <ul>\n\t\t\t * <li>x</li>\n\t\t\t * <li>y</li>\n\t\t\t * <li>z</li>\n\t\t\t * <li>[optional empty indices to match stride setting]</li>\n\t\t\t * </ul>\n\t\t\t * </li>\n\t\t\t * <li>Vertex #2\n\t\t\t * <ul>\n\t\t\t * <li>x</li>\n\t\t\t * <li>y</li>\n\t\t\t * <li>z</li>\n\t\t\t * <li>[optional empty indices to match stride setting]</li>\n\t\t\t * </ul>\n\t\t\t * </li>\n\t\t\t * <li>Vertex #3\n\t\t\t * <ul>\n\t\t\t * <li>x</li>\n\t\t\t * <li>y</li>\n\t\t\t * <li>z</li>\n\t\t\t * <li>[optional empty indices to match stride setting]</li>\n\t\t\t * </ul>\n\t\t\t * </li>\n\t\t\t * </ul>\n\t\t\t * <li>Face 2:\n\t\t\t * <ul>\n\t\t\t * <li>Vertex #1</li>\n\t\t\t * <li>...etc.</li>\n\t\t\t * </ul>\n\t\t\t * </ul>\n\t\t\t *\n\t\t\t * @param verts  an existing target array or null to automatically create one\n\t\t\t * @param offset start index in arrtay to place vertices\n\t\t\t * @param stride stride/alignment setting for individual coordinates\n\t\t\t * @return array of xyz vertex coords\n\t\t\t */\n\t\t\tgetMeshAsVertexArray: function(verts, offset, stride) {\n\t\t\t\tif(verts ===undefined){\n\t\t\t\t\tverts = undefined;\n\t\t\t\t}\n\t\t\t\tif(offset === undefined){\n\t\t\t\t\toffset = 0;\n\t\t\t\t}\n\t\t\t\tif(stride === undefined){\n\t\t\t\t\tstride = TriangleMesh.DEFAULT_STRIDE;\n\t\t\t\t}\n\t\t\t\tstride = mathUtils.max(stride, 3);\n\t\t\t\tif (verts === undefined) {\n\t\t\t\t\tverts = [];\n\t\t\t\t}\n\t\t\t\tvar i = 0,//offset\n\t\t\t\t\tl = this.faces.length;\n\t\t\t\tfor (var j=0;j<l;++j) {\n\t\t\t\t\tvar f = this.faces[j];\n\t\t\t\t\tverts[i] = f.a.x;\n\t\t\t\t\tverts[i + 1] = f.a.y;\n\t\t\t\t\tverts[i + 2] = f.a.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tverts[i] = f.b.x;\n\t\t\t\t\tverts[i + 1] = f.b.y;\n\t\t\t\t\tverts[i + 2] = f.b.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tverts[i] = f.c.x;\n\t\t\t\t\tverts[i + 1] = f.c.y;\n\t\t\t\t\tverts[i + 2] = f.c.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t}\n\t\t\t\treturn verts;\n\t\t\t},\n\n\t\t\tgetNumFaces: function() {\n\t\t\t\treturn this.faces.length;\n\t\t\t},\n\n\t\t\tgetNumVertices: function() {\n\t\t\t\treturn this.vertexMap.size();\n\t\t\t},\n\n\t\t\tgetRotatedAroundAxis: function(axis,theta) {\n\t\t\t\treturn this.copy().rotateAroundAxis(axis, theta);\n\t\t\t},\n\n\t\t\tgetRotatedX: function(theta) {\n\t\t\t\treturn this.copy().rotateX(theta);\n\t\t\t},\n\n\t\t\tgetRotatedY: function(theta) {\n\t\t\t\treturn this.copy().rotateY(theta);\n\t\t\t},\n\n\t\t\tgetRotatedZ: function(theta) {\n\t\t\t\treturn this.copy().rotateZ(theta);\n\t\t\t},\n\n\t\t\tgetScaled: function(scale) {\n\t\t\t\treturn this.copy().scale(scale);\n\t\t\t},\n\n\t\t\tgetTranslated: function(trans) {\n\t\t\t\treturn this.copy().translate(trans);\n\t\t\t},\n\n            /**\n             * flatten each vertex once into an array, useful for OpenGL attributes\n             * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n             * @return {Array|Float32Array}\n             */\n\t\t\tgetUniqueVerticesAsArray: function(array) {\n\t\t\t\tarray = array || [];\n\t\t\t\tvar i = 0;\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor (var j=0;j<l;j++) {\n\t\t\t\t\tvar v = this.vertices[j];\n\t\t\t\t\tarray[i++] = v.x;\n\t\t\t\t\tarray[i++] = v.y;\n\t\t\t\t\tarray[i++] = v.z;\n\t\t\t\t}\n\t\t\t\treturn array;\n\t\t\t},\n\n            /**\n             * flatten each vertex normal once into an array, useful for OpenGL attributes\n             * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n             * @return {Array|Float32Array}\n             */\n            getUniqueVertexNormalsAsArray: function(array){\n                array = array || [];\n                var n = 0;\n                for(i=0; i<this.vertices.length; i++){\n                    var v = this.vertices[i];\n                    array[n++] = v.normal.x;\n                    array[n++] = v.normal.y;\n                    array[n++] = v.normal.z;\n                }\n\n                return array;\n            },\n\n            /**\n             * get the UVs of all faces in flattened array that is, usefl for OpenGL attributes\n             * any missing UV coordinates are returned as 0\n             * @param {Array|Float32Array} [array] optionally pass in an array or typed-array to reuse\n             * @return {Array|Float32Array}\n             */\n            getUVsAsArray: function(array){\n                array = array || [];\n                var i = 0;\n                for(f=0; f<this.faces.length; f++){\n                    var face = this.faces[f];\n                    array[i++] = face.uvA ? face.uvA.x : 0;\n                    array[i++] = face.uvA ? face.uvA.y : 0;\n                    array[i++] = face.uvB ? face.uvB.x : 0;\n                    array[i++] = face.uvB ? face.uvB.y : 0;\n                    array[i++] = face.uvC ? face.uvC.x : 0;\n                    array[i++] = face.uvC ? face.uvC.y : 0;\n                }\n\n                return array;\n            },\n\n\t\t\tgetVertexAtPoint: function(v) {\n\t\t\t\tvar index;\n\t\t\t\tfor(var i=0;i<this.vertices.length;i++){\n\t\t\t\t\tif(this.vertices[i].equals(v)){\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this.vertices[index];\n\t\t\t},\n\t\t\t//my own method to help\n\t\t\tgetVertexIndex: function(vec) {\n\t\t\t\tvar matchedVertex = -1;\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++)\n\t\t\t\t{\n\t\t\t\t\tvar vert = this.vertices[i];\n\t\t\t\t\tif(vert.equals(vec))\n\t\t\t\t\t{\n\t\t\t\t\t\tmatchedVertex =i;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn matchedVertex;\n\n\t\t\t},\n\n\t\t\tgetVertexForID: function(id) {\n\t\t\t\tvar vertex,\n\t\t\t\t\tl = this.vertices.length;\n\t\t\t\tfor (var i=0;i<l;i++) {\n\t\t\t\t\tvar v = this.vertices[i];\n\t\t\t\t\tif (v.id == id) {\n\t\t\t\t\t\tvertex = v;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn vertex;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Creates an array of unravelled vertex normal coordinates for all faces.\n\t\t\t * This method can be used to translate the internal mesh data structure\n\t\t\t * into a format suitable for OpenGL Vertex Buffer Objects (by choosing\n\t\t\t * stride=4). For more detail, please see\n\t\t\t * {@link #getMeshAsVertexArray(float[], int, int)}\n\t\t\t *\n\t\t\t * @see #getMeshAsVertexArray(float[], int, int)\n\t\t\t *\n\t\t\t * @param normals existing float array or null to automatically create one\n\t\t\t * @param offset start index in array to place normals\n\t\t\t * @param stride stride/alignment setting for individual coordinates (min value\n\t\t\t *            = 3)\n\t\t\t * @return array of xyz normal coords\n\t\t\t */\n\t\t\tgetVertexNormalsAsArray: function(normals, offset,stride) {\n\t\t\t\tif(offset === undefined)offset = 0;\n\t\t\t\tif(stride === undefined)stride = TriangleMesh.DEFAULT_STRIDE;\n\t\t\t\tstride = mathUtils.max(stride, 3);\n\t\t\t\tif (normals === undefined) {\n\t\t\t\t\tnormals = [];\n\t\t\t\t}\n\t\t\t\tvar i = offset;\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor (var j=0;j<l;j++) {\n\t\t\t\t\tvar f = this.faces[j];\n\t\t\t\t\tnormals[i] = f.a.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.a.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.a.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tnormals[i] = f.b.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.b.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.b.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t\tnormals[i] = f.c.normal.x;\n\t\t\t\t\tnormals[i + 1] = f.c.normal.y;\n\t\t\t\t\tnormals[i + 2] = f.c.normal.z;\n\t\t\t\t\ti += stride;\n\t\t\t\t}\n\t\t\t\treturn normals;\n\t\t\t},\n\n\t\t\tgetVertices: function() {\n\t\t\t\treturn this.vertices;\n\t\t\t},\n\n\t\t\thandleSaveAsSTL: function(stl,useFlippedY) {\n\t\t\t\t/*f (useFlippedY) {\n\t\t\t\t\tstl.setScale(new Vec3D(1, -1, 1));\n\t\t\t\t\tfor (Face f : faces) {\n\t\t\t\t\t\tstl.face(f.a, f.b, f.c, f.normal, STLWriter.DEFAULT_RGB);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor (Face f : faces) {\n\t\t\t\t\t\tstl.face(f.b, f.a, f.c, f.normal, STLWriter.DEFAULT_RGB);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tstl.endSave();\n\t\t\t\tconsole.log(numFaces + \" faces written\");\n\t\t\t\t*/\n\t\t\t\tthrow new Error(\"TriangleMesh.handleSaveAsSTL() currently not implemented\");\n\n\t\t\t},\n\n\t\t\tinit: function( name ){\n\t\t\t\tthis.setName(name);\n\t\t\t\tthis.matrix = new Matrix4x4();\n\t\t\t\tthis.centroid = new Vec3D();\n\t\t\t\tthis.vertexMap = new internals.LinkedMap( vertexKeyGenerator );\n\t\t\t\t//used for checking if theres an existing Vertex\n\t\t\t\tthis.vertices = this.vertexMap.getArray();\n\t\t\t\tthis.faces = [];\n\t\t\t\tthis.uniqueVertexID = 0;\n                this.intersector = new TriangleIntersector();\n\t\t\t},\n\n\t\t\tintersectsRay: function(ray) {\n\t\t\t\tvar tri = this.intersector.getTriangle();\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tvar f;\n\t\t\t\tfor (var i =0;i<l;i++) {\n\t\t\t\t\tf = this.faces[i];\n\t\t\t\t\ttri.a = f.a;\n\t\t\t\t\ttri.b = f.b;\n\t\t\t\t\ttri.c = f.c;\n\t\t\t\t\tif (this.intersector.intersectsRay(ray)) {\n\t\t\t\t\t\treturn true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn false;\n\t\t\t},\n\n\t\t\tperforateFace: function(f, size) {\n\t\t\t\tvar centroid = f.getCentroid();\n\t\t\t\tvar d = 1 - size;\n\t\t\t\tvar a2 = f.a.interpolateTo(centroid, d);\n\t\t\t\tvar b2 = f.b.interpolateTo(centroid, d);\n\t\t\t\tvar c2 = f.c.interpolateTo(centroid, d);\n\t\t\t\tthis.removeFace(f);\n\t\t\t\tthis.addFace(f.a, b2, a2);\n\t\t\t\tthis.addFace(f.a, f.b, b2);\n\t\t\t\tthis.addFace(f.b, c2, b2);\n\t\t\t\tthis.addFace(f.b, f.c, c2);\n\t\t\t\tthis.addFace(f.c, a2, c2);\n\t\t\t\tthis.addFace(f.c, f.a, a2);\n\t\t\t\treturn new Triangle3D(a2, b2, c2);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Rotates the mesh in such a way so that its \"forward\" axis is aligned with\n\t\t\t * the given direction. This version uses the positive Z-axis as default\n\t\t\t * forward direction.\n\t\t\t *\n\t\t\t * @param dir, new target direction to point in\n\t\t\t * @param [forward], optional vector, defaults to Vec3D.Z_AXIS\n\t\t\t * @return itself\n\t\t\t */\n\t\t\tpointTowards: function(dir, forward) {\n\t\t\t\tforward = forward || Vec3D.Z_AXIS;\n\t\t\t\treturn this.transform( Quaternion.getAlignmentQuat(dir, forward).toMatrix4x4(this.matrix), true);\n\t\t\t},\n\n\t\t\tremoveFace: function(f) {\n\t\t\t\tvar index = -1;\n\t\t\t\tvar l = this.faces.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tif(this.faces[i] == f){\n\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(index > -1){\n\t\t\t\t\tthis.faces.splice(index,1);\n\t\t\t\t}\n\t\t\t},\n\n\n\t\t\trotateAroundAxis: function(axis, theta) {\n\t\t\t\treturn this.transform(this.matrix.identity().rotateAroundAxis(axis, theta));\n\t\t\t},\n\n\t\t\trotateX: function(theta) {\n\t\t\t\treturn this.transform(this.matrix.identity().rotateX(theta));\n\t\t\t},\n\n\t\t\trotateY: function(theta) {\n\t\t\t\treturn this.transform(this.matrix.identity().rotateY(theta));\n\t\t\t},\n\n\t\t\trotateZ: function(theta) {\n\t\t\t\treturn this.transform(this.matrix.identity().rotateZ(theta));\n\t\t\t},\n\n\t\t\tsaveAsOBJ: function(obj, saveNormals) {\n\t\t\t\tif( saveNormals === undefined){\n\t\t\t\t\tsaveNormals = true;\n\t\t\t\t}\n\t\t\t\tvar vOffset = obj.getCurrVertexOffset() + 1,\n\t\t\t\t\tnOffset = obj.getCurrNormalOffset() + 1;\n\t\t\t\tobj.newObject( this.name );\n\t\t\t\t//vertices\n\t\t\t\tvar v = 0, f = 0,\n\t\t\t\t\tvlen = this.vertices.length,\n\t\t\t\t\tflen = this.faces.length,\n\t\t\t\t\tface;\n\t\t\t\tfor( v=0; v<vlen; v++ ){\n\t\t\t\t\tobj.vertex( this.vertices[v] );\n\t\t\t\t}\n\t\t\t\t//faces\n\t\t\t\tif( saveNormals ){\n\t\t\t\t\t//normals\n\t\t\t\t\tfor( v=0; v<vlen; v++){\n\t\t\t\t\t\tobj.normal( this.vertices[v].normal );\n\t\t\t\t\t}\n\t\t\t\t\tfor( f=0; f<flen; f++){\n\t\t\t\t\t\tface = this.faces[f];\n\t\t\t\t\t\tobj.faceWithNormals(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset, face.b.id + nOffset, face.a.id + nOffset, face.c.id + nOffset);\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tfor( f=0; f<flen; f++){\n\t\t\t\t\t\tface = this.faces[f];\n\t\t\t\t\t\tobj.face(face.b.id + vOffset, face.a.id + vOffset, face.c.id + vOffset);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\tsaveAsSTL: function(a,b,c){\n\t\t\t\tthrow new Error(\"TriangleMesh.saveAsSTL() currently not implemented\");\n\t\t\t},\n\n\t\t\tscale: function(scale) {\n\t\t\t\treturn this.transform(this.matrix.identity().scaleSelf(scale));\n\t\t\t},\n\n\t\t\tsetName: function(name) {\n\t\t\t\tthis.name = name;\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\ttoString: function() {\n\t\t\t\treturn \"TriangleMesh: \" + this.name + \" vertices: \" + this.getNumVertices() + \" faces: \" + this.getNumFaces();\n\t\t\t},\n\n\t\t\ttoWEMesh: function() {\n\t\t\t\treturn new WETriangleMesh(this.name).addMesh(this);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t* Applies the given matrix transform to all mesh vertices. If the\n\t\t\t* updateNormals flag is true, all face normals are updated automatically,\n\t\t\t* however vertex normals need a manual update.\n\t\t\t* @param mat\n\t\t\t* @param updateNormals\n\t\t\t* @return itself\n\t\t\t*/\n\t\t\ttransform: function(mat,updateNormals) {\n\t\t\t\tif(updateNormals === undefined){\n\t\t\t\t\tupdateNormals = true;\n\t\t\t\t}\n\t\t\t\tvar l = this.vertices.length;\n\t\t\t\tfor(var i=0;i<l;i++){\n\t\t\t\t\tvar v = this.vertices[i];\n\t\t\t\t\tv.set(mat.applyTo(v));\n\t\t\t\t}\n\t\t\t\tif(updateNormals){\n\t\t\t\t\tthis.computeFaceNormals();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\ttranslate: function(x,y,z){\n\t\t\t\tif(arguments.length == 1){\n\t\t\t\t\ty = x.y;\n\t\t\t\t\tz = x.z;\n\t\t\t\t\tx = x.x;\n\t\t\t\t}\n\t\t\t\treturn this.transform(this.matrix.identity().translateSelf(x,y,z));\n\t\t\t},\n\n\t\t\tupdateVertex: function(origVec3D,newPos) {\n\t\t\t\tvar vertex = this.vertexMap.get( origVec3D );\n\t\t\t\tif (vertex !== undefined ) {\n\t\t\t\t\tthis.vertexMap.remove( vertex );\n\t\t\t\t\tvertex.set( newPos );\n\t\t\t\t\tthis.vertexMap.put( newPos, vertex );\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t}\n\t\t};\n\t}());\n\n\t//define WETriangleMesh\n\t(function( TriangleMesh ){\n\t\t//dependenecies\n\t\tvar internals = require('../../internals');\n\t\tvar Line3D = require('../Line3D');\n\t\tvar Vec3D = require('../Vec3D');\n\t\tvar WEVertex = require('./Vertex').WEVertex;\n\t\tvar WEFace = require('./Face').WEFace;\n\t\tvar WingedEdge = require('./WingedEdge');\n\t\tvar MidpointSubdivision = require('./subdiv/MidpointSubdivision');\n\n\t\t//locals\n\t\tvar proto;\n\t\t//constructor\n\t\tWETriangleMesh = function( name ){\n\t\t\tname = name || \"untitled\";\n\t\t\tTriangleMesh.call(this, name);\n\t\t};\n\t\t//passing these on to match java api\n\t\tWETriangleMesh.DEFAULT_NUM_FACES = TriangleMesh.DEFAULT_NUM_FACES;\n\t\tWETriangleMesh.DEFAULT_NUM_VERTICES = TriangleMesh.DEFAULT_NUM_VERTICES;\n\n\t\tinternals.extend( WETriangleMesh, TriangleMesh );\n\t\tproto = WETriangleMesh.prototype;\n\n\t\tproto.addFace = function( a, b, c, norm, uvA, uvB, uvC ){\n\t\t\tif( arguments.length === 6 ){\n\t\t\t\t//6-arg a,b,c,uvA,uvB,uvC pass everything up one\n\t\t\t\tuvC = uvB;\n\t\t\t\tuvB = uvA;\n\t\t\t\tuvA = norm;\n\t\t\t\tnorm = undefined;\n\t\t\t}\n\n\t\t\tvar va = this.__checkVertex(a),\n\t\t\t\tvb = this.__checkVertex(b),\n\t\t\t\tvc = this.__checkVertex(c),\n\t\t\t\tnc, t, f;\n\n\t\t\tif( va.id === vb.id || va.id === vc.id || vb.id === vc.id ){\n\t\t\t\tconsole.log('Ignoring invalid face: ' + a + ',' + b + ',' + c);\n\t\t\t} else {\n\t\t\t\tif( norm !== undefined && norm !== null ){\n\t\t\t\t\tnc = va.sub(vc).crossSelf(va.sub(vb));\n\t\t\t\t\tif( norm.dot(nc) < 0 ){\n\t\t\t\t\t\tt = va;\n\t\t\t\t\t\tva = vb;\n\t\t\t\t\t\tvb = t;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tf = new WEFace(va, vb, vc, uvA, uvB, uvC);\n\t\t\t\tthis.faces.push(f);\n\t\t\t\tthis.updateEdge( va,vb,f );\n\t\t\t\tthis.updateEdge( vb,vc,f );\n\t\t\t\tthis.updateEdge( vc,va,f );\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\t\tproto.center = function( origin, callback ){\n\t\t\tTriangleMesh.prototype.center.call(this, origin, callback);\n\t\t\tthis.rebuildIndex();\n\t\t};\n\n\t\tproto.clear = function(){\n\t\t\tTriangleMesh.prototype.clear.call(this);\n\t\t\tthis.edgeMap = new internals.LinkedMap( edgeKeyGenerator );\n\t\t\tthis.edges = this.edgeMap.getArray();\n\t\t\treturn this;\n\t\t};\n\n\t\tproto.copy = function(){\n\t\t\tvar m = new WETriangleMesh( this.name+\"-copy\" );\n\t\t\tvar i, l, f;\n\t\t\tl = this.faces.length;\n\t\t\tfor(i=0; i<l; i++){\n\t\t\t\tf = this.faces[i];\n\t\t\t\tm.addFace( f.a, f.b, f.c, f.normal, f.uvA, f.uvB, f.uvC );\n\t\t\t}\n\t\t\treturn m;\n\t\t};\n\n\t\tproto._createVertex = function( vec3D, id ){\n\t\t\tvar vertex = new WEVertex( vec3D, id );\n\t\t\treturn vertex;\n\t\t};\n\t\t//TODO: numEdges currently not hooked up\n\t\tproto.getNumEdges = function(){\n\t\t\treturn this.edgeMap.size();\n\t\t};\n\n\t\tproto.init = function( name ){\n\t\t\tTriangleMesh.prototype.init.call(this, name);\n\t\t\t//this.edgeMap.put(va.toString()+vb.toString(), {WingedEdge} );\n\t\t\tthis.edgeMap = new internals.LinkedMap( edgeKeyGenerator );\n\t\t\tthis.edges = this.edgeMap.getArray();\n\t\t\tthis.__edgeCheck = new Line3D( new Vec3D(), new Vec3D() );\n\t\t\tthis.__uniqueEdgeID = 0;\n\t\t};\n\n\t\tproto.rebuildIndex = function(){\n\t\t\t//if vertices have moved / transformed a new vertexMap and edgeMap must be made\n\t\t\t//in order to have updated string keys of new positions\n\t\t\t//newVertexDictionary[{String}] = {Vertex}\n\t\t\tvar newVertexMap = new internals.LinkedMap( vertexKeyGenerator );\n\t\t\tvar newEdgeMap = new internals.LinkedMap( edgeKeyGenerator );\n\n            var i = 0,\n                arr = this.vertexMap.getArray();\n            for(i=0; i<arr.length; i++){\n\t\t\t\tnewVertexMap.put( arr[i], arr[i] );\n\t\t\t}\n\n            arr = this.edgeMap.getArray();\n            for(i=0; i<arr.length; i++){\n\t\t\t\tnewEdgeMap.put( arr[i], arr[i] );\n\t\t\t}\n\n\t\t\tthis.vertexMap = newVertexMap;\n\t\t\tthis.vertices = newVertexMap.getArray();\n\t\t\tthis.edgeMap = newEdgeMap;\n\t\t\tthis.edges = newEdgeMap.getArray();\n\t\t};\n\n\t\tproto.removeEdge = function( edge ){\n\t\t\tedge.remove();\n\t\t\tvar v = edge.a;\n\t\t\tif( v.edges.length === 0 ){\n\t\t\t\tthis.vertexMap.remove( v );\n\t\t\t}\n\t\t\tv = edge.b;\n\t\t\tif( v.edges.length === 0 ){\n\t\t\t\tthis.vertexMap.remove( v );\n\t\t\t}\n            for(var i=0; i<edge.faces.length; i++){\n                this.removeFace(edge.faces[i]);\n            }\n\t\t\tvar removed = this.edgeMap.remove( this.__edgeCheck.set( edge.a, edge.b ) );\n            if(!removed){\n                this.edgeMap.remove( this.__edgeCheck.set(edge.b, edge.a) );\n            }\n\t\t\tif( removed !== edge ){\n\t\t\t\tthrow new Error(\"Can't remove edge\");\n\t\t\t}\n\t\t};\n\n\t\tproto.removeFace = function( face ){\n\t\t\tvar i = this.faces.indexOf( face );\n\t\t\tif( i > -1 ){\n\t\t\t\tthis.faces.splice( i, 1 );\n\t\t\t}\n\n            i = 0;\n            var edge;\n\n            for(i=0; i<face.edges.length; i++){\n                edge = face.edges[i];\n                edge.faces.splice(edge.faces.indexOf(face), 1);\n                if(edge.faces.length === 0){\n                    this.removeEdge(edge);\n                }\n            }\n\t\t};\n\n\t\t//FIXME (FIXME in original java source)\n\t\t//TODO UNIT TEST .splice\n\t\tproto.removeUnusedVertices = function(){\n\t\t\tinternals.each( this.vertices, function( vertex, i ){\n\t\t\t\tvar isUsed = false;\n\t\t\t\tinternals.each( this.faces, function( f ){\n\t\t\t\t\tif( f.a == vertex || f.b == vertex || f.c == vertex ){\n\t\t\t\t\t\tisUsed = true;\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t\tif( !isUsed ){\n\t\t\t\t\tthis.vertices.splice( i, 1 );\n\t\t\t\t}\n\t\t\t});\n\t\t};\n\n\t\t/**\n\t\t* @param {Vertex[] | Vertex{}} selection, array or object of Vertex's to remove\n\t\t*/\n\t\tproto.removeVertices = function( selection ){\n\t\t\tinternals.each( selection, function( vertex ){\n\t\t\t\t//WingedEdgeVertex\n\t\t\t\tinternals.each( vertex.edges, function( edge ){\n\t\t\t\t\tinternals.each( edge.faces, function( face ){\n\t\t\t\t\t\tthis.removeFace( face );\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t});\n\t\t};\n\n\t\t//@param {Vec3D | WingedEdge} a or edge\n\t\t//@param {Vec3D | SubdivisionStrategy} b or strategy if edge supplied\n\t\t//@param {SubdivisionStrategy} [subDiv] or undefined\n\t\tproto.splitEdge = function( a, b, subDiv ){\n\t\t\tvar edge, mid;\n\t\t\tif( arguments.length === 3 ){\n\t\t\t\tedge = this.edgeMap.get( this.__edgeCheck.set(a, b) );\n\n                if(!edge){\n                    this.edgeMap.get( this.__edgeCheck.set(b,a) );\n                }\n\n\t\t\t} else if( arguments.length == 2 ){\n\t\t\t\tedge = a;\n\t\t\t\tsubDiv = b;\n\t\t\t}\n\t\t\tmid = subDiv.computeSplitPoints( edge );\n\t\t\tthis.splitFace( edge.faces[0], edge, mid);\n\t\t\tif( edge.faces.length > 1 ){\n\t\t\t\tthis.splitFace( edge.faces[1], edge, mid);\n\t\t\t}\n\t\t\tthis.removeEdge( edge );\n\t\t};\n\t\t//@param {WEFace} face,\n\t\t//@param {WingedEdge} edge,\n\t\t//@param {Vec3D[]} midPoints\n\t\tproto.splitFace = function( face, edge, midPoints ){\n\t\t\tvar p, i, ec, prev, num, mid;\n\t\t\tfor(i=0; i<3; i++){\n\t\t\t\tec = face.edges[i];\n\t\t\t\tif( !ec.equals(edge) ){\n\t\t\t\t\tif( ec.a.equals(edge.a) || ec.a.equals(edge.b) ){\n\t\t\t\t\t\tp = ec.b;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tp = ec.a;\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tnum = midPoints.length;\n\t\t\tfor(i=0; i<num; i++){\n\t\t\t\tmid = midPoints[i];\n\t\t\t\tif( i === 0 ){\n\t\t\t\t\tthis.addFace( p, edge.a, mid, face.normal );\n\t\t\t\t} else {\n\t\t\t\t\tthis.addFace( p, prev, mid, face.normal );\n\t\t\t\t}\n\t\t\t\tif( i === num-1 ){\n\t\t\t\t\tthis.addFace( p, mid, edge.b, face.normal );\n\t\t\t\t}\n\t\t\t\tprev = mid;\n\t\t\t}\n\t\t};\n\n\t\t//@param {SubdivisionStrategy | Number} subDiv or minLength\n\t\t//@param {Number} [minLength] if also supplying subDiv\n\t\tproto.subdivide = function( subDiv, minLength ){\n\t\t\tif( arguments.length === 1 ){\n\t\t\t\tminLength = subDiv;\n\t\t\t\tsubDiv = new MidpointSubdivision();\n\t\t\t}\n\t\t\tthis.subdivideEdges( this.edges.slice(0), subDiv, minLength);\n\t\t};\n\n\t\tproto.subdivideEdges = function( origEdges, subDiv, minLength ){\n\t\t\torigEdges.sort( subDiv.getEdgeOrdering() );\n\t\t\tminLength *= minLength;\n\t\t\tvar i=0, l = origEdges.length;\n\t\t\tfor(i=0; i<l; i++){\n\t\t\t\tvar e = origEdges[i];\n\t\t\t\tif( this.edges.indexOf( e ) > -1 ) {\n\t\t\t\t\tif( e.getLengthSquared() >= minLength ) {\n\t\t\t\t\t\tthis.splitEdge( e, subDiv );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tproto.subdivideFaceEdges = function( faces, subDiv, minLength ){\n\t\t\tvar fedges = [], i,j, f, e, fl, el;\n\t\t\tfl = this.faces.length;\n\t\t\tfor(i=0; i<fl; i++){\n\t\t\t\tf = this.faces[i];\n\t\t\t\tel = f.edges.length;\n\t\t\t\tfor(j=0; j<el; j++){\n\t\t\t\t\te = f.edges[j];\n\t\t\t\t\tif( fedges.indexOf(e) < 0 ){\n\t\t\t\t\t\tfedges.push( e );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.subdividEdges( fedges, subDiv, minLength );\n\t\t};\n\n\t\tproto.toString = function(){\n\t\t\treturn \"WETriangleMesh: \" + this.name + \" vertices: \" + this.getNumVertices() + \" faces: \" + this.getNumFaces() + \" edges:\" + this.getNumEdges();\n\t\t};\n\n\t\t/**\n\t\t* Applies the given matrix transform to all mesh vertices. If the\n\t\t* updateNormals flag is true, all face normals are updated automatically,\n\t\t* however vertex normals still need a manual update.\n\t\t* @param {toxi.geom.Matrix4x4} matrix\n\t\t* @param {Boolean} [updateNormals]\n\t\t*/\n\t\tproto.transform = function( matrix, updateNormals ){\n\t\t\tif( updateNormals === undefined || updateNormals === null ){\n\t\t\t\tupdateNormals = true;\n\t\t\t}\n\t\t\tfor(var i=0, l = this.vertices.length; i<l; i++){\n\t\t\t\tmatrix.applyToSelf( this.vertices[i] );\n\t\t\t}\n\t\t\tthis.rebuildIndex();\n\t\t\tif( updateNormals ){\n\t\t\t\tthis.computeFaceNormals();\n\t\t\t}\n\t\t\treturn this;\n\t\t};\n\n\t\tproto.updateEdge = function( va, vb, face ){\n\t\t\t//dictionary key is va.toString() + vb.toString()\n\t\t\t//because Line3D toString would be different than WingedEdge toString()\n\t\t\tthis.__edgeCheck.set( va, vb );\n\t\t\tvar e = this.edgeMap.get( this.__edgeCheck );\n            if(!e){\n                //edge could be as b->a or a->b\n                this.__edgeCheck.set(vb, va);\n                e = this.edgeMap.get(this.__edgeCheck);\n            }\n\t\t\tif( e !== undefined ){\n\t\t\t\te.addFace( face );\n\t\t\t} else {\n\t\t\t\te = new WingedEdge( va, vb, face, this.__uniqueEdgeID++ );\n\t\t\t\tthis.edgeMap.put( e, e );\n\t\t\t\tva.addEdge( e );\n\t\t\t\tvb.addEdge( e );\n\t\t\t}\n\t\t\tface.addEdge( e );\n\t\t};\n\t}( TriangleMesh ));\n\n\n\t//Terrain\n\t(function( TriangleMesh ){\n\t\tvar internals = require('../../internals'),\n\t\t\tmathUtils = require('../../math/mathUtils'),\n\t\t\tInterpolation2D = require('../../math/Interpolation2D'),\n\t\t\tRay3D = require('../Ray3D'),\n\t\t\tTriangleIntersector = require('../TriangleIntersector'),\n\t\t\tTriangle3D = require('../Triangle3D'),\n\t\t\tIsectData3D = require('../IsectData3D'),\n\t\t\tVec2D = require('../vectors').Vec2D,\n\t\t\tVec3D = require('../vectors').Vec3D;\n\t\t/**\n\t\t* Constructs a new and initially flat terrain of the given size in the XZ\n\t\t* plane, centred around the world origin.\n\t\t*\n\t\t* @param {Number} width\n\t\t* @param {Number} depth\n\t\t* @param {toxi.geom.Vec2D | Number} scale\n\t\t*/\n\t\tTerrain = function(width, depth, scale){\n\t\t\tthis.width = width;\n\t\t\tthis._depth = depth;\n\t\t\tif( !internals.has.XY(scale) ){\n\t\t\t\tscale = new Vec2D(scale,scale);\n\t\t\t}\n\t\t\tthis.setScale( scale );\n\t\t\tthis.elevation = [];\n\t\t\tvar i = 0,\n\t\t\t\tlen = width * depth;\n\t\t\tfor(i=0; i<len; i++){\n\t\t\t\tthis.elevation[i] = 0;\n\t\t\t}\n\n\t\t\tthis.__elevationLength = this.width * this._depth;\n\t\t\tthis.vertices = [];\n\t\t\tvar offset = new Vec3D(parseInt(this.width / 2,10), 0, parseInt(this._depth / 2,10)),\n\t\t\t\tscaleXZ = this.getScale().to3DXZ();\n\t\t\ti=0;\n\t\t\tfor(var z = 0; z < this._depth; z++){\n\t\t\t\tfor(var x = 0; x < this.width; x++){\n\t\t\t\t\tthis.vertices[i++] = new Vec3D(x,0,z).subSelf(offset).scaleSelf(scaleXZ);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tTerrain.prototype = {\n\t\t\t/**\n\t\t\t* @return number of grid cells along the Z axis.\n\t\t\t*/\n\t\t\tgetDepth: function(){\n\t\t\t\treturn this._depth;\n\t\t\t},\n\t\t\tgetElevation: function(){\n\t\t\t\treturn this.elevation;\n\t\t\t},\n\t\t\t/**\n\t\t\t* @param {Number} x\n\t\t\t* @param {Number} z\n\t\t\t* @return the elevation at grid point\n\t\t\t*/\n\t\t\tgetHeightAtCell: function(x,z){\n\t\t\t\t//console.log(\"[\"+x+\",\"+z+\"]\");\n\t\t\t\treturn this.elevation[this._getIndex(x,z)];\n\t\t\t},\n\t\t\t/**\n\t\t\t* Computes the elevation of the terrain at the given 2D world coordinate\n\t\t\t* (based on current terrain scale).\n\t\t\t*\n\t\t\t* @param {Number} x scaled world coord x\n\t\t\t* @param {Number} z scaled world coord z\n\t\t\t* @return {Number} interpolated elevation\n\t\t\t*/\n\t\t\tgetHeightAtPoint: function(x,z){\n\t\t\t\tvar xx = x / this._scale.x + this.width * 0.5,\n\t\t\t\t\tzz = z / this._scale.y + this._depth * 0.5,\n\t\t\t\t\ty = 0,\n\t\t\t\t\tflxx = ~~x,\n\t\t\t\t\tflzz = ~~zz;\n\n\t\t\t\tif(xx >= 0 & xx < this.width && zz >= 0 && zz < this._depth){\n\n\t\t\t\t\tvar x2 = ~~Math.min(xx + 1, this.width - 1),\n\t\t\t\t\t\tz2 = ~~Math.min(zz + 1, this._depth - 1);\n\n\t\t\t\t\tvar\ta = this.getHeightAtCell(flxx, flzz),\n\t\t\t\t\t\tb = this.getHeightAtCell(x2, flzz),\n\t\t\t\t\t\tc = this.getHeightAtCell(flxx, z2),\n\t\t\t\t\t\td = this.getHeightAtCell(x2, z2);\n\n\t\t\t\t\ty = Interpolation2D.bilinear(xx,zz, flxx, flzz, x2, z2, a, b, c, d);\n\t\t\t\t}\n\t\t\t\treturn y;\n\t\t\t},\n\t\t\t/**\n\t\t\t* Computes the array index for the given cell coords & checks if they're in\n\t\t\t* bounds. If not an {@link IndexOutOfBoundsException} is thrown.\n\t\t\t* @param {Number} x\n\t\t\t* @param {Number} z\n\t\t\t* @return {Number} array index\n\t\t\t*/\n\t\t\t_getIndex: function(x,z){\n\t\t\t\tvar idx = z * this.width + x;\n\t\t\t\tif(idx < 0 || idx > this.__elevationLength){\n\t\t\t\t\tthrow new Error(\"the given terrain cell is invalid: \"+x+ \";\"+z);\n\t\t\t\t}\n\t\t\t\treturn idx;\n\t\t\t},\n\t\t\t/**\n\t\t\t * @return {Vec2D} the scale\n\t\t\t */\n\t\t\tgetScale: function(){\n\t\t\t\treturn this._scale;\n\t\t\t},\n\n\t\t\tgetVertexAtCell: function(x,z){\n\t\t\t\treturn this.vertices[this._getIndex(x,z)];\n\t\t\t},\n\t\t\t/**\n\t\t\t * @return {Number} number of grid cells along X axis\n\t\t\t */\n\t\t\tgetWidth: function(){\n\t\t\t\treturn this.width;\n\t\t\t},\n\t\t\t/**\n\t\t\t* Computes the 3D position (with elevation) and normal vector at the given\n\t\t\t* 2D location in the terrain. The position is in scaled world coordinates\n\t\t\t* based on the given terrain scale. The returned data is encapsulated in a\n\t\t\t* {@link toxi.geom.IsectData3D} instance.\n\t\t\t* @param {Number} x\n\t\t\t* @param {Number} z\n\t\t\t* @return {IsectData3D} intersection data parcel\n\t\t\t*/\n\t\t\tintersectAtPoint: function(x,z){\n\t\t\t\tvar xx = x / this._scale.x + this.width * 0.5,\n\t\t\t\t\tzz = z / this._scale.y + this._depth * 0.5,\n\t\t\t\t\tisec = new IsectData3D();\n\t\t\t\tif(xx >= 0 && xx < this.width && zz >= 0 && zz < this._depth){\n\t\t\t\t\tvar x2 = ~~Math.min(xx + 1, this.width - 1),\n\t\t\t\t\t\tz2 = ~~Math.min(zz + 1, this._depth - 1),\n\t\t\t\t\t\tflxx = ~~xx,\n\t\t\t\t\t\tflzz = ~~zz,\n\n\t\t\t\t\t\ta = this.getVertexAtCell(flxx,flzz),\n\t\t\t\t\t\tb = this.getVertexAtCell(x2, flzz),\n\t\t\t\t\t\tc = this.getVertexAtCell(x2,z2),\n\t\t\t\t\t\td = this.getVertexAtCell(flxx,z2),\n\t\t\t\t\t\tr = new Ray3D(new Vec3D(x, 10000, z), new Vec3D(0, -1, 0)),\n\t\t\t\t\t\ti = new TriangleIntersector(new Triangle3D(a, b, d));\n\n\t\t\t\t\tif(i.intersectsRay(r)){\n\t\t\t\t\t\tisec = i.getIntersectionData();\n\t\t\t\t\t} else {\n\t\t\t\t\t\ti.setTriangle(new Triangle3D(b, c, d));\n\t\t\t\t\t\ti.intersectsRay(r);\n\t\t\t\t\t\tisec = i.getIntersectionData();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn isec;\n\t\t\t},\n\t\t\t/**\n\t\t\t* Sets the elevation of all cells to those of the given array values.\n\t\t\t* @param {Array} elevation array of height values\n\t\t\t* @return itself\n\t\t\t*/\n\t\t\tsetElevation: function(elevation){\n\t\t\t\tif(this.__elevationLength == elevation.length){\n\t\t\t\t\tfor(var i = 0, len = elevation.length; i<len; i++){\n\t\t\t\t\t\tthis.vertices[i].y = this.elevation[i] = elevation[i];\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error(\"the given elevation array size does not match terrain\");\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t/**\n\t\t\t* Sets the elevation for a single given grid cell.\n\t\t\t* @param {Number} x\n\t\t\t* @param {Number} z\n\t\t\t* @param {Number} h new elevation value\n\t\t\t* @return itself\n\t\t\t*/\n\t\t\tsetHeightAtCell: function(x,z,h){\n\t\t\t\tvar index = this._getIndex(x,z);\n\t\t\t\tthis.elevation[index] = h;\n\t\t\t\tthis.vertices[index].y = h;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\tsetScale: function(scale){\n\t\t\t\tif(!internals.has.XY(scale) ){\n\t\t\t\t\tscale = new Vec2D(scale,scale);\n\t\t\t\t}\n\t\t\t\tthis._scale = scale;\n\t\t\t},\n\t\t\ttoMesh: function(){\n\t\t\t\tvar opts = {\n\t\t\t\t\tmesh: undefined,\n\t\t\t\t\tminX: 0,\n\t\t\t\t\tminZ: 0,\n\t\t\t\t\tmaxX: this.width,\n\t\t\t\t\tmaxZ: this._depth\n\t\t\t\t};\n\n\t\t\t\tvar v = this.vertices,\n\t\t\t\t\tw = this.width,\n\t\t\t\t\td = this._depth;\n\n\t\t\t\tif(arguments.length == 1 && typeof arguments[0] == 'object'){\n\t\t\t\t\t//options object\n\t\t\t\t\tvar args = arguments[0];\n\t\t\t\t\topts.mesh = args.mesh || new TriangleMesh(\"terrain\");\n\t\t\t\t\topts.minX = args.minX || opts.minX;\n\t\t\t\t\topts.minZ = args.minZ || opts.minZ;\n\t\t\t\t\topts.maxX = args.maxX || opts.maxX;\n\t\t\t\t\topts.maxZ = args.maxZ || opts.maxZ;\n\t\t\t\t} else if(arguments.length >= 5){\n\t\t\t\t\topts.mesh = arguments[0];\n\t\t\t\t\topts.minX = arguments[1];\n\t\t\t\t\topts.minZ = arguments[2];\n\t\t\t\t\topts.maxX  = arguments[3];\n\t\t\t\t\topts.maxZ = arguments[4];\n\t\t\t\t}\n\n\t\t\t\topts.mesh = opts.mesh || new TriangleMesh(\"terrain\");\n\t\t\t\topts.minX = mathUtils.clip(opts.minX, 0, w - 1);\n\t\t\t\topts.maxX = mathUtils.clip(opts.maxX, 0, w);\n\t\t\t\topts.minZ = mathUtils.clip(opts.minZ, 0, d-1);\n\t\t\t\topts.maxZ = mathUtils.clip(opts.maxZ, 0, d);\n\t\t\t\topts.minX++;\n\t\t\t\topts.minZ++;\n\n\n\t\t\t\tfor(var z = opts.minZ, idx = opts.minX * w; z < opts.maxZ; z++, idx += w){\n\t\t\t\t\tfor(var x = opts.minX; x < opts.maxX; x++){\n\t\t\t\t\t\topts.mesh.addFace(v[idx - w + x - 1], v[idx - w + x], v[idx + x - 1]);\n\t\t\t\t\t\topts.mesh.addFace(v[idx - w + x], v[idx + x], v[idx + x - 1]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn opts.mesh;\n\t\t\t}\n\t\t};\n\n\t}( TriangleMesh ));\n\n\n\t//SurfaceMeshBuilder\n\t(function( TriangleMesh ){\n\t\tvar Vec3D = require('../Vec3D'),\n\t\t\tVec2D = require('../Vec2D');\n\n\t\t/**\n\t\t * @class An extensible builder class for {@link TriangleMesh}es based on 3D surface\n\t\t * functions using spherical coordinates. In order to create mesh, you'll need\n\t\t * to supply a {@link SurfaceFunction} implementation to the builder.\n\t\t * @member toxi\n\t\t */\n\t\tSurfaceMeshBuilder = function(func) {\n\t\t\tthis.func = func;\n\t\t};\n\n\t\tSurfaceMeshBuilder.prototype = {\n\t\t\t/*\n\t\t\t\tcreate a mesh from a surface,\n\t\t\t\tparameter options:\n\t\t\t\t\t1 - Object options\n\t\t\t\t\t1 - Number resolution\n\t\t\t\t\t3 - TriangleMesh mesh, Number resolution, Number size\n\t\t\t\t\t4 - TriangleMesh mesh, Number resolution, Number size, boolean isClosed\n\t\t\t*/\n\t\t\tcreateMesh: function() {\n\t\t\t\tvar opts = {\n\t\t\t\t\tmesh: undefined,\n\t\t\t\t\tresolution: 0,\n\t\t\t\t\tsize: 1,\n\t\t\t\t\tisClosed: true\n\t\t\t\t};\n\t\t\t\tif(arguments.length == 1){\n\t\t\t\t\tif(typeof arguments[0] == 'object'){ //options object\n\t\t\t\t\t\tvar arg = arguments[0];\n\t\t\t\t\t\t//if a mesh was provided as an option, use it, otherwise make one\n\t\t\t\t\t\topts.mesh = arg.mesh;\n\t\t\t\t\t\topts.resolution = arg.res || arg.resoultion || 0;\n\t\t\t\t\t\tif(arg.size !== undefined){\n\t\t\t\t\t\t\topts.size = arg.size;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif(arg.isClosed !== undefined){\n\t\t\t\t\t\t\topts.isClosed = arg.isClosed;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { //resolution Number\n\t\t\t\t\t\topts.resolution = arguments[0];\n\t\t\t\t\t}\n\t\t\t\t} else if(arguments.length > 2){\n\t\t\t\t\topts.mesh = arguments[0];\n\t\t\t\t\topts.resolution = arguments[1];\n\t\t\t\t\topts.size = arguments[2];\n\t\t\t\t\tif(arguments.length == 4){\n\t\t\t\t\t\topts.isClosed = arguments[3];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tvar mesh = opts.mesh;\n\t\t\t\tif(mesh === undefined || mesh === null){\n\t\t\t\t\tmesh = new TriangleMesh();\n\t\t\t\t}\n\n\t\t\t\tvar a = new Vec3D(),\n\t\t\t\t\tb = new Vec3D(),\n\t\t\t\t\tpa = new Vec3D(),\n\t\t\t\t\tpb = new Vec3D(),\n\t\t\t\t\ta0 = new Vec3D(),\n\t\t\t\t\tb0 = new Vec3D(),\n\t\t\t\t\tphiRes = this.func.getPhiResolutionLimit(opts.resolution),\n\t\t\t\t\tphiRange = this.func.getPhiRange(),\n\t\t\t\t\tthetaRes = this.func.getThetaResolutionLimit(opts.resolution),\n\t\t\t\t\tthetaRange = this.func.getThetaRange(),\n\t\t\t\t\tpres = 1.0 / phiRes, //(1 == opts.resolution % 2 ? opts.resolution - 0 : opts.resolution);\n\t\t\t\t\ttres = 1.0 / thetaRes,\n\t\t\t\t\tires = 1.0 / opts.resolution,\n\t\t\t\t\tpauv = new Vec2D(),\n\t\t\t\t\tpbuv = new Vec2D(),\n\t\t\t\t\tauv = new Vec2D(),\n\t\t\t\t\tbuv = new Vec2D();\n\n\t\t\t\tfor (var p = 0; p < phiRes; p++) {\n\t\t\t\t\tvar phi = p * phiRange * ires;\n\t\t\t\t\tvar phiNext = (p + 1) * phiRange * ires;\n\t\t\t\t\tfor (var t = 0; t <= thetaRes; t++) {\n\t\t\t\t\t\tvar theta = t * thetaRange * ires;\n\t\t\t\t\t\tvar func = this.func;\n\t\t\t\t\t\ta =\tfunc.computeVertexFor(a, phiNext, theta).scaleSelf(opts.size);\n\t\t\t\t\t\tauv.set( t * tres, 1 - (p + 1) * pres);\n\t\t\t\t\t\tb = func.computeVertexFor(b, phi, theta).scaleSelf(opts.size);\n\t\t\t\t\t\tbuv.set( t * tres, 1 - p * pres );\n\t\t\t\t\t\tif (b.equalsWithTolerance(a, 0.0001) ) {\n\t\t\t\t\t\t\tb.set(a);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (t > 0) {\n\t\t\t\t\t\t\tif (t == thetaRes && opts.isClosed) {\n\t\t\t\t\t\t\t\ta.set(a0);\n\t\t\t\t\t\t\t\tb.set(b0);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tmesh.addFace(pa, pb, a, pauv.copy(), pbuv.copy(), auv.copy());\n\t\t\t\t\t\t\tmesh.addFace(pb, b, a, pbuv.copy(), buv.copy(), auv.copy());\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\ta0.set(a);\n\t\t\t\t\t\t\tb0.set(b);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpa.set(a);\n\t\t\t\t\t\tpb.set(b);\n\t\t\t\t\t\tpauv.set(auv);\n\t\t\t\t\t\tpbuv.set(buv);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn mesh;\n\t\t\t},\n\n\n\t\t\t/**\n\t\t\t@return the function\n\t\t\t*/\n\t\t\tgetFunction: function() {\n\t\t\t\treturn this.func;\n\t\t\t},\n\n\t\t\tsetFunction: function(func) {\n\t\t\t\tthis.func = func;\n\t\t\t}\n\t\t};\n\t}( TriangleMesh ));\n\n\texports.TriangleMesh = TriangleMesh;\n\texports.WETriangleMesh = WETriangleMesh;\n\texports.Terrain = Terrain;\n\texports.SurfaceMeshBuilder = SurfaceMeshBuilder;\n\n\n"]},"metadata":{},"sourceType":"script"}