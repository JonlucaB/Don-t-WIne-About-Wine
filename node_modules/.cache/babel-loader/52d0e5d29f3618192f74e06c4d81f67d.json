{"ast":null,"code":"var internals = require('../internals');\n/**\n* @class Implementations of 2D interpolation functions (currently only bilinear).\n* @member toxi\n* @static\n*/\n\n\nvar Interpolation2D = {};\n/**\n* @param {Number} x\n*            x coord of point to filter (or Vec2D p)\n* @param {Number} y\n*            y coord of point to filter (or Vec2D p1)\n* @param {Number} x1\n*            x coord of top-left corner (or Vec2D p2)\n* @param {Number} y1\n*            y coord of top-left corner\n* @param {Number} x2\n*            x coord of bottom-right corner\n* @param {Number} y2\n*            y coord of bottom-right corner\n* @param {Number} tl\n*            top-left value\n* @param {Number} tr\n*            top-right value (do not use if first 3 are Vec2D)\n* @param {Number} bl\n*            bottom-left value (do not use if first 3 are Vec2D)\n* @param {Number} br\n*            bottom-right value (do not use if first 3 are Vec2D)\n* @return {Number} interpolated value\n*/\n\nInterpolation2D.bilinear = function (_x, _y, _x1, _y1, _x2, _y2, _tl, _tr, _bl, _br) {\n  var x, y, x1, y1, x2, y2, tl, tr, bl, br;\n\n  if (internals.has.XY(_x)) //if the first 3 params are passed in as Vec2Ds\n    {\n      x = _x.x;\n      y = _x.y;\n      x1 = _y.x;\n      y1 = _y.y;\n      x2 = _x1.x;\n      y2 = _x1.y;\n      tl = _y1;\n      tr = _x2;\n      bl = _y2;\n      br = _tl;\n    } else {\n    x = _x;\n    y = _y;\n    x1 = _x1;\n    y1 = _y1;\n    x2 = _x2;\n    y2 = _y2;\n    tl = _tl;\n    tr = _tr;\n    bl = _bl;\n    br = _br;\n  }\n\n  var denom = 1.0 / ((x2 - x1) * (y2 - y1));\n  var dx1 = (x - x1) * denom;\n  var dx2 = (x2 - x) * denom;\n  var dy1 = y - y1;\n  var dy2 = y2 - y;\n  return tl * dx2 * dy2 + tr * dx1 * dy2 + bl * dx2 * dy1 + br * dx1 * dy1;\n};\n\nmodule.exports = Interpolation2D;","map":{"version":3,"sources":["C:/Users/alfor/Documents/GitHub/Don-t-WIne-About-Wine/node_modules/toxiclibsjs/math/Interpolation2D.js"],"names":["internals","require","Interpolation2D","bilinear","_x","_y","_x1","_y1","_x2","_y2","_tl","_tr","_bl","_br","x","y","x1","y1","x2","y2","tl","tr","bl","br","has","XY","denom","dx1","dx2","dy1","dy2","module","exports"],"mappings":"AAAA,IAAIA,SAAS,GAAGC,OAAO,CAAC,cAAD,CAAvB;AAEI;AACJ;AACA;AACA;AACA;;;AACI,IAAIC,eAAe,GAAG,EAAtB;AACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACIA,eAAe,CAACC,QAAhB,GAA2B,UAASC,EAAT,EAAaC,EAAb,EAAiBC,GAAjB,EAAqBC,GAArB,EAA0BC,GAA1B,EAA+BC,GAA/B,EAAoCC,GAApC,EAAyCC,GAAzC,EAA8CC,GAA9C,EAAmDC,GAAnD,EAAwD;AAC/E,MAAIC,CAAJ,EAAMC,CAAN,EAAQC,EAAR,EAAWC,EAAX,EAAcC,EAAd,EAAiBC,EAAjB,EAAoBC,EAApB,EAAuBC,EAAvB,EAA0BC,EAA1B,EAA6BC,EAA7B;;AACA,MAAIvB,SAAS,CAACwB,GAAV,CAAcC,EAAd,CAAkBrB,EAAlB,CAAJ,EAA6B;AAC7B;AACIU,MAAAA,CAAC,GAAGV,EAAE,CAACU,CAAP;AACAC,MAAAA,CAAC,GAAGX,EAAE,CAACW,CAAP;AAEAC,MAAAA,EAAE,GAAGX,EAAE,CAACS,CAAR;AACAG,MAAAA,EAAE,GAAGZ,EAAE,CAACU,CAAR;AAEAG,MAAAA,EAAE,GAAGZ,GAAG,CAACQ,CAAT;AACAK,MAAAA,EAAE,GAAGb,GAAG,CAACS,CAAT;AAEAK,MAAAA,EAAE,GAAGb,GAAL;AACAc,MAAAA,EAAE,GAAGb,GAAL;AACAc,MAAAA,EAAE,GAAGb,GAAL;AACAc,MAAAA,EAAE,GAAGb,GAAL;AACH,KAfD,MAeO;AACHI,IAAAA,CAAC,GAAGV,EAAJ;AACAW,IAAAA,CAAC,GAAGV,EAAJ;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACAW,IAAAA,EAAE,GAAGV,GAAL;AACH;;AACD,MAAIa,KAAK,GAAG,OAAO,CAACR,EAAE,GAAGF,EAAN,KAAaG,EAAE,GAAGF,EAAlB,CAAP,CAAZ;AACA,MAAIU,GAAG,GAAG,CAACb,CAAC,GAAGE,EAAL,IAAWU,KAArB;AACA,MAAIE,GAAG,GAAG,CAACV,EAAE,GAAGJ,CAAN,IAAWY,KAArB;AACA,MAAIG,GAAG,GAAGd,CAAC,GAAGE,EAAd;AACA,MAAIa,GAAG,GAAGX,EAAE,GAAGJ,CAAf;AACA,SAAQK,EAAE,GAAGQ,GAAL,GAAWE,GAAX,GAAiBT,EAAE,GAAGM,GAAL,GAAWG,GAA5B,GAAkCR,EAAE,GAAGM,GAAL,GAAWC,GAA7C,GAAmDN,EAAE,GAAEI,GAAJ,GAAUE,GAArE;AACH,CAnCD;;AAqCAE,MAAM,CAACC,OAAP,GAAiB9B,eAAjB","sourcesContent":["var internals = require('../internals');\n\n    /**\n    * @class Implementations of 2D interpolation functions (currently only bilinear).\n    * @member toxi\n    * @static\n    */\n    var Interpolation2D = {};\n    /**\n    * @param {Number} x\n    *            x coord of point to filter (or Vec2D p)\n    * @param {Number} y\n    *            y coord of point to filter (or Vec2D p1)\n    * @param {Number} x1\n    *            x coord of top-left corner (or Vec2D p2)\n    * @param {Number} y1\n    *            y coord of top-left corner\n    * @param {Number} x2\n    *            x coord of bottom-right corner\n    * @param {Number} y2\n    *            y coord of bottom-right corner\n    * @param {Number} tl\n    *            top-left value\n    * @param {Number} tr\n    *            top-right value (do not use if first 3 are Vec2D)\n    * @param {Number} bl\n    *            bottom-left value (do not use if first 3 are Vec2D)\n    * @param {Number} br\n    *            bottom-right value (do not use if first 3 are Vec2D)\n    * @return {Number} interpolated value\n    */\n    Interpolation2D.bilinear = function(_x, _y, _x1,_y1, _x2, _y2, _tl, _tr, _bl, _br) {\n        var x,y,x1,y1,x2,y2,tl,tr,bl,br;\n        if( internals.has.XY( _x ) ) //if the first 3 params are passed in as Vec2Ds\n        {\n            x = _x.x;\n            y = _x.y;\n\n            x1 = _y.x;\n            y1 = _y.y;\n\n            x2 = _x1.x;\n            y2 = _x1.y;\n\n            tl = _y1;\n            tr = _x2;\n            bl = _y2;\n            br = _tl;\n        } else {\n            x = _x;\n            y = _y;\n            x1 = _x1;\n            y1 = _y1;\n            x2 = _x2;\n            y2 = _y2;\n            tl = _tl;\n            tr = _tr;\n            bl = _bl;\n            br = _br;\n        }\n        var denom = 1.0 / ((x2 - x1) * (y2 - y1));\n        var dx1 = (x - x1) * denom;\n        var dx2 = (x2 - x) * denom;\n        var dy1 = y - y1;\n        var dy2 = y2 - y;\n        return (tl * dx2 * dy2 + tr * dx1 * dy2 + bl * dx2 * dy1 + br* dx1 * dy1);\n    };\n\n    module.exports = Interpolation2D;\n\n"]},"metadata":{},"sourceType":"script"}