{"ast":null,"code":"var is = require('../internals/is');\n\nvar ScaleMap = require('../math/ScaleMap');\n\nvar ColorList = require('./ColorList');\n\nvar ColorGradient = require('./ColorGradient');\n\nvar ToneMap;\n/**\n * ToneMap\n * @constructor\n * @param {Number} min `min` or `a`\n * @param {Number} max `max` or `b`\n * @param {toxi.color.ColorGradient|ColorList|TColor} g\n * @param {toxi.color.TColor} [colorB]\n * @param {Number} [resolution]\n *\n * @usages\n * new ToneMap( min, max, gradient );\n * or\n * new ToneMap( min, max, colorList );\n * or\n * new ToneMap( a, b, colorA, colorB );\n * or\n * new ToneMap( min, max, colorA, colorB, resolution );\n */\n\nToneMap = function (min, max, list, colorB, resolution) {\n  var al = arguments.length;\n\n  if (al > 3) {\n    //( a, b, colorA, colorB )\n    if (al === 4) {\n      list = new ColorList(list, colorB);\n    } else {\n      //( min, max, colorA, colorB, resolution )\n      var colA = list;\n      list = new ColorGradient();\n      list.addColorAt(0, colA);\n      list.addColorAt(resolution - 1, colorB);\n      list = list.calcGradient(0, resolution);\n    } //by now all of the variables are syphoned down to min, max, colorList\n\n  } //( min, max, gradient ) or\n  //( min, max, colorlist )\n\n\n  if (is.ColorGradient(list)) {\n    //make it a colorlist\n    list = list.calcGradient();\n  }\n\n  this.map = new ScaleMap(min, max, 0, list.size() - 1);\n  this.colors = list;\n};\n\nToneMap.prototype = {\n  constructor: ToneMap,\n  getARGBToneFor: function (t) {\n    return this.getToneFor(t).toARGB();\n  },\n\n  /**\n  * get a color from a tonal value\n  * @param {Number} t\n  * @return {toxi.color.TColor}\n  */\n  getToneFor: function (t) {\n    var idx;\n\n    if (this.colors.size() > 2) {\n      idx = Math.floor(this.map.getClippedValueFor(t) + 0.5);\n    } else {\n      idx = t >= this.map.getInputMedian() ? 1 : 0;\n    }\n\n    return this.colors.get(idx);\n  },\n\n  /**\n  * Applies the tonemap to all elements in the given source array of\n  * values and places the resulting ARGB color in the corresponding\n  * index of the target pixel buffer. If the target buffer is null, a new one\n  * will be created automatically.\n  *\n  * @param {Array<Number>}src source array of values to be tone mapped\n  * @param {Array<Number>}pixels target pixel buffer\n  * @param {Number} [offset] optionally provide an index-offset to start\n  * at in the destination pixels array\n  * @return pixel array\n  */\n  getToneMappedArray: function (src, pixels, offset) {\n    if (typeof offset !== 'number') {\n      offset = 0;\n    } else if (offset < 0) {\n      throw new Error(\"offset into target pixel array is negative\");\n    }\n\n    pixels = pixels || new Array(src.length);\n\n    for (var i = 0, l = src.length; i < l; i++) {\n      pixels[offset++] = this.getToneFor(src[i]).toARGB();\n    }\n\n    return pixels;\n  },\n\n  /**\n   * @param {toxi.math.InterpolateStrategy} func\n   */\n  setMapFunction: function (func) {\n    this.map.setMapFunction(func);\n  }\n};\nmodule.exports = ToneMap;","map":{"version":3,"sources":["C:/Users/jonlu/node_modules/toxiclibsjs/color/ToneMap.js"],"names":["is","require","ScaleMap","ColorList","ColorGradient","ToneMap","min","max","list","colorB","resolution","al","arguments","length","colA","addColorAt","calcGradient","map","size","colors","prototype","constructor","getARGBToneFor","t","getToneFor","toARGB","idx","Math","floor","getClippedValueFor","getInputMedian","get","getToneMappedArray","src","pixels","offset","Error","Array","i","l","setMapFunction","func","module","exports"],"mappings":"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","sourcesContent":["var is = require('../internals/is');\nvar ScaleMap = require('../math/ScaleMap');\nvar ColorList = require('./ColorList');\nvar ColorGradient = require('./ColorGradient');\n\n    var ToneMap;\n    /**\n     * ToneMap\n     * @constructor\n     * @param {Number} min `min` or `a`\n     * @param {Number} max `max` or `b`\n     * @param {toxi.color.ColorGradient|ColorList|TColor} g\n     * @param {toxi.color.TColor} [colorB]\n     * @param {Number} [resolution]\n     *\n     * @usages\n     * new ToneMap( min, max, gradient );\n     * or\n     * new ToneMap( min, max, colorList );\n     * or\n     * new ToneMap( a, b, colorA, colorB );\n     * or\n     * new ToneMap( min, max, colorA, colorB, resolution );\n     */\n    ToneMap = function( min, max, list, colorB, resolution ){\n        var al = arguments.length;\n        if( al > 3 ){\n            //( a, b, colorA, colorB )\n            if( al === 4 ){\n                list = new ColorList( list, colorB );\n            } else {\n                //( min, max, colorA, colorB, resolution )\n                var colA = list;\n                list = new ColorGradient();\n                list.addColorAt(0, colA);\n                list.addColorAt(resolution-1, colorB);\n                list = list.calcGradient(0, resolution);\n            }\n        //by now all of the variables are syphoned down to min, max, colorList\n        }\n        //( min, max, gradient ) or\n        //( min, max, colorlist )\n        if( is.ColorGradient( list ) ){\n            //make it a colorlist\n            list = list.calcGradient();\n        }\n        this.map = new ScaleMap( min, max, 0, list.size()-1 );\n        this.colors = list;\n    };\n\n    ToneMap.prototype = {\n        constructor: ToneMap,\n        getARGBToneFor: function( t  ){\n            return this.getToneFor(t).toARGB();\n        },\n        /**\n        * get a color from a tonal value\n        * @param {Number} t\n        * @return {toxi.color.TColor}\n        */\n        getToneFor: function( t ){\n            var idx;\n            if( this.colors.size() > 2 ){\n                idx = Math.floor( this.map.getClippedValueFor(t) + 0.5 );\n            } else {\n                idx = t >= this.map.getInputMedian() ? 1 : 0;\n            }\n            return this.colors.get(idx);\n        },\n        /**\n        * Applies the tonemap to all elements in the given source array of\n        * values and places the resulting ARGB color in the corresponding\n        * index of the target pixel buffer. If the target buffer is null, a new one\n        * will be created automatically.\n        *\n        * @param {Array<Number>}src source array of values to be tone mapped\n        * @param {Array<Number>}pixels target pixel buffer\n        * @param {Number} [offset] optionally provide an index-offset to start\n        * at in the destination pixels array\n        * @return pixel array\n        */\n        getToneMappedArray: function( src, pixels, offset ){\n            if( typeof offset !== 'number'){\n                offset = 0;\n            } else if ( offset < 0 ){\n                throw new Error(\"offset into target pixel array is negative\");\n            }\n            pixels = pixels || new Array(src.length);\n            for(var i=0, l=src.length; i<l; i++){\n                pixels[offset++] = this.getToneFor(src[i]).toARGB();\n            }\n            return pixels;\n        },\n        /**\n         * @param {toxi.math.InterpolateStrategy} func\n         */\n        setMapFunction: function( func ){\n            this.map.setMapFunction( func );\n        }\n    };\n\n    module.exports = ToneMap;\n\n\n"]},"metadata":{},"sourceType":"script"}